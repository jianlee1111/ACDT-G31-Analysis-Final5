# -*- coding: utf-8 -*-
"""acdt_g31

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F5fm0D95_3CLMpKv3LVVCJCWz4Vwmcv_
"""

import warnings
warnings.filterwarnings("ignore")

import streamlit as st
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import statsmodels.formula.api as smf
from difflib import get_close_matches

st.set_page_config(page_title="ACDT G31 – GERD(2020) → GDP(2023)", layout="wide")

DATA_FILE = "ACDT_final_dataset.csv"

# 변수명은 데이터셋에 있는 실제 컬럼명을 정확히 맞춤
GDP_NAME  = "Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)"
GERD_NAME = "Gross Domestic Expenditure on R&D (GERD) (current PPP USD)"

# Colab 시각화 코드에서 쓰인 주요 변수명 및 연도를 코드 변수로 정의
MEDIATOR_NAMES = [
    "Resident Patent Applications",
    "Non-Resident Patent Applications",
    "Business R&D Personnel (FTE)";
]

CONFOUNDER_NAMES = [
    "GDP per Capita",
    "Labor Force Size",
]

MODERATOR_NAMES = [
    "Share of Government-Financed BERD (%)",
    "Share of Business-Financed BERD (%)",
]

X_YEAR = 2020  # GERD 기준 연도
Y_YEAR = 2023  # GDP 등 나머지 변수 기준 연도

@st.cache_data
def safe_read_csv(path, debug=False):
    # 다중 인코덱 지원 및 중복 컬럼 평균 처리
    raw, last_err = None, None
    for enc in ("utf-8-sig", "cp949"):
        try:
            raw = pd.read_csv(path, header=None, encoding=enc, engine="python")
            break
        except Exception as e:
            last_err = e
    if raw is None:
        raise RuntimeError(f"Failed to load CSV: {last_err}")

    if debug:
        st.subheader("Raw CSV preview")
        st.write(f"Shape: {raw.shape}")
        st.write("Years row (first 30):", raw.iloc[0].tolist()[:30])
        st.write("Indicators row (first 30):", raw.iloc[1].tolist()[:30])
        st.dataframe(raw.iloc[:6, :30])
        st.stop()

    # 단일 컬럼 문자열 분리 처리
    if raw.shape[1] == 1:
        sample = "\n".join(raw.iloc[:5, 0].astype(str).tolist())
        sep = next((s for s in [",", "\t", ";", "|"] if s in sample), None)
        if sep:
            raw = raw.iloc[:, 0].astype(str).str.split(sep, expand=True)

    years = raw.iloc[0].astype(str).str.strip()
    indicators = raw.iloc[1].astype(str).str.strip()
    df = raw.iloc[2:].copy()
    df.columns = pd.MultiIndex.from_arrays([indicators, years])

    def clean_col(col):
        col = col.astype(str).str.replace(",", "").str.replace(r"[^0-9.eE+\-]", "", regex=True)
        return pd.to_numeric(col, errors="coerce")

    for col in df.columns:
        df[col] = clean_col(df[col])

    # 년도 컬럼 int로 캐스팅 시도
    new_cols = []
    for ind, yr in df.columns:
        try:
            yv = int(float(yr))
        except:
            yv = yr
        new_cols.append((ind, yv))
    df.columns = pd.MultiIndex.from_tuples(new_cols)

    # 중복 컬럼 평균으로 병합
    if df.columns.duplicated(keep=False).any():
        df = df.T.groupby(level=[0,1]).mean(numeric_only=True).T
        df.index = pd.RangeIndex(len(df))

    return df

def get_column(df: pd.DataFrame, indicator: str, year) -> pd.Series:
    level0 = df.columns.get_level_values(0)
    if indicator in set(level0):
        sub = df.loc[:, indicator]
        cols = list(sub.columns) if hasattr(sub, "columns") else []
        if year in cols:
            return df.loc[:, (indicator, year)]
    return pd.Series([np.nan]*len(df), index=df.index)

def build_dataset(df: pd.DataFrame):
    out = pd.DataFrame(index=df.index)
    out["GERD"] = get_column(df, GERD_NAME, X_YEAR)
    out["GDP"] = get_column(df, GDP_NAME, Y_YEAR)
    for v in CONFOUNDER_NAMES + MEDIATOR_NAMES + MODERATOR_NAMES:
        out[v] = get_column(df, v, Y_YEAR)
    out["ln_GERD"] = np.log(out["GERD"].replace(0, np.nan))
    out["ln_GDP"] = np.log(out["GDP"].replace(0, np.nan))
    out = out.dropna(subset=["ln_GERD", "ln_GDP"]).reset_index(drop=True)
    return out

def run_regressions(df: pd.DataFrame):
    confs = [c for c in CONFOUNDER_NAMES if c in df.columns]
    meds = [m for m in MEDIATOR_NAMES if m in df.columns]
    mods = [m for m in MODERATOR_NAMES if m in df.columns]

    m1 = smf.ols("ln_GDP ~ ln_GERD", data=df).fit()
    rhs2 = "ln_GERD" + ((" + " + " + ".join(f'Q("{c}")' for c in confs)) if confs else "")
    m2 = smf.ols(f"ln_GDP ~ {rhs2}", data=df).fit()
    rhs3 = rhs2 + ((" + " + " + ".join(f'Q("{m}")' for m in meds)) if meds else "")
    m3 = smf.ols(f"ln_GDP ~ {rhs3}", data=df).fit()
    interact = " + ".join(f'ln_GERD * Q("{mo}")' for mo in mods) if mods else ""
    rhs4 = rhs3 + ((" + " + interact) if interact else "")
    m4 = smf.ols(f"ln_GDP ~ {rhs4}", data=df).fit()

    def extract_stats(model, key="ln_GERD"):
        return model.params.get(key, np.nan), model.pvalues.get(key, np.nan), model.rsquared_adj

    rows = []
    for label, model in [("M1", m1), ("M2", m2), ("M3", m3), ("M4", m4)]:
        b, p, r2 = extract_stats(model)
        rows.append([label, b, p, r2])
    summary_df = pd.DataFrame(rows, columns=["Model", "Beta", "p-value", "Adj R2"]).round(4)
    return {"M1": m1, "M2": m2, "M3": m3, "M4": m4}, summary_df

# === Streamlit UI ===

st.title("ACDT G31 – GERD(2020) → GDP(2023) 회귀분석 및 시각화")

debug = st.sidebar.checkbox("디버그: 원본 CSV 헤더 미리보기 후 멈춤", False)

try:
    df_multi = safe_read_csv(DATA_FILE, debug=debug)
except Exception as e:
    st.error(f"데이터 로딩 실패: {e}")
    st.stop()

if debug:
    st.info("디버그 모드 활성화, 앱 임시 중단")
    st.stop()

all_indicators = sorted(set(df_multi.columns.get_level_values(0)))
required_vars = [GDP_NAME, GERD_NAME] + MEDIATOR_NAMES + CONFOUNDER_NAMES + MODERATOR_NAMES
missing_variables = [v for v in required_vars if v not in all_indicators]

if missing_variables:
    st.warning("다음 지표명들이 데이터 셋에 없습니다. 철자/기호/공백을 확인해주세요:")
    for miss in missing_variables:
        candidates = get_close_matches(miss, all_indicators, n=3, cutoff=0.6)
        st.write(f"- `{miss}` → 후보: {candidates}")

st.header("기초 통계 및 상관관계")
flat_df = df_multi.copy()
flat_df.columns = [f"{a} [{b}]" for a, b in flat_df.columns]
num_df = flat_df.select_dtypes(include=np.number)
if not num_df.empty:
    st.write(num_df.describe().T)
    try:
        fig, ax = plt.subplots(figsize=(12, 7))
        sns.heatmap(num_df.corr(), cmap="coolwarm", center=0, ax=ax)
        ax.set_title("상관관계 행렬")
        st.pyplot(fig)
    except Exception:
        st.info("상관관계 시각화는 생략되었습니다.")
else:
    st.info("숫자형 변수가 없습니다.")

regression_df = build_dataset(df_multi)
if regression_df.empty:
    st.error("회귀분석용 데이터가 없습니다. 지표명과 연도를 정확히 확인하세요.")
    st.stop()

st.subheader("회귀 분석용 데이터 미리보기")
st.dataframe(regression_df.head())

st.subheader("ln(GERD)와 ln(GDP) 산점도")
fig_scat, ax_scat = plt.subplots(figsize=(7, 5))
sns.regplot(x="ln_GERD", y="ln_GDP", data=regression_df, scatter_kws={"alpha": 0.6}, ax=ax_scat)
ax_scat.set_xlabel(f"ln {GERD_NAME} ({X_YEAR})")
ax_scat.set_ylabel(f"ln {GDP_NAME} ({Y_YEAR})")
st.pyplot(fig_scat)

models, summary_df = run_regressions(regression_df)
st.subheader("회귀 모델 요약")
st.dataframe(summary_df)

fig_bar, ax_bar = plt.subplots(figsize=(6, 4))
sns.barplot(x="Model", y="Adj R2", data=summary_df, ax=ax_bar)
ymax = float(summary_df["Adj R2"].max()) if not summary_df.empty else 1.0
ax_bar.set_ylim(0, max(0.1, ymax) * 1.1)
ax_bar.set_title("모델별 조정 결정계수(Adj R2)")
st.pyplot(fig_bar)

with st.expander("모델별 회귀 상세 결과 보기"):
    for lbl, mdl in models.items():
        st.markdown(f"**{lbl}**")
        st.text(mdl.summary())

st.markdown("""
### 요약
- 원본 Colab 대비 개선점 및 변경사항:
  - CSV 중복 및 헤더 변형 자동 평균 처리 추가
  - 변수명 대응 정확성 및 근사치 추천 기능 내장
  - Series/DataFrame 조건 검사 명확화로 에러 방지
  - 최신 Streamlit 시각화 및 UI 전체 개선
  - 원시 데이터 헤더 즉시 확인 가능한 디버그 모드 포함
- 포함된 기능:
  - 로그변환 단순 및 다중 회귀모형 (confounder, mediator, moderator 포함)
  - 상관관계 히트맵, 산점도, 회귀결과 비교표, 상세회귀결과 확장 출력
""")