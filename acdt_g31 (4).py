# -*- coding: utf-8 -*-
"""ACDT G31

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y-AHolMDNw6lQo2MBcySd3kqYQaFPCSg
"""

# -*- coding: utf-8 -*-
"""ACDT G31 Analysis

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RU-6NtWM8qAxq4adpXEcF6SHTJOdEbdL

# **Topic: Real GDP and R&D research**
"""

# This code should be saved as a Python file (e.g., app.py) and run from your terminal
# using the command: streamlit run app.py

import streamlit as st
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import statsmodels.formula.api as smf
import pandas as pd
import io

# Set the page configuration
st.set_page_config(page_title="Real GDP and R&D Research Analysis", layout="wide")

# Add a main title to the app
st.title("Analysis of Real GDP and R&D Research")

# Add a sidebar with a brief description
st.sidebar.header("About")
st.sidebar.write(
    "This application analyzes the relationship between Real GDP and R&D research, "
    "including simple linear regression, correlation analysis, and multiple linear regression models."
)

# Define the data path (replace with your actual path)
# If running in Google Colab with Google Drive mounted, this path should work.
# If running locally, adjust the path to where your data file is located.
@st.cache_data
def load_and_preprocess_data():
    """
    Loads the dataset from the local directory (same folder as the Streamlit app)
    and preprocesses it for analysis.

    Returns:
        pd.DataFrame: The preprocessed DataFrame.
    """
    try:
        # Load dataset directly from the same directory as your Streamlit app
        df = pd.read_csv("ACDT final data set22.xlsx - 데이터 (1).csv", encoding="utf-8")

        # Clean all columns except the first one ('Country') and skip the first two metadata rows
        for col in df.columns[1:]:
            # Convert from the 3rd row onward to strings and remove non-numeric characters
            # Using .loc for explicit row selection to avoid SettingWithCopyWarning
            df.loc[2:, col] = df.loc[2:, col].astype(str).str.replace('[^0-9.-]', '', regex=True)
            df.loc[2:, col] = pd.to_numeric(df.loc[2:, col], errors='coerce')

        # Create a dictionary to identify relevant variables in the dataset
        variable_cols = {}

        # Define keywords to map raw column names to standardized variable labels
        keywords = {
            'Resident Patent Applications': 'Resident Patent Applications',
            'Non-Resident Patent Applications': 'Non-Resident Patent Applications',
            'Number of R&D Researcher': 'Number of R&D Researchers (per million people)',
            'High-Tech Export Share': 'High-Tech Export Share (% of manufacturing exports)',
            'Business R&D Personnel (FTE)': 'Business R&D Personnel (FTE)',
            'Real GDP': 'Real GDP',
            'Total Population': 'Total Population',
            'Labor Force': 'Labor Force Size',
            'Government-Financed BERD (%)': 'Share of Government-Financed BERD (%)',
            'Business-Financed BERD (%)': 'Share of Business-Financed BERD (%)',
            'Business R&D Personnel (FTE) per 1,000 Employed': 'Business R&D Personnel (FTE) per 1,000 Employed'
        }

        st.success("Data successfully loaded and preprocessed!")
        return df

    except FileNotFoundError:
        st.error("Data file not found. Please make sure the CSV file is uploaded to the GitHub repository root.")
        return None

     # Iterate through columns to find matches based on keywords in the first row content
        for col in df.columns:
            first_row_value = df.iloc[0][col]
            if isinstance(first_row_value, str):
                # Check for each keyword in the first row value
                for keyword, var_name in keywords.items():
                    if keyword in first_row_value:
                        # For 'Real GDP', prioritize later years
                        if var_name == 'Real GDP':
                            year = str(col).split('.')[0] if '.' in str(col) else str(col)
                            try:
                                year_int = int(year)
                                # Keep the latest identified GDP year if multiple are found
                                if var_name not in variable_cols or (isinstance(variable_cols[var_name], str) and int(variable_cols[var_name].split('.')[0] if '.' in variable_cols[var_name] else variable_cols[var_name]) < year_int):
                                    variable_cols[var_name] = col
                            except ValueError:
                                # Handle cases where the column name before the dot is not a year
                                pass
                        # For other variables, assign the first column found containing the keyword
                        elif var_name not in variable_cols:
                            variable_cols[var_name] = col


        # Create a new DataFrame with the '국가별' column and the identified variable columns
        # Ensure all identified columns are actually present in the original dataframe before selection
        selected_cols = ['국가별'] + [col for col in variable_cols.values() if col in df.columns]
        df_cleaned = df.loc[:, selected_cols].copy()

        # Remove the first two rows which contain header information
        df_cleaned = df_cleaned.iloc[2:].copy()

        # Rename columns to be more descriptive using the keys from variable_cols
        # Create a mapping from the original column names to the desired variable names
        col_rename_map = {v: k for k, v in variable_cols.items() if v in df_cleaned.columns}
        df_cleaned.rename(columns=col_rename_map, inplace=True)

        # Iterate through the variable columns (excluding '국가별') and clean the data
        for col in df_cleaned.columns:
            if col != '국가별':
                # Convert the data to string type to handle potential mixed data types
                df_cleaned[col] = df_cleaned[col].astype(str)

                # Remove non-numeric characters (keep digits, periods, and hyphens)
                df_cleaned[col] = df_cleaned[col].str.replace('[^0-9.-]', '', regex=True)

                # Convert to numeric, coercing errors to NaN
                df_cleaned[col] = pd.to_numeric(df_cleaned[col], errors='coerce')

        # Handle missing values by dropping rows with NaNs in the variable columns
        variable_column_names = [col for col in df_cleaned.columns if col != '국가별']
        df_cleaned.dropna(subset=variable_column_names, inplace=True)

        return df_cleaned

    except FileNotFoundError:
        st.error(f"Error: Data file not found")
        return pd.DataFrame() # Return an empty DataFrame on error
    except Exception as e:
        st.error(f"An error occurred during data loading and preprocessing: {e}")
        return pd.DataFrame() # Return an empty DataFrame on error


# Load and preprocess the data using the cached function
df_cleaned = load_and_preprocess_data()

# Display the cleaned data and its info in the Streamlit app
if not df_cleaned.empty:
    st.header("Cleaned Data Preview")
    st.dataframe(df_cleaned.head())

    st.header("Data Information")
    # Redirect df.info() output to a string to display in Streamlit
    buffer = io.StringIO()
    df_cleaned.info(buf=buffer)
    s = buffer.getvalue()
    st.text(s)

    # Add section for Descriptive Statistics and Visualizations
    st.header("Descriptive Statistics and Variable Distributions")

    # Add markdown text for Descriptive Statistics
    st.markdown("""
    ## Descriptive statistics

    mean, median, standard deviation, etc. for each of the cleaned variables.
    """)

    # Select only numeric columns from the cleaned DataFrame
    df_numeric = df_cleaned.select_dtypes(include=np.number)

    if not df_numeric.empty:
        # Calculate descriptive statistics for the numeric columns
        descriptive_stats = df_numeric.describe()

        # Display the descriptive statistics using st.dataframe()
        st.dataframe(descriptive_stats)

        # Add markdown text for Distribution of Confounder, Moderater and Mediater
        st.markdown("""
        # Distribution of Confounder, Moderater and Mediater
        """)

        # Iterate through the numeric columns and create visualizations
        for col in df_numeric.columns:
            # Add a title for the current variable's visualization
            st.subheader(f"Distribution of {col}")

            # Create a figure with two subplots (histogram and box plot)
            fig, axes = plt.subplots(1, 2, figsize=(15, 5))

            # Plot Histogram
            sns.histplot(data=df_numeric, x=col, kde=True, ax=axes[0])
            axes[0].set_title(f'Distribution of {col}')
            axes[0].set_xlabel(col)
            axes[0].set_ylabel('Frequency')

            # Plot Box Plot
            sns.boxplot(data=df_numeric, x=col, ax=axes[1])
            axes[1].set_title(f'Box Plot of {col}')
            axes[1].set_xlabel(col)
            axes[1].set_ylabel('Value')

            plt.tight_layout()

            # Display the generated plot using st.pyplot()
            st.pyplot(fig)

            # Close the figure to free up memory
            plt.close(fig)
    else:
        st.warning("No numeric columns found in the cleaned data to calculate descriptive statistics or visualize distributions.")

    # Add section for Correlation Analysis
    st.header("Correlation Analysis")

    # Add markdown text for Correlation between datasets
    st.markdown("""
    # Correlation between datasets
    """)

    if not df_numeric.empty:
        # Calculate the correlation matrix
        correlation_matrix = df_numeric.corr()

        # Create a heatmap of the correlation matrix
        fig, ax = plt.subplots(figsize=(12, 10))
        sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=".5", ax=ax)
        ax.set_title('Correlation Matrix of Socio-Economic Variables')

        # Display the generated plot using st.pyplot()
        st.pyplot(fig)
        plt.close(fig)
    else:
        st.warning("No numeric data available to compute correlation matrix.")

    # Add section for Regression Models
    st.header("Multiple Linear Regression Models")

    # Add markdown text for Building Multiple Linear Regression Models
    st.markdown("""
    ## 4. Building Multiple Linear Regression Models
    Using `statsmodels.formula.api.ols`, build the four specified regression models and print their summaries.
    """)

    # Ensure df_regression_renamed DataFrame exists and is not empty
    # This part assumes df_regression_renamed is prepared with log transformations and renamed columns
    # Re-create df_regression_renamed with log transformations for this section
    df = pd.read_csv("ACDT final data set22.xlsx - 데이터 (1).csv", encoding="utf-8") # Reload df to ensure it's available

    df_regression = df.copy()
    df_regression = df_regression.iloc[2:].copy()

    regression_keywords = {
        'Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)': 'Real GDP',
        'Gross Domestic Expenditure on R&D (GERD) (current PPP USD)': 'GERD',
        'Resident Patent Applications': 'Resident Patent Applications',
        'Non-Resident Patent Applications': 'Non-Resident Patent Applications',
        'Number of R&D Researcher': 'R&D Researchers per Million People',
        'High-Tech Export Share (as % of Manufacturing exports)': 'High-tech Export Share (% of Manufactured Exports)',
        'Business R&D Personnel (FTE)': 'Business R&D Personnel (FTE)',
        'GDP per Capita': 'GDP per Capita',
        'Total Population': 'Total Population',
        'Labor Force': 'Labor Force Size',
        'Share of Government-Financed BERD (%)': 'Government-financed BERD (%)',
        'Share of Business-Financed BERD (%)': 'Business-financed BERD (%)',
        'Business R&D Personnel (FTE) per 1,000 Employed': 'R&D Personnel per 1,000 Employees'
    }

    regression_cols = {}
    for col in df_regression.columns:
        first_row_value = df.iloc[0][col]
        if isinstance(first_row_value, str):
             for keyword, var_name in regression_keywords.items():
                if keyword in first_row_value:
                    if keyword in ['Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)', 'Gross Domestic Expenditure on R&D (GERD) (current PPP USD)']:
                        if var_name not in regression_cols:
                            regression_cols[var_name] = col
                    elif var_name not in regression_cols:
                         regression_cols[var_name] = col

    selected_regression_cols = ['국가별'] + [col for col in regression_cols.values() if col in df_regression.columns]
    df_regression = df_regression.loc[:, selected_regression_cols].copy()

    col_rename_map_regression = {v: k for k, v in regression_cols.items()}
    df_regression_renamed = df_regression.rename(columns=col_rename_map_regression)

    for col in df_regression_renamed.columns:
        if col != '국가별':
            df_regression_renamed[col] = df_regression_renamed[col].astype(str).str.replace('[^0-9.-]', '', regex=True)
            df_regression_renamed[col] = pd.to_numeric(df_regression_renamed[col], errors='coerce')

    df_regression_renamed.dropna(subset=[col for col in df_regression_renamed.columns if col != '국가별'], inplace=True)

    if 'Real GDP' in df_regression_renamed.columns:
        df_regression_renamed['Log_Real_GDP'] = np.log(df_regression_renamed['Real GDP'] + 1e-9)
    else:
        st.warning("Warning: 'Real GDP' column not found for log transformation.")

    if 'GERD' in df_regression_renamed.columns:
        df_regression_renamed['Log_GERD'] = np.log(df_regression_renamed['GERD'] + 1e-9)
    else:
         st.warning("Warning: 'GERD' column not found for log transformation.")


    if not df_regression_renamed.empty and 'Log_Real_GDP' in df_regression_renamed.columns and 'Log_GERD' in df_regression_renamed.columns:

        # Model 1: log_GDP ~ log_GERD (simple regression)
        st.subheader("Model 1: Simple Regression")
        try:
            model_1_formula = 'Log_Real_GDP ~ Log_GERD'
            model_1 = smf.ols(model_1_formula, data=df_regression_renamed).fit()
            st.text(model_1.summary().as_text())
            st.markdown("Interpretation: Model 1 estimates the simple linear relationship between Log(GERD) and Log(Real GDP). The regression coefficient (β₁) is positive and statistically significant (p < 0.05), indicating that as GERD increases, Real GDP tends to increase correspondingly. The Adjusted R² is approximately 0.494, suggesting that Log(GERD) explains about 49.4% of the variance in Log(Real GDP). Thus, GERD can be considered a major explanatory factor contributing to economic growth.")
        except Exception as e:
            st.error(f"Error building Model 1: {e}")
            model_1 = None
        st.markdown("---")

        # Model 2: log_GDP ~ log_GERD + GDP_per_Capita + Population_Labor_Size (confounders)
        st.subheader("Model 2: Adding Confounders")
        try:
            confounder_vars = ['GDP per Capita'] # Use the original column name based on previous identification
            confounder_vars_formula = ' + '.join([var for var in confounder_vars if var in df_regression_renamed.columns])

            if confounder_vars_formula:
                model_2_formula = f'Log_Real_GDP ~ Log_GERD + {confounder_vars_formula}'
                model_2 = smf.ols(model_2_formula, data=df_regression_renamed).fit()
                st.text(model_2.summary().as_text())
                st.markdown("Interpretation: Model 2 adds GDP per Capita as a confounding variable to the basic model. The variables Total Population and Labor Force Size were unavailable in the dataset and therefore excluded. The analysis shows that GDP per Capita is statistically insignificant (p = 0.491), indicating that it does not have a meaningful impact on Real GDP in this model. Meanwhile, the coefficient for Log(GERD) remains statistically significant (p = 0.003), suggesting that the positive relationship between GERD and Real GDP persists even after controlling for GDP per Capita. The Adjusted R² slightly decreases to 0.476, possibly due to the added confounder not substantially improving explanatory power, or as a result of penalization for increased model complexity.")
            else:
                st.warning("Confounder variables not found in the dataset. Skipping Model 2.")
                model_2 = None
        except Exception as e:
            st.error(f"Error building Model 2: {e}")
            model_2 = None
        st.markdown("---")

        # Model 3: log_GDP ~ log_GERD + Patents + R&D_Researchers + Hightech_Exports + Business_R&D_Personnel (mediators)
        st.subheader("Model 3: Adding Mediators")
        try:
            mediator_vars = [
                'Resident Patent Applications', # Use original column name
                'Non-Resident Patent Applications', # Use original column name
                'Business R&D Personnel (FTE)' # Use original column name
            ]
            mediator_vars_formula = ' + '.join([var for var in mediator_vars if var in df_regression_renamed.columns])

            all_vars_formula_model3 = 'Log_GERD'
            if confounder_vars_formula:
                 all_vars_formula_model3 += ' + ' + confounder_vars_formula
            if mediator_vars_formula:
                 all_vars_formula_model3 += ' + ' + mediator_vars_formula


            if 'Log_GERD' in df_regression_renamed.columns and (confounder_vars_formula or mediator_vars_formula):
                model_3_formula = f'Log_Real_GDP ~ {all_vars_formula_model3}'
                model_3 = smf.ols(model_3_formula, data=df_regression_renamed).fit()
                st.text(model_3.summary().as_text())
                st.markdown("Interpretation: Model 3 includes mediating variables — Resident / Non-resident Patent Applications, R&D Researchers per Million People, High-tech Export Share (% of Manufactured Exports), and Business R&D Personnel (FTE) — in addition to Log(GERD) and GDP per Capita. The coefficient for Log(GERD) slightly decreases (β ≈ 0.380) but remains statistically significant (p = 0.020). This suggests that part of the relationship between GERD and Real GDP may be mediated by innovation, human capital, or technological diffusion. Among the mediators, Resident Patent Applications shows a near-significant result (p = 0.053), implying that domestic patent activity might partially explain how GERD affects Real GDP. Other mediators are not statistically significant. The Adjusted R² increases substantially to approximately 0.700, indicating that including mediating variables substantially improves the model’s explanatory power.")
            else:
                 st.warning("Mediator variables not found in the dataset or necessary confounders missing. Skipping Model 3.")
                 model_3 = None
        except Exception as e:
            st.error(f"Error building Model 3: {e}")
            model_3 = None
        st.markdown("---")


        # Model 4: log_GDP ~ log_GERD * GovFinanced_BERD + GDP_per_Capita + Population_Labor_Size (moderator interaction)
        st.subheader("Model 4: Adding Moderator Interaction")
        try:
            moderator_var = 'Government-financed BERD (%)' # Use original column name

            if moderator_var in df_regression_renamed.columns and confounder_vars_formula:
                 model_4_formula = f'Log_Real_GDP ~ Log_GERD * `{moderator_var}` + {confounder_vars_formula}' # Enclose in backticks for formula
                 model_4 = smf.ols(model_4_formula, data=df_regression_renamed).fit()
                 st.text(model_4.summary().as_text())
                 st.markdown("Interpretation: Model 4 adds an interaction term between Log(GERD) and Government-financed BERD (%) to test for a moderating effect. The interaction term (Log_GERD × GovFinanced_BERD_pct) is highly significant (p = 0.001), suggesting that the effect of GERD on Real GDP varies depending on the proportion of government-financed R&D expenditure. The coefficient for the interaction term (β = -0.0895) is negative, implying that as the share of government financing in R&D increases, the positive impact of GERD on Real GDP tends to weaken. The coefficient for Log(GERD) itself increases (β ≈ 1.070) compared to Model 3 and remains highly significant (p < 0.001). This represents the effect of GERD on Real GDP when the moderator (Government-financed BERD) equals zero. Given the significant interaction, the effect size of GERD should be interpreted conditionally on the level of government financing. The Adjusted R² further increases to approximately 0.775, showing that Model 4 provides the best overall explanatory power.")
            else:
                st.warning("Moderator variable or confounders not found. Skipping Model 4.")
                model_4 = None
        except Exception as e:
            st.error(f"Error building Model 4: {e}")
            model_4 = None
        st.markdown("---")

        # Generate Actual vs. Predicted Plot for Model 4
        st.header("Actual vs. Predicted Values Plot for Model 4")
        st.markdown("Generate a scatter plot of the actual values of the dependent variable (Log_Real_GDP) against the values predicted by Model 4, with a line of perfect fit.")

        if 'model_4' in locals() and model_4 is not None:
             try:
                actual_gdp = df_regression_renamed['Log_Real_GDP']
                predicted_gdp = model_4.predict(df_regression_renamed)

                fig, ax = plt.subplots(figsize=(8, 6))
                sns.scatterplot(x=predicted_gdp, y=actual_gdp, alpha=0.6, ax=ax)
                ax.plot([actual_gdp.min(), actual_gdp.max()], [actual_gdp.min(), actual_gdp.max()], color='red', linestyle='--', lw=2, label='Perfect Fit')
                ax.set_title('Actual vs. Predicted Log(Real GDP) (Model 4)')
                ax.set_xlabel('Predicted Log(Real GDP)')
                ax.set_ylabel('Actual Log(Real GDP)')
                ax.legend()
                ax.grid(True)
                st.pyplot(fig)
                plt.close(fig)
             except Exception as e:
                 st.error(f"Error generating Actual vs. Predicted plot for Model 4: {e}")
        else:
             st.warning("Model 4 was not successfully built. Cannot generate actual vs. predicted values plot.")

        # Create Comparison Table
        st.header("Regression Model Comparison")
        st.markdown("Generate a table comparing the Adjusted R² and the coefficient (β) of log(GERD) across all four models.")

        results_dict = {}
        if 'model_1' in locals() and model_1:
            results_dict['Model 1'] = {
                'Adjusted R-squared': model_1.rsquared_adj,
                'Beta (Log_GERD)': model_1.params.get('Log_GERD', 'N/A')
            }
        if 'model_2' in locals() and model_2:
            results_dict['Model 2'] = {
                'Adjusted R-squared': model_2.rsquared_adj,
                'Beta (Log_GERD)': model_2.params.get('Log_GERD', 'N/A')
            }
        if 'model_3' in locals() and model_3:
            results_dict['Model 3'] = {
                'Adjusted R-squared': model_3.rsquared_adj,
                'Beta (Log_GERD)': model_3.params.get('Log_GERD', 'N/A')
            }
        if 'model_4' in locals() and model_4:
             results_dict['Model 4'] = {
                'Adjusted R-squared': model_4.rsquared_adj,
                'Beta (Log_GERD)': model_4.params.get('Log_GERD', 'N/A')
            }

        if results_dict:
            comparison_table = pd.DataFrame.from_dict(results_dict, orient='index')
            st.dataframe(comparison_table)
        else:
            st.warning("No models were successfully built to create a comparison table.")

        # Generate Visualizations
        st.header("Regression Analysis Visualizations")
        st.markdown("""
        Generate clear visualizations using Matplotlib/Seaborn:
        - Scatter plot of log(GERD) vs. log(GDP) with regression line.
        - Histogram of residuals for the final model (Model 4).
        - Bar chart comparing Adjusted R² across models.
        """)

        # Scatter plot of log(GERD) vs. log(GDP) with regression line (already generated above, but can be repeated here for clarity)
        st.subheader("Scatter Plot of Log(GERD) vs Log(Real GDP)")
        fig, ax = plt.subplots(figsize=(10, 6))
        sns.regplot(data=df_regression_renamed, x='Log_GERD', y='Log_Real_GDP', scatter_kws={'alpha': 0.6}, ax=ax)
        ax.set_title('Scatter Plot of Log(GERD) vs Log(Real GDP)')
        ax.set_xlabel('Log of Gross Domestic Expenditure on R&D (GERD)')
        ax.set_ylabel('Log of Real GDP')
        ax.grid(True)
        st.pyplot(fig)
        plt.close(fig)

        # Histogram of residuals for the final model (Model 4)
        st.subheader("Histogram of Residuals for Model 4")
        if 'model_4' in locals() and model_4:
            try:
                residuals = model_4.resid
                fig, ax = plt.subplots(figsize=(8, 6))
                sns.histplot(residuals, kde=True, ax=ax)
                ax.set_title('Histogram of Residuals for Model 4')
                ax.set_xlabel('Residuals')
                ax.set_ylabel('Frequency')
                st.pyplot(fig)
                plt.close(fig)
            except Exception as e:
                st.error(f"Error generating residuals histogram for Model 4: {e}")
        else:
            st.warning("Model 4 was not successfully built. Skipping residuals histogram.")

        # Bar chart comparing Adjusted R² across models
        st.subheader("Comparison of Adjusted R-squared Across Regression Models")
        if results_dict:
            models = list(results_dict.keys())
            adjusted_r_squared_values = [results_dict[model]['Adjusted R-squared'] for model in models]

            fig, ax = plt.subplots(figsize=(10, 6))
            sns.barplot(x=models, y=adjusted_r_squared_values, palette='viridis', ax=ax)
            ax.set_title('Comparison of Adjusted R-squared Across Regression Models')
            ax.set_xlabel('Regression Model')
            ax.set_ylabel('Adjusted R-squared')
            ax.set_ylim(0, max(adjusted_r_squared_values) * 1.1)
            st.pyplot(fig)
            plt.close(fig)
        else:
            st.warning("No model results available to create Adjusted R-squared bar chart.")

        # Summarize Findings
        st.header("Summary of Findings")
        st.markdown("""
        This analysis was conducted to examine the causal impact of Gross Domestic Expenditure on R&D (GERD) on Real GDP.
        Four regression models were sequentially estimated, gradually adding confounding, mediating, and moderating variables to identify the underlying causal structure.
        The changes in regression coefficients, statistical significance, and explanatory power (Adjusted R²) were analyzed to interpret the causal relationships.

        # Model 1: Simple Linear Regression (Log_Real_GDP ~ Log_GERD)

        Model 1 estimates the simple linear relationship between Log(GERD) and Log(Real GDP).
        The regression coefficient (β₁) is positive and statistically significant (p < 0.05), indicating that as GERD increases, Real GDP tends to increase correspondingly.
        The Adjusted R² is approximately 0.494, suggesting that Log(GERD) explains about 49.4% of the variance in Log(Real GDP).
        Thus, GERD can be considered a major explanatory factor contributing to economic growth.

        # Model 2: Adding a Confounding Variable (Log_Real_GDP ~ Log_GERD + GDP_per_Capita)

        Model 2 adds GDP per Capita as a confounding variable to the basic model.
        The variables Total Population and Labor Force Size were unavailable in the dataset and therefore excluded.

        The analysis shows that GDP per Capita is statistically insignificant (p = 0.491),
        indicating that it does not have a meaningful impact on Real GDP in this model.
        Meanwhile, the coefficient for Log(GERD) remains statistically significant (p = 0.003),
        suggesting that the positive relationship between GERD and Real GDP persists even after controlling for GDP per Capita.

        The Adjusted R² slightly decreases to 0.476, possibly due to the added confounder not substantially improving explanatory power, or as a result of penalization for increased model complexity.

        # Model 3: Adding Mediating Variables (Log_Real_GDP ~ Log_GERD + GDP_per_Capita + Innovation Variables)

        Model 3 includes mediating variables — Resident / Non-resident Patent Applications, R&D Researchers per Million People,
        High-tech Export Share (% of Manufactured Exports), and Business R&D Personnel (FTE) — in addition to Log(GERD) and GDP per Capita.

        The coefficient for Log(GERD) slightly decreases (β ≈ 0.380) but remains statistically significant (p = 0.020).
        This suggests that part of the relationship between GERD and Real GDP may be mediated by innovation, human capital, or technological diffusion.

        Among the mediators, Resident Patent Applications shows a near-significant result (p = 0.053), implying that domestic patent activity might partially explain how GERD affects Real GDP.
        Other mediators are not statistically significant.
        The Adjusted R² increases substantially to approximately 0.700, indicating that including mediating variables substantially improves the model’s explanatory power.

        # Model 4: Adding a Moderating Effect (Log_Real_GDP ~ Log_Real_GDP ~ Log_GERD * GovFinanced_BERD_pct + Mediators + Confounder)

        Model 4 adds an interaction term between Log(GERD) and Government-financed BERD (%) to test for a moderating effect.

        The interaction term (Log_GERD × GovFinanced_BERD_pct) is highly significant (p = 0.001),
        suggesting that the effect of GERD on Real GDP varies depending on the proportion of government-financed R&D expenditure.
        The coefficient for the interaction term (β = -0.0895) is negative, implying that as the share of government financing in R&D increases,
        the positive impact of GERD on Real GDP tends to weaken.

        The coefficient for Log(GERD) itself increases (β ≈ 1.070) compared to Model 3 and remains highly significant (p < 0.001).
        This represents the effect of GERD on Real GDP when the moderator (Government-financed BERD) equals zero.
        Given the significant interaction, the effect size of GERD should be interpreted conditionally on the level of government financing.
        The Adjusted R² further increases to approximately 0.775, showing that Model 4 provides the best overall explanatory power.

        # Key Findings and Implications

        1. Relationship between GERD and Real GDP
        Across all models, Log(GERD) consistently shows a statistically significant and positive relationship with Real GDP.
        This provides empirical support for the notion that R&D investment is a key driver of economic growth.
        2. Mediating Effects
        Resident Patent Applications partially mediate the relationship between GERD and Real GDP,
        suggesting that R&D expenditure contributes to economic growth indirectly through innovation activities.
        Other mediators were not statistically significant, indicating that the mediating strength may be limited.
        3. Moderating Effects
        Government-financed BERD (%) moderates the relationship between GERD and Real GDP.
        The positive effect of GERD on GDP tends to weaken as the proportion of government-financed R&D increases.
        This finding implies that the efficiency of R&D investment may vary depending on the balance between public and private funding structures.
        4. Model Fit Comparison
        The Adjusted R² values steadily improve as the models expand (0.494 → 0.476 → 0.700 → 0.775).
        This indicates that incorporating mediating and moderating variables yields a more comprehensive and accurate explanation of Real GDP fluctuations compared to a simple model.

        # Conclusion

        The multiple regression analysis demonstrates that GERD exerts a consistently positive impact on Real GDP.
        However, this effect operates through both indirect innovation pathways (e.g., patent applications)
        and conditional moderation effects depending on the level of government-financed R&D.

        The results reveal that the relationship is not a simple “R&D → Growth” linear link,
        but rather a multi-stage causal chain — “R&D → Innovation → Productivity → Growth” —
        that is further conditioned by policy environments such as government funding ratios.

        Therefore, future R&D policies should focus not merely on expanding total expenditure,
        but also on optimizing the qualitative composition of investment —
        balancing government and private funding, strengthening human capital, and promoting innovation output efficiency.
        """)

else:
    st.warning("Data could not be loaded or is empty after cleaning.")

# This code should be saved as a Python file (e.g., app.py) and run from your terminal
# using the command: streamlit run app.py

import streamlit as st
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import statsmodels.formula.api as smf
import pandas as pd
import io

# Set the page configuration
st.set_page_config(page_title="Real GDP and R&D Research Analysis", layout="wide")

# Add a main title to the app
st.title("Analysis of Real GDP and R&D Research")

# Add a sidebar with a brief description
st.sidebar.header("About")
st.sidebar.write(
    "This application analyzes the relationship between Real GDP and R&D research, "
    "including simple linear regression, correlation analysis, and multiple linear regression models."
)
import pandas as pd
import streamlit as st

@st.cache_data
def load_and_preprocess_data():
    """
    Loads and preprocesses the dataset for analysis and visualization in Streamlit.
    This function assumes the CSV file is located in the same directory as this app.

    Returns:
        pd.DataFrame: The cleaned and preprocessed dataset.
    """
    try:
        # Load dataset (adjust filename if necessary)
        df = pd.read_csv("ACDT final data set22.xlsx - 데이터 (1).csv", encoding="utf-8")

        # Clean all columns except the first ('국가별'), skip the first two header rows
        for col in df.columns[1:]:
            df.loc[2:, col] = df.loc[2:, col].astype(str).str.replace('[^0-9.-]', '', regex=True)
            df.loc[2:, col] = pd.to_numeric(df.loc[2:, col], errors='coerce')

        # Initialize variable dictionary (used later for labeling or renaming)
        variable_cols = {}

        # Define a dictionary mapping column keywords to human-readable variable names
        keywords = {
            'Resident Patent Applications': 'Resident Patent Applications',
            'Non-Resident Patent Applications': 'Non-Resident Patent Applications',
            'Number of R&D Researcher': 'Number of R&D Researchers (per million people)',
            'High-Tech Export Share': 'High-Tech Export Share (% of manufacturing exports)',
            'Business R&D Personnel (FTE)': 'Business R&D Personnel (FTE)',
            'Real GDP': 'Real GDP',
            'Total Population': 'Total Population',
            'Labor Force': 'Labor Force Size',
            'Government-Financed BERD (%)': 'Share of Government-Financed BERD (%)',
            'Business-Financed BERD (%)': 'Share of Business-Financed BERD (%)',
            'Business R&D Personnel (FTE) per 1,000 Employed': 'Business R&D Personnel (FTE) per 1,000 Employed'
        }

        # Display success message in Streamlit
        st.success(" Dataset successfully loaded and preprocessed!")
        return df

    except FileNotFoundError:
        st.error("Error: The data file could not be found. Please ensure it is uploaded to your repository root.")
        return pd.DataFrame()

    except Exception as e:
        st.error(f" An unexpected error occurred during data loading: {e}")
        return pd.DataFrame()

        # Iterate through columns to find matches based on keywords in the first row content
        for col in df.columns:
            first_row_value = df.iloc[0][col]
            if isinstance(first_row_value, str):
                # Check for each keyword in the first row value
                for keyword, var_name in keywords.items():
                    if keyword in first_row_value:
                        # For 'Real GDP', prioritize later years
                        if var_name == 'Real GDP':
                            year = str(col).split('.')[0] if '.' in str(col) else str(col)
                            try:
                                year_int = int(year)
                                # Keep the latest identified GDP year if multiple are found
                                if var_name not in variable_cols or (isinstance(variable_cols[var_name], str) and int(variable_cols[var_name].split('.')[0] if '.' in variable_cols[var_name] else variable_cols[var_name]) < year_int):
                                    variable_cols[var_name] = col
                            except ValueError:
                                # Handle cases where the column name before the dot is not a year
                                pass
                        # For other variables, assign the first column found containing the keyword
                        elif var_name not in variable_cols:
                            variable_cols[var_name] = col


        # Create a new DataFrame with the '국가별' column and the identified variable columns
        # Ensure all identified columns are actually present in the original dataframe before selection
        selected_cols = ['국가별'] + [col for col in variable_cols.values() if col in df.columns]
        df_cleaned = df.loc[:, selected_cols].copy()

        # Remove the first two rows which contain header information
        df_cleaned = df_cleaned.iloc[2:].copy()

        # Rename columns to be more descriptive using the keys from variable_cols
        # Create a mapping from the original column names to the desired variable names
        col_rename_map = {v: k for k, v in variable_cols.items() if v in df_cleaned.columns}
        df_cleaned.rename(columns=col_rename_map, inplace=True)

        # Iterate through the variable columns (excluding '국가별') and clean the data
        for col in df_cleaned.columns:
            if col != '국가별':
                # Convert the data to string type to handle potential mixed data types
                df_cleaned[col] = df_cleaned[col].astype(str)

                # Remove non-numeric characters (keep digits, periods, and hyphens)
                df_cleaned[col] = df_cleaned[col].str.replace('[^0-9.-]', '', regex=True)

                # Convert to numeric, coercing errors to NaN
                df_cleaned[col] = pd.to_numeric(df_cleaned[col], errors='coerce')

        # Handle missing values by dropping rows with NaNs in the variable columns
        variable_column_names = [col for col in df_cleaned.columns if col != '국가별']
        df_cleaned.dropna(subset=variable_column_names, inplace=True)

        return df_cleaned

    except FileNotFoundError:
        st.error(f"Error: Data file not found")
        return pd.DataFrame() # Return an empty DataFrame on error
    except Exception as e:
        st.error(f"An error occurred during data loading and preprocessing: {e}")
        return pd.DataFrame() # Return an empty DataFrame on error



# Display the cleaned data and its info in the Streamlit app
if not df_cleaned.empty:
    st.header("Cleaned Data Preview")
    st.dataframe(df_cleaned.head())

    st.header("Data Information")
    # Redirect df.info() output to a string to display in Streamlit
    buffer = io.StringIO()
    df_cleaned.info(buf=buffer)
    s = buffer.getvalue()
    st.text(s)

    # Add section for Descriptive Statistics and Visualizations
    st.header("Descriptive Statistics and Variable Distributions")

    # Add markdown text for Descriptive Statistics
    st.markdown("""
    ## Descriptive statistics

    mean, median, standard deviation, etc. for each of the cleaned variables.
    """)

    # Select only numeric columns from the cleaned DataFrame
    df_numeric = df_cleaned.select_dtypes(include=np.number)

    if not df_numeric.empty:
        # Calculate descriptive statistics for the numeric columns
        descriptive_stats = df_numeric.describe()

        # Display the descriptive statistics using st.dataframe()
        st.dataframe(descriptive_stats)

        # Add markdown text for Distribution of Confounder, Moderater and Mediater
        st.markdown("""
        # Distribution of Confounder, Moderater and Mediater
        """)

        # Iterate through the numeric columns and create visualizations
        for col in df_numeric.columns:
            # Add a title for the current variable's visualization
            st.subheader(f"Distribution of {col}")

            # Create a figure with two subplots (histogram and box plot)
            fig, axes = plt.subplots(1, 2, figsize=(15, 5))

            # Plot Histogram
            sns.histplot(data=df_numeric, x=col, kde=True, ax=axes[0])
            axes[0].set_title(f'Distribution of {col}')
            axes[0].set_xlabel(col)
            axes[0].set_ylabel('Frequency')

            # Plot Box Plot
            sns.boxplot(data=df_numeric, x=col, ax=axes[1])
            axes[1].set_title(f'Box Plot of {col}')
            axes[1].set_xlabel(col)
            axes[1].set_ylabel('Value')

            plt.tight_layout()

            # Display the generated plot using st.pyplot()
            st.pyplot(fig)

            # Close the figure to free up memory
            plt.close(fig)
    else:
        st.warning("No numeric columns found in the cleaned data to calculate descriptive statistics or visualize distributions.")

    # Add section for Correlation Analysis
    st.header("Correlation Analysis")

    # Add markdown text for Correlation between datasets
    st.markdown("""
    # Correlation between datasets
    """)

    if not df_numeric.empty:
        # Calculate the correlation matrix
        correlation_matrix = df_numeric.corr()

        # Create a heatmap of the correlation matrix
        fig, ax = plt.subplots(figsize=(12, 10))
        sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=".5", ax=ax)
        ax.set_title('Correlation Matrix of Socio-Economic Variables')

        # Display the generated plot using st.pyplot()
        st.pyplot(fig)
        plt.close(fig)
    else:
        st.warning("No numeric data available to compute correlation matrix.")

    # Add section for Regression Models
    st.header("Multiple Linear Regression Models")

    # Add markdown text for Building Multiple Linear Regression Models
    st.markdown("""
    ## 4. Building Multiple Linear Regression Models
    Using `statsmodels.formula.api.ols`, build the four specified regression models and print their summaries.
    """)

    # Ensure df_regression_renamed DataFrame exists and is not empty
    # This part assumes df_regression_renamed is prepared with log transformations and renamed columns
    # Re-create df_regression_renamed with log transformations for this section
df = load_and_preprocess_data()

# Create a regression-specific copy (already cleaned inside the function)
df_regression = df.copy()

regression_keywords = {
        'Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)': 'Real GDP',
        'Gross Domestic Expenditure on R&D (GERD) (current PPP USD)': 'GERD',
        'Resident Patent Applications': 'Resident Patent Applications',
        'Non-Resident Patent Applications': 'Non-Resident Patent Applications',
        'Number of R&D Researcher (per million people)': 'R&D Researchers per Million People',
        'High-Tech Export Share (as % of Manufacturing exports)': 'High-tech Export Share (% of Manufactured Exports)',
        'Business R&D Personnel (FTE)': 'Business R&D Personnel (FTE)',
        'GDP per Capita': 'GDP per Capita',
        'Total Population': 'Total Population',
        'Labor Force': 'Labor Force Size',
        'Share of Government-Financed BERD (%)': 'Government-financed BERD (%)',
        'Share of Business-Financed BERD (%)': 'Business-financed BERD (%)',
        'Business R&D Personnel (FTE) per 1,000 Employed': 'R&D Personnel per 1,000 Employees'
    }

    regression_cols = {}
    for col in df_regression.columns:
        first_row_value = df.iloc[0][col]
        if isinstance(first_row_value, str):
             for keyword, var_name in regression_keywords.items():
                if keyword in first_row_value:
                    if keyword in ['Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)', 'Gross Domestic Expenditure on R&D (GERD) (current PPP USD)']:
                        if var_name not in regression_cols:
                            regression_cols[var_name] = col
                    elif var_name not in regression_cols:
                         regression_cols[var_name] = col

    selected_regression_cols = ['국가별'] + [col for col in regression_cols.values() if col in df_regression.columns]
    df_regression = df_regression.loc[:, selected_regression_cols].copy()

    col_rename_map_regression = {v: k for k, v in regression_cols.items()}
    df_regression_renamed = df_regression.rename(columns=col_rename_map_regression)

    for col in df_regression_renamed.columns:
        if col != '국가별':
            df_regression_renamed[col] = df_regression_renamed[col].astype(str).str.replace('[^0-9.-]', '', regex=True)
            df_regression_renamed[col] = pd.to_numeric(df_regression_renamed[col], errors='coerce')

    df_regression_renamed.dropna(subset=[col for col in df_regression_renamed.columns if col != '국가별'], inplace=True)

    if 'Real GDP' in df_regression_renamed.columns:
        df_regression_renamed['Log_Real_GDP'] = np.log(df_regression_renamed['Real GDP'] + 1e-9)
    else:
        st.warning("Warning: 'Real GDP' column not found for log transformation.")

    if 'GERD' in df_regression_renamed.columns:
        df_regression_renamed['Log_GERD'] = np.log(df_regression_renamed['GERD'] + 1e-9)
    else:
         st.warning("Warning: 'GERD' column not found for log transformation.")


    if not df_regression_renamed.empty and 'Log_Real_GDP' in df_regression_renamed.columns and 'Log_GERD' in df_regression_renamed.columns:

        # Model 1: log_GDP ~ log_GERD (simple regression)
        st.subheader("Model 1: Simple Regression")
        try:
            model_1_formula = 'Log_Real_GDP ~ Log_GERD'
            model_1 = smf.ols(model_1_formula, data=df_regression_renamed).fit()
            st.text(model_1.summary().as_text())
            st.markdown("Interpretation: Model 1 estimates the simple linear relationship between Log(GERD) and Log(Real GDP). The regression coefficient (β₁) is positive and statistically significant (p < 0.05), indicating that as GERD increases, Real GDP tends to increase correspondingly. The Adjusted R² is approximately 0.494, suggesting that Log(GERD) explains about 49.4% of the variance in Log(Real GDP). Thus, GERD can be considered a major explanatory factor contributing to economic growth.")
        except Exception as e:
            st.error(f"Error building Model 1: {e}")
            model_1 = None
        st.markdown("---")

        # Model 2: log_GDP ~ log_GERD + GDP_per_Capita + Population_Labor_Size (confounders)
        st.subheader("Model 2: Adding Confounders")
        try:
            confounder_vars = ['GDP_per_Capita']
            confounder_vars_formula = ' + '.join([var for var in confounder_vars if var in df_regression_renamed.columns])

            if confounder_vars_formula:
                model_2_formula = f'Log_Real_GDP ~ Log_GERD + {confounder_vars_formula}'
                model_2 = smf.ols(model_2_formula, data=df_regression_renamed).fit()
                st.text(model_2.summary().as_text())
                st.markdown("Interpretation: Model 2 adds GDP per Capita as a confounding variable to the basic model. The variables Total Population and Labor Force Size were unavailable in the dataset and therefore excluded. The analysis shows that GDP per Capita is statistically insignificant (p = 0.491), indicating that it does not have a meaningful impact on Real GDP in this model. Meanwhile, the coefficient for Log(GERD) remains statistically significant (p = 0.003), suggesting that the positive relationship between GERD and Real GDP persists even after controlling for GDP per Capita. The Adjusted R² slightly decreases to 0.476, possibly due to the added confounder not substantially improving explanatory power, or as a result of penalization for increased model complexity.")
            else:
                st.warning("Confounder variables not found in the dataset. Skipping Model 2.")
                model_2 = None
        except Exception as e:
            st.error(f"Error building Model 2: {e}")
            model_2 = None
        st.markdown("---")

        # Model 3: log_GDP ~ log_GERD + Patents + R&D_Researchers + Hightech_Exports + Business_R&D_Personnel (mediators)
        st.subheader("Model 3: Adding Mediators")
        try:
            mediator_vars = [
                'Resident_Patent_Applications',
                'Non_Resident_Patent_Applications',
                'Business_R_and_D_Personnel_FTE'
            ]
            mediator_vars_formula = ' + '.join([var for var in mediator_vars if var in df_regression_renamed.columns])

            all_vars_formula_model3 = 'Log_GERD'
            if confounder_vars_formula:
                 all_vars_formula_model3 += ' + ' + confounder_vars_formula
            if mediator_vars_formula:
                 all_vars_formula_model3 += ' + ' + mediator_vars_formula


            if 'Log_GERD' in df_regression_renamed.columns and (confounder_vars_formula or mediator_vars_formula):
                model_3_formula = f'Log_Real_GDP ~ {all_vars_formula_model3}'
                model_3 = smf.ols(model_3_formula, data=df_regression_renamed).fit()
                st.text(model_3.summary().as_text())
                st.markdown("Interpretation: Model 3 includes mediating variables — Resident / Non-resident Patent Applications, R&D Researchers per Million People, High-tech Export Share (% of Manufactured Exports), and Business R&D Personnel (FTE) — in addition to Log(GERD) and GDP per Capita. The coefficient for Log(GERD) slightly decreases (β ≈ 0.380) but remains statistically significant (p = 0.020). This suggests that part of the relationship between GERD and Real GDP may be mediated by innovation, human capital, or technological diffusion. Among the mediators, Resident Patent Applications shows a near-significant result (p = 0.053), implying that domestic patent activity might partially explain how GERD affects Real GDP. Other mediators are not statistically significant. The Adjusted R² increases substantially to approximately 0.700, indicating that including mediating variables substantially improves the model’s explanatory power.")
            else:
                 st.warning("Mediator variables not found in the dataset or necessary confounders missing. Skipping Model 3.")
                 model_3 = None
        except Exception as e:
            st.error(f"Error building Model 3: {e}")
            model_3 = None
        st.markdown("---")


        # Model 4: log_GDP ~ log_GERD * GovFinanced_BERD + GDP_per_Capita + Population_Labor_Size (moderator interaction)
        st.subheader("Model 4: Adding Moderator Interaction")
        try:
            moderator_var = 'GovFinanced_BERD_pct'

            if moderator_var in df_regression_renamed.columns and confounder_vars_formula:
                 model_4_formula = f'Log_Real_GDP ~ Log_GERD * {moderator_var} + {confounder_vars_formula}'
                 model_4 = smf.ols(model_4_formula, data=df_regression_renamed).fit()
                 st.text(model_4.summary().as_text())
                 st.markdown("Interpretation: Model 4 adds an interaction term between Log(GERD) and Government-financed BERD (%) to test for a moderating effect. The interaction term (Log_GERD × GovFinanced_BERD_pct) is highly significant (p = 0.001), suggesting that the effect of GERD on Real GDP varies depending on the proportion of government-financed R&D expenditure. The coefficient for the interaction term (β = -0.0895) is negative, implying that as the share of government financing in R&D increases, the positive impact of GERD on Real GDP tends to weaken. The coefficient for Log(GERD) itself increases (β ≈ 1.070) compared to Model 3 and remains highly significant (p < 0.001). This represents the effect of GERD on Real GDP when the moderator (Government-financed BERD) equals zero. Given the significant interaction, the effect size of GERD should be interpreted conditionally on the level of government financing. The Adjusted R² further increases to approximately 0.775, showing that Model 4 provides the best overall explanatory power.")
            else:
                st.warning("Moderator variable or confounders not found. Skipping Model 4.")
                model_4 = None
        except Exception as e:
            st.error(f"Error building Model 4: {e}")
            model_4 = None
        st.markdown("---")

        # Generate Actual vs. Predicted Plot for Model 4
        st.header("Actual vs. Predicted Values Plot for Model 4")
        st.markdown("Generate a scatter plot of the actual values of the dependent variable (Log_Real_GDP) against the values predicted by Model 4, with a line of perfect fit.")

        if 'model_4' in locals() and model_4 is not None:
             try:
                actual_gdp = df_regression_renamed['Log_Real_GDP']
                predicted_gdp = model_4.predict(df_regression_renamed)

                fig, ax = plt.subplots(figsize=(8, 6))
                sns.scatterplot(x=predicted_gdp, y=actual_gdp, alpha=0.6, ax=ax)
                ax.plot([actual_gdp.min(), actual_gdp.max()], [actual_gdp.min(), actual_gdp.max()], color='red', linestyle='--', lw=2, label='Perfect Fit')
                ax.set_title('Actual vs. Predicted Log(Real GDP) (Model 4)')
                ax.set_xlabel('Predicted Log(Real GDP)')
                ax.set_ylabel('Actual Log(Real GDP)')
                ax.legend()
                ax.grid(True)
                st.pyplot(fig)
                plt.close(fig)
             except Exception as e:
                 st.error(f"Error generating Actual vs. Predicted plot for Model 4: {e}")
        else:
             st.warning("Model 4 was not successfully built. Cannot generate actual vs. predicted values plot.")

        # Create Comparison Table
        st.header("Regression Model Comparison")
        st.markdown("Generate a table comparing the Adjusted R² and the coefficient (β) of log(GERD) across all four models.")

        results_dict = {}
        if 'model_1' in locals() and model_1:
            results_dict['Model 1'] = {
                'Adjusted R-squared': model_1.rsquared_adj,
                'Beta (Log_GERD)': model_1.params.get('Log_GERD', 'N/A')
            }
        if 'model_2' in locals() and model_2:
            results_dict['Model 2'] = {
                'Adjusted R-squared': model_2.rsquared_adj,
                'Beta (Log_GERD)': model_2.params.get('Log_GERD', 'N/A')
            }
        if 'model_3' in locals() and model_3:
            results_dict['Model 3'] = {
                'Adjusted R-squared': model_3.rsquared_adj,
                'Beta (Log_GERD)': model_3.params.get('Log_GERD', 'N/A')
            }
        if 'model_4' in locals() and model_4:
             results_dict['Model 4'] = {
                'Adjusted R-squared': model_4.rsquared_adj,
                'Beta (Log_GERD)': model_4.params.get('Log_GERD', 'N/A')
            }

        if results_dict:
            comparison_table = pd.DataFrame.from_dict(results_dict, orient='index')
            st.dataframe(comparison_table)
        else:
            st.warning("No models were successfully built to create a comparison table.")

        # Generate Visualizations
        st.header("Regression Analysis Visualizations")
        st.markdown("""
        Generate clear visualizations using Matplotlib/Seaborn:
        - Scatter plot of log(GERD) vs. log(GDP) with regression line.
        - Histogram of residuals for the final model (Model 4).
        - Bar chart comparing Adjusted R² across models.
        """)

        # Scatter plot of log(GERD) vs. log(GDP) with regression line (already generated above, but can be repeated here for clarity)
        st.subheader("Scatter Plot of Log(GERD) vs Log(Real GDP)")
        fig, ax = plt.subplots(figsize=(10, 6))
        sns.regplot(data=df_regression_renamed, x='Log_GERD', y='Log_Real_GDP', scatter_kws={'alpha': 0.6}, ax=ax)
        ax.set_title('Scatter Plot of Log(GERD) vs Log(Real GDP)')
        ax.set_xlabel('Log of Gross Domestic Expenditure on R&D (GERD)')
        ax.set_ylabel('Log of Real GDP')
        ax.grid(True)
        st.pyplot(fig)
        plt.close(fig)

        # Histogram of residuals for the final model (Model 4)
        st.subheader("Histogram of Residuals for Model 4")
        if 'model_4' in locals() and model_4:
            try:
                residuals = model_4.resid
                fig, ax = plt.subplots(figsize=(8, 6))
                sns.histplot(residuals, kde=True, ax=ax)
                ax.set_title('Histogram of Residuals for Model 4')
                ax.set_xlabel('Residuals')
                ax.set_ylabel('Frequency')
                st.pyplot(fig)
                plt.close(fig)
            except Exception as e:
                st.error(f"Error generating residuals histogram for Model 4: {e}")
        else:
            st.warning("Model 4 was not successfully built. Skipping residuals histogram.")

        # Bar chart comparing Adjusted R² across models
        st.subheader("Comparison of Adjusted R-squared Across Regression Models")
        if results_dict:
            models = list(results_dict.keys())
            adjusted_r_squared_values = [results_dict[model]['Adjusted R-squared'] for model in models]

            fig, ax = plt.subplots(figsize=(10, 6))
            sns.barplot(x=models, y=adjusted_r_squared_values, palette='viridis', ax=ax)
            ax.set_title('Comparison of Adjusted R-squared Across Regression Models')
            ax.set_xlabel('Regression Model')
            ax.set_ylabel('Adjusted R-squared')
            ax.set_ylim(0, max(adjusted_r_squared_values) * 1.1)
            st.pyplot(fig)
            plt.close(fig)
        else:
            st.warning("No model results available to create Adjusted R-squared bar chart.")

        # Summarize Findings
        st.header("Summary of Findings")
        st.markdown("""
        This analysis was conducted to examine the causal impact of Gross Domestic Expenditure on R&D (GERD) on Real GDP.
        Four regression models were sequentially estimated, gradually adding confounding, mediating, and moderating variables to identify the underlying causal structure.
        The changes in regression coefficients, statistical significance, and explanatory power (Adjusted R²) were analyzed to interpret the causal relationships.

        # Model 1: Simple Linear Regression (Log_Real_GDP ~ Log_GERD)

        Model 1 estimates the simple linear relationship between Log(GERD) and Log(Real GDP).
        The regression coefficient (β₁) is positive and statistically significant (p < 0.05), indicating that as GERD increases, Real GDP tends to increase correspondingly.
        The Adjusted R² is approximately 0.494, suggesting that Log(GERD) explains about 49.4% of the variance in Log(Real GDP).
        Thus, GERD can be considered a major explanatory factor contributing to economic growth.

        # Model 2: Adding a Confounding Variable (Log_Real_GDP ~ Log_GERD + GDP_per_Capita)

        Model 2 adds GDP per Capita as a confounding variable to the basic model.
        The variables Total Population and Labor Force Size were unavailable in the dataset and therefore excluded.

        The analysis shows that GDP per Capita is statistically insignificant (p = 0.491),
        indicating that it does not have a meaningful impact on Real GDP in this model.
        Meanwhile, the coefficient for Log(GERD) remains statistically significant (p = 0.003),
        suggesting that the positive relationship between GERD and Real GDP persists even after controlling for GDP per Capita.

        The Adjusted R² slightly decreases to 0.476, possibly due to the added confounder not substantially improving explanatory power, or as a result of penalization for increased model complexity.

        # Model 3: Adding Mediating Variables (Log_Real_GDP ~ Log_GERD + GDP per Capita + Innovation Variables)

        Model 3 includes mediating variables — Resident / Non-resident Patent Applications, R&D Researchers per Million People,
        High-tech Export Share (% of Manufactured Exports), and Business R&D Personnel (FTE) — in addition to Log(GERD) and GDP per Capita.

        The coefficient for Log(GERD) slightly decreases (β ≈ 0.380) but remains statistically significant (p = 0.020).
        This suggests that part of the relationship between GERD and Real GDP may be mediated by innovation, human capital, or technological diffusion.

        Among the mediators, Resident Patent Applications shows a near-significant result (p = 0.053), implying that domestic patent activity might partially explain how GERD affects Real GDP.
        Other mediators are not statistically significant.
        The Adjusted R² increases substantially to approximately 0.700, indicating that including mediating variables substantially improves the model’s explanatory power.

        # Model 4: Adding a Moderating Effect (Log_Real_GDP ~ Log_GERD * GovFinanced_BERD_pct + Mediators + Confounder)

        Model 4 adds an interaction term between Log(GERD) and Government-financed BERD (%) to test for a moderating effect.

        The interaction term (Log_GERD × GovFinanced_BERD_pct) is highly significant (p = 0.001),
        suggesting that the effect of GERD on Real GDP varies depending on the proportion of government-financed R&D expenditure.
        The coefficient for the interaction term (β = -0.0895) is negative, implying that as the share of government financing in R&D increases,
        the positive impact of GERD on Real GDP tends to weaken.

        The coefficient for Log(GERD) itself increases (β ≈ 1.070) compared to Model 3 and remains highly significant (p < 0.001).
        This represents the effect of GERD on Real GDP when the moderator (Government-financed BERD) equals zero.
        Given the significant interaction, the effect size of GERD should be interpreted conditionally on the level of government financing.
        The Adjusted R² further increases to approximately 0.775, showing that Model 4 provides the best overall explanatory power.

        # Key Findings and Implications

        1. Relationship between GERD and Real GDP
        Across all models, Log(GERD) consistently shows a statistically significant and positive relationship with Real GDP.
        This provides empirical support for the notion that R&D investment is a key driver of economic growth.
        2. Mediating Effects
        Resident Patent Applications partially mediate the relationship between GERD and Real GDP,
        suggesting that R&D expenditure contributes to economic growth indirectly through innovation activities.
        Other mediators were not statistically significant, indicating that the mediating strength may be limited.
        3. Moderating Effects
        Government-financed BERD (%) moderates the relationship between GERD and Real GDP.
        The positive effect of GERD on GDP tends to weaken as the proportion of government-financed R&D increases.
        This finding implies that the efficiency of R&D investment may vary depending on the balance between public and private funding structures.
        4. Model Fit Comparison
        The Adjusted R² values steadily improve as the models expand (0.494 → 0.476 → 0.700 → 0.775).
        This indicates that incorporating mediating and moderating variables yields a more comprehensive and accurate explanation of Real GDP fluctuations compared to a simple model.

        # Conclusion

        The multiple regression analysis demonstrates that GERD exerts a consistently positive impact on Real GDP.
        However, this effect operates through both indirect innovation pathways (e.g., patent applications)
        and conditional moderation effects depending on the level of government-financed R&D.

        The results reveal that the relationship is not a simple “R&D → Growth” linear link,
        but rather a multi-stage causal chain — “R&D → Innovation → Productivity → Growth” —
        that is further conditioned by policy environments such as government funding ratios.

        Therefore, future R&D policies should focus not merely on expanding total expenditure,
        but also on optimizing the qualitative composition of investment —
        balancing government and private funding, strengthening human capital, and promoting innovation output efficiency.
        """)

else:
    st.warning("Data could not be loaded or is empty after cleaning.")

import streamlit as st
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import statsmodels.formula.api as smf
import pandas as pd
import io

# Set the page configuration
st.set_page_config(page_title="Real GDP and R&D Research Analysis", layout="wide")

# Add a main title to the app
st.title("Analysis of Real GDP and R&D Research")

# Add a sidebar with a brief description
st.sidebar.header("About")
st.sidebar.write(
    "This application analyzes the relationship between Real GDP and R&D research, "
    "including simple linear regression, correlation analysis, and multiple linear regression models."
)


@st.cache_data
def load_and_preprocess_data():
    """
    Loads the dataset from the current directory and preprocesses it for analysis.

    Returns:
        pd.DataFrame: The preprocessed DataFrame.
    """
    try:
        #  Directly load the CSV file in the same folder as your Streamlit app
        df = pd.read_csv("ACDT final data set22.xlsx - 데이터 (1).csv", encoding="utf-8")

        st.success("Dataset successfully loaded!")
        return df

    except FileNotFoundError:
        st.error("Error: The data file was not found. Please ensure it is uploaded to your repository root.")
        return pd.DataFrame()

    except Exception as e:
        st.error(f"An unexpected error occurred while loading data: {e}")
        return pd.DataFrame()

        # Clean all columns except the first one ('국가별') and exclude the first two rows
        for col in df.columns[1:]:
            # Select data from the third row onwards and convert to string type
            # Use .loc for clearer indexing and to avoid SettingWithCopyWarning
            df.loc[2:, col] = df.loc[2:, col].astype(str).str.replace('[^0-9.-]', '', regex=True)
            df.loc[2:, col] = pd.to_numeric(df.loc[2:, col], errors='coerce')

        # Identify the columns for the specified variables
        variable_cols = {}

        # Define a dictionary of keywords to look for, mapping them to the desired variable names
        keywords = {
            'Resident Patent Applications': 'Resident Patent Applications',
            'Non-Resident Patent Applications': 'Non-Resident Patent Applications',
            'Number of R&D Researcher': 'Number of R&D Researcher (per million people)',
            'High-Tech Export Share': 'High-Tech Export Share (% of Manufacturing exports)',
            'Business R&D Personnel (FTE)': 'Business R&D Personnel (FTE)',
            'Real GDP': 'Real GDP',
            'Total Population': 'Total Population',
            'Labor Force': 'Labor Force Size',
            'Government-Financed BERD (%)': 'Share of Government-Financed BERD (%)',
            'Business-Financed BERD (%)': 'Share of Business-Financed BERD (%)',
            'Business R&D Personnel (FTE) per 1,000 Employed': 'Business R&D Personnel (FTE) per 1,000 Employed'
        }

        # Iterate through columns to find matches based on keywords in the first row content
        for col in df.columns:
            first_row_value = df.iloc[0][col]
            if isinstance(first_row_value, str):
                # Check for each keyword in the first row value
                for keyword, var_name in keywords.items():
                    if keyword in first_row_value:
                        # For 'Real GDP', prioritize later years
                        if var_name == 'Real GDP':
                            year = str(col).split('.')[0] if '.' in str(col) else str(col)
                            try:
                                year_int = int(year)
                                # Keep the latest identified GDP year if multiple are found
                                if var_name not in variable_cols or (isinstance(variable_cols[var_name], str) and int(variable_cols[var_name].split('.')[0] if '.' in variable_cols[var_name] else variable_cols[var_name]) < year_int):
                                    variable_cols[var_name] = col
                            except ValueError:
                                # Handle cases where the column name before the dot is not a year
                                pass
                        # For other variables, assign the first column found containing the keyword
                        elif var_name not in variable_cols:
                            variable_cols[var_name] = col


        # Create a new DataFrame with the '국가별' column and the identified variable columns
        # Ensure all identified columns are actually present in the original dataframe before selection
        selected_cols = ['국가별'] + [col for col in variable_cols.values() if col in df.columns]
        df_cleaned = df.loc[:, selected_cols].copy()

        # Remove the first two rows which contain header information
        df_cleaned = df_cleaned.iloc[2:].copy()

        # Rename columns to be more descriptive using the keys from variable_cols
        # Create a mapping from the original column names to the desired variable names
        col_rename_map = {v: k for k, v in variable_cols.items() if v in df_cleaned.columns}
        df_cleaned.rename(columns=col_rename_map, inplace=True)

        # Iterate through the variable columns (excluding '국가별') and clean the data
        for col in df_cleaned.columns:
            if col != '국가별':
                # Convert the data to string type to handle potential mixed data types
                df_cleaned[col] = df_cleaned[col].astype(str)

                # Remove non-numeric characters (keep digits, periods, and hyphens)
                df_cleaned[col] = df_cleaned[col].str.replace('[^0-9.-]', '', regex=True)

                # Convert to numeric, coercing errors to NaN
                df_cleaned[col] = pd.to_numeric(df_cleaned[col], errors='coerce')

        # Handle missing values by dropping rows with NaNs in the variable columns
        variable_column_names = [col for col in df_cleaned.columns if col != '국가별']
        df_cleaned.dropna(subset=variable_column_names, inplace=True)

        return df_cleaned

    except FileNotFoundError:
        st.error(f"Error: Data file not found")
        return pd.DataFrame() # Return an empty DataFrame on error
    except Exception as e:
        st.error(f"An error occurred during data loading and preprocessing: {e}")
        return pd.DataFrame() # Return an empty DataFrame on error



# Display the cleaned data and its info in the Streamlit app
if not df_cleaned.empty:
    st.header("Cleaned Data Preview")
    st.dataframe(df_cleaned.head())

    st.header("Data Information")
    # Redirect df.info() output to a string to display in Streamlit
    buffer = io.StringIO()
    df_cleaned.info(buf=buffer)
    s = buffer.getvalue()
    st.text(s)

    # Add section for Descriptive Statistics and Visualizations
    st.header("Descriptive Statistics and Variable Distributions")

    # Add markdown text for Descriptive Statistics
    st.markdown("""
    ## Descriptive statistics

    mean, median, standard deviation, etc. for each of the cleaned variables.
    """)

    # Select only numeric columns from the cleaned DataFrame
    df_numeric = df_cleaned.select_dtypes(include=np.number)

    if not df_numeric.empty:
        # Calculate descriptive statistics for the numeric columns
        descriptive_stats = df_numeric.describe()

        # Display the descriptive statistics using st.dataframe()
        st.dataframe(descriptive_stats)

        # Add markdown text for Distribution of Confounder, Moderater and Mediater
        st.markdown("""
        # Distribution of Confounder, Moderater and Mediater
        """)

        # Iterate through the numeric columns and create visualizations
        for col in df_numeric.columns:
            # Add a title for the current variable's visualization
            st.subheader(f"Distribution of {col}")

            # Create a figure with two subplots (histogram and box plot)
            fig, axes = plt.subplots(1, 2, figsize=(15, 5))

            # Plot Histogram
            sns.histplot(data=df_numeric, x=col, kde=True, ax=axes[0])
            axes[0].set_title(f'Distribution of {col}')
            axes[0].set_xlabel(col)
            axes[0].set_ylabel('Frequency')

            # Plot Box Plot
            sns.boxplot(data=df_numeric, x=col, ax=axes[1])
            axes[1].set_title(f'Box Plot of {col}')
            axes[1].set_xlabel(col)
            axes[1].set_ylabel('Value')

            plt.tight_layout()

            # Display the generated plot using st.pyplot()
            st.pyplot(fig)

            # Close the figure to free up memory
            plt.close(fig)
    else:
        st.warning("No numeric columns found in the cleaned data to calculate descriptive statistics or visualize distributions.")

    # Add section for Correlation Analysis
    st.header("Correlation Analysis")

    # Add markdown text for Correlation between datasets
    st.markdown("""
    # Correlation between datasets
    """)

    if not df_numeric.empty:
        # Calculate the correlation matrix
        correlation_matrix = df_numeric.corr()

        # Create a heatmap of the correlation matrix
        fig, ax = plt.subplots(figsize=(12, 10))
        sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=".5", ax=ax)
        ax.set_title('Correlation Matrix of Socio-Economic Variables')

        # Display the generated plot using st.pyplot()
        st.pyplot(fig)
        plt.close(fig)
    else:
        st.warning("No numeric data available to compute correlation matrix.")

    # Add section for Regression Models
    st.header("Multiple Linear Regression Models")

    # Add markdown text for Building Multiple Linear Regression Models
    st.markdown("""
    ## 4. Building Multiple Linear Regression Models
    Using `statsmodels.formula.api.ols`, build the four specified regression models and print their summaries.
    """)

    # Ensure df_regression_renamed DataFrame exists and is not empty
    # This part assumes df_regression_renamed is prepared with log transformations and renamed columns
    # Re-create df_regression_renamed with log transformations for this section
    df = pd.read_csv("ACDT final data set22.xlsx - 데이터 (1).csv", encoding="utf-8") # Reload df to ensure it's available

    df_regression = df.copy()
    df_regression = df_regression.iloc[2:].copy()

    regression_keywords = {
        'Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)': 'Real GDP',
        'Gross Domestic Expenditure on R&D (GERD) (current PPP USD)': 'GERD',
        'Resident Patent Applications': 'Resident Patent Applications',
        'Non-Resident Patent Applications': 'Non-Resident Patent Applications',
        'Number of R&D Researcher (per million people)': 'R&D Researchers per Million People',
        'High-Tech Export Share (as % of Manufacturing exports)': 'High-tech Export Share (% of Manufactured Exports)',
        'Business R&D Personnel (FTE)': 'Business R&D Personnel (FTE)',
        'GDP per Capita': 'GDP per Capita',
        'Total Population': 'Total Population',
        'Labor Force': 'Labor Force Size',
        'Share of Government-Financed BERD (%)': 'Government-financed BERD (%)',
        'Share of Business-Financed BERD (%)': 'Business-financed BERD (%)',
        'Business R&D Personnel (FTE) per 1,000 Employed': 'R&D Personnel per 1,000 Employees'
    }

    regression_cols = {}
    for col in df_regression.columns:
        first_row_value = df.iloc[0][col]
        if isinstance(first_row_value, str):
             for keyword, var_name in regression_keywords.items():
                if keyword in first_row_value:
                    if keyword in ['Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)', 'Gross Domestic Expenditure on R&D (GERD) (current PPP USD)']:
                        if var_name not in regression_cols:
                            regression_cols[var_name] = col
                    elif var_name not in regression_cols:
                         regression_cols[var_name] = col

    selected_regression_cols = ['국가별'] + [col for col in regression_cols.values() if col in df_regression.columns]
    df_regression = df_regression.loc[:, selected_regression_cols].copy()

    col_rename_map_regression = {v: k for k, v in regression_cols.items()}
    df_regression_renamed = df_regression.rename(columns=col_rename_map_regression)

    for col in df_regression_renamed.columns:
        if col != '국가별':
            df_regression_renamed[col] = df_regression_renamed[col].astype(str).str.replace('[^0-9.-]', '', regex=True)
            df_regression_renamed[col] = pd.to_numeric(df_regression_renamed[col], errors='coerce')

    df_regression_renamed.dropna(subset=[col for col in df_regression_renamed.columns if col != '국가별'], inplace=True)

    if 'Real GDP' in df_regression_renamed.columns:
        df_regression_renamed['Log_Real_GDP'] = np.log(df_regression_renamed['Real GDP'] + 1e-9)
    else:
        st.warning("Warning: 'Real GDP' column not found for log transformation.")

    if 'GERD' in df_regression_renamed.columns:
        df_regression_renamed['Log_GERD'] = np.log(df_regression_renamed['GERD'] + 1e-9)
    else:
         st.warning("Warning: 'GERD' column not found for log transformation.")


    if not df_regression_renamed.empty and 'Log_Real_GDP' in df_regression_renamed.columns and 'Log_GERD' in df_regression_renamed.columns:

        # Model 1: log_GDP ~ log_GERD (simple regression)
        st.subheader("Model 1: Simple Regression")
        try:
            model_1_formula = 'Log_Real_GDP ~ Log_GERD'
            model_1 = smf.ols(model_1_formula, data=df_regression_renamed).fit()
            st.text(model_1.summary().as_text())
            st.markdown("Interpretation: Model 1 estimates the simple linear relationship between Log(GERD) and Log(Real GDP). The regression coefficient (β₁) is positive and statistically significant (p < 0.05), indicating that as GERD increases, Real GDP tends to increase correspondingly. The Adjusted R² is approximately 0.494, suggesting that Log(GERD) explains about 49.4% of the variance in Log(Real GDP). Thus, GERD can be considered a major explanatory factor contributing to economic growth.")
        except Exception as e:
            st.error(f"Error building Model 1: {e}")
            model_1 = None
        st.markdown("---")

        # Model 2: log_GDP ~ log_GERD + GDP_per_Capita + Population_Labor_Size (confounders)
        st.subheader("Model 2: Adding Confounders")
        try:
            confounder_vars = ['GDP_per_Capita']
            confounder_vars_formula = ' + '.join([var for var in confounder_vars if var in df_regression_renamed.columns])

            if confounder_vars_formula:
                model_2_formula = f'Log_Real_GDP ~ Log_GERD + {confounder_vars_formula}'
                model_2 = smf.ols(model_2_formula, data=df_regression_renamed).fit()
                st.text(model_2.summary().as_text())
                st.markdown("Interpretation: Model 2 adds GDP per Capita as a confounding variable to the basic model. The variables Total Population and Labor Force Size were unavailable in the dataset and therefore excluded. The analysis shows that GDP per Capita is statistically insignificant (p = 0.491), indicating that it does not have a meaningful impact on Real GDP in this model. Meanwhile, the coefficient for Log(GERD) remains statistically significant (p = 0.003), suggesting that the positive relationship between GERD and Real GDP persists even after controlling for GDP per Capita. The Adjusted R² slightly decreases to 0.476, possibly due to the added confounder not substantially improving explanatory power, or as a result of penalization for increased model complexity.")
            else:
                st.warning("Confounder variables not found in the dataset. Skipping Model 2.")
                model_2 = None
        except Exception as e:
            st.error(f"Error building Model 2: {e}")
            model_2 = None
        st.markdown("---")

        # Model 3: log_GDP ~ log_GERD + Patents + R&D_Researchers + Hightech_Exports + Business_R&D_Personnel (mediators)
        st.subheader("Model 3: Adding Mediators")
        try:
            mediator_vars = [
                'Resident_Patent_Applications',
                'Non_Resident_Patent_Applications',
                'Business_R_and_D_Personnel_FTE'
            ]
            mediator_vars_formula = ' + '.join([var for var in mediator_vars if var in df_regression_renamed.columns])

            all_vars_formula_model3 = 'Log_GERD'
            if confounder_vars_formula:
                 all_vars_formula_model3 += ' + ' + confounder_vars_formula
            if mediator_vars_formula:
                 all_vars_formula_model3 += ' + ' + mediator_vars_formula


            if 'Log_GERD' in df_regression_renamed.columns and (confounder_vars_formula or mediator_vars_formula):
                model_3_formula = f'Log_Real_GDP ~ {all_vars_formula_model3}'
                model_3 = smf.ols(model_3_formula, data=df_regression_renamed).fit()
                st.text(model_3.summary().as_text())
                st.markdown("Interpretation: Model 3 includes mediating variables — Resident / Non-resident Patent Applications, R&D Researchers per Million People, High-tech Export Share (% of Manufactured Exports), and Business R&D Personnel (FTE) — in addition to Log(GERD) and GDP per Capita. The coefficient for Log(GERD) slightly decreases (β ≈ 0.380) but remains statistically significant (p = 0.020). This suggests that part of the relationship between GERD and Real GDP may be mediated by innovation, human capital, or technological diffusion. Among the mediators, Resident Patent Applications shows a near-significant result (p = 0.053), implying that domestic patent activity might partially explain how GERD affects Real GDP. Other mediators are not statistically significant. The Adjusted R² increases substantially to approximately 0.700, indicating that including mediating variables substantially improves the model’s explanatory power.")
            else:
                 st.warning("Mediator variables not found in the dataset or necessary confounders missing. Skipping Model 3.")
                 model_3 = None
        except Exception as e:
            st.error(f"Error building Model 3: {e}")
            model_3 = None
        st.markdown("---")


        # Model 4: log_GDP ~ log_GERD * GovFinanced_BERD + GDP_per_Capita + Population_Labor_Size (moderator interaction)
        st.subheader("Model 4: Adding Moderator Interaction")
        try:
            moderator_var = 'GovFinanced_BERD_pct'

            if moderator_var in df_regression_renamed.columns and confounder_vars_formula:
                 model_4_formula = f'Log_Real_GDP ~ Log_GERD * {moderator_var} + {confounder_vars_formula}'
                 model_4 = smf.ols(model_4_formula, data=df_regression_renamed).fit()
                 st.text(model_4.summary().as_text())
                 st.markdown("Interpretation: Model 4 adds an interaction term between Log(GERD) and Government-financed BERD (%) to test for a moderating effect. The interaction term (Log_GERD × GovFinanced_BERD_pct) is highly significant (p = 0.001), suggesting that the effect of GERD on Real GDP varies depending on the proportion of government-financed R&D expenditure. The coefficient for the interaction term (β = -0.0895) is negative, implying that as the share of government financing in R&D increases, the positive impact of GERD on Real GDP tends to weaken. The coefficient for Log(GERD) itself increases (β ≈ 1.070) compared to Model 3 and remains highly significant (p < 0.001). This represents the effect of GERD on Real GDP when the moderator (Government-financed BERD) equals zero. Given the significant interaction, the effect size of GERD should be interpreted conditionally on the level of government financing. The Adjusted R² further increases to approximately 0.775, showing that Model 4 provides the best overall explanatory power.")
            else:
                st.warning("Moderator variable or confounders not found. Skipping Model 4.")
                model_4 = None
        except Exception as e:
            st.error(f"Error building Model 4: {e}")
            model_4 = None
        st.markdown("---")

        # Generate Actual vs. Predicted Plot for Model 4
        st.header("Actual vs. Predicted Values Plot for Model 4")
        st.markdown("Generate a scatter plot of the actual values of the dependent variable (Log_Real_GDP) against the values predicted by Model 4, with a line of perfect fit.")

        if 'model_4' in locals() and model_4 is not None:
             try:
                actual_gdp = df_regression_renamed['Log_Real_GDP']
                predicted_gdp = model_4.predict(df_regression_renamed)

                fig, ax = plt.subplots(figsize=(8, 6))
                sns.scatterplot(x=predicted_gdp, y=actual_gdp, alpha=0.6, ax=ax)
                ax.plot([actual_gdp.min(), actual_gdp.max()], [actual_gdp.min(), actual_gdp.max()], color='red', linestyle='--', lw=2, label='Perfect Fit')
                ax.set_title('Actual vs. Predicted Log(Real GDP) (Model 4)')
                ax.set_xlabel('Predicted Log(Real GDP)')
                ax.set_ylabel('Actual Log(Real GDP)')
                ax.legend()
                ax.grid(True)
                st.pyplot(fig)
                plt.close(fig)
             except Exception as e:
                 st.error(f"Error generating Actual vs. Predicted plot for Model 4: {e}")
        else:
             st.warning("Model 4 was not successfully built. Cannot generate actual vs. predicted values plot.")

        # Create Comparison Table
        st.header("Regression Model Comparison")
        st.markdown("Generate a table comparing the Adjusted R² and the coefficient (β) of log(GERD) across all four models.")

        results_dict = {}
        if 'model_1' in locals() and model_1:
            results_dict['Model 1'] = {
                'Adjusted R-squared': model_1.rsquared_adj,
                'Beta (Log_GERD)': model_1.params.get('Log_GERD', 'N/A')
            }
        if 'model_2' in locals() and model_2:
            results_dict['Model 2'] = {
                'Adjusted R-squared': model_2.rsquared_adj,
                'Beta (Log_GERD)': model_2.params.get('Log_GERD', 'N/A')
            }
        if 'model_3' in locals() and model_3:
            results_dict['Model 3'] = {
                'Adjusted R-squared': model_3.rsquared_adj,
                'Beta (Log_GERD)': model_3.params.get('Log_GERD', 'N/A')
            }
        if 'model_4' in locals() and model_4:
             results_dict['Model 4'] = {
                'Adjusted R-squared': model_4.rsquared_adj,
                'Beta (Log_GERD)': model_4.params.get('Log_GERD', 'N/A')
            }

        if results_dict:
            comparison_table = pd.DataFrame.from_dict(results_dict, orient='index')
            st.dataframe(comparison_table)
        else:
            st.warning("No models were successfully built to create a comparison table.")

        # Generate Visualizations
        st.header("Regression Analysis Visualizations")
        st.markdown("""
        Generate clear visualizations using Matplotlib/Seaborn:
        - Scatter plot of log(GERD) vs. log(GDP) with regression line.
        - Histogram of residuals for the final model (Model 4).
        - Bar chart comparing Adjusted R² across models.
        """)

        # Scatter plot of log(GERD) vs. log(GDP) with regression line (already generated above, but can be repeated here for clarity)
        st.subheader("Scatter Plot of Log(GERD) vs Log(Real GDP)")
        fig, ax = plt.subplots(figsize=(10, 6))
        sns.regplot(data=df_regression_renamed, x='Log_GERD', y='Log_Real_GDP', scatter_kws={'alpha': 0.6}, ax=ax)
        ax.set_title('Scatter Plot of Log(GERD) vs Log(Real GDP)')
        ax.set_xlabel('Log of Gross Domestic Expenditure on R&D (GERD)')
        ax.set_ylabel('Log of Real GDP')
        ax.grid(True)
        st.pyplot(fig)
        plt.close(fig)

        # Histogram of residuals for the final model (Model 4)
        st.subheader("Histogram of Residuals for Model 4")
        if 'model_4' in locals() and model_4:
            try:
                residuals = model_4.resid
                fig, ax = plt.subplots(figsize=(8, 6))
                sns.histplot(residuals, kde=True, ax=ax)
                ax.set_title('Histogram of Residuals for Model 4')
                ax.set_xlabel('Residuals')
                ax.set_ylabel('Frequency')
                st.pyplot(fig)
                plt.close(fig)
            except Exception as e:
                st.error(f"Error generating residuals histogram for Model 4: {e}")
        else:
            st.warning("Model 4 was not successfully built. Skipping residuals histogram.")

        # Bar chart comparing Adjusted R² across models
        st.subheader("Comparison of Adjusted R-squared Across Regression Models")
        if results_dict:
            models = list(results_dict.keys())
            adjusted_r_squared_values = [results_dict[model]['Adjusted R-squared'] for model in models]

            fig, ax = plt.subplots(figsize=(10, 6))
            sns.barplot(x=models, y=adjusted_r_squared_values, palette='viridis', ax=ax)
            ax.set_title('Comparison of Adjusted R-squared Across Regression Models')
            ax.set_xlabel('Regression Model')
            ax.set_ylabel('Adjusted R-squared')
            ax.set_ylim(0, max(adjusted_r_squared_values) * 1.1)
            st.pyplot(fig)
            plt.close(fig)
        else:
            st.warning("No model results available to create Adjusted R-squared bar chart.")

        # Summarize Findings
        st.header("Summary of Findings")
        st.markdown("""
        This analysis was conducted to examine the causal impact of Gross Domestic Expenditure on R&D (GERD) on Real GDP.
        Four regression models were sequentially estimated, gradually adding confounding, mediating, and moderating variables to identify the underlying causal structure.
        The changes in regression coefficients, statistical significance, and explanatory power (Adjusted R²) were analyzed to interpret the causal relationships.

        # Model 1: Simple Linear Regression (Log_Real_GDP ~ Log_GERD)

        Model 1 estimates the simple linear relationship between Log(GERD) and Log(Real GDP).
        The regression coefficient (β₁) is positive and statistically significant (p < 0.05), indicating that as GERD increases, Real GDP tends to increase correspondingly.
        The Adjusted R² is approximately 0.494, suggesting that Log(GERD) explains about 49.4% of the variance in Log(Real GDP).
        Thus, GERD can be considered a major explanatory factor contributing to economic growth.

        # Model 2: Adding a Confounding Variable (Log_Real_GDP ~ Log_GERD + GDP_per_Capita)

        Model 2 adds GDP per Capita as a confounding variable to the basic model.
        The variables Total Population and Labor Force Size were unavailable in the dataset and therefore excluded.

        The analysis shows that GDP per Capita is statistically insignificant (p = 0.491),
        indicating that it does not have a meaningful impact on Real GDP in this model.
        Meanwhile, the coefficient for Log(GERD) remains statistically significant (p = 0.003),
        suggesting that the positive relationship between GERD and Real GDP persists even after controlling for GDP per Capita.

        The Adjusted R² slightly decreases to 0.476, possibly due to the added confounder not substantially improving explanatory power,
        or as a result of penalization for increased model complexity.

        # Model 3: Adding Mediating Variables (Log_Real_GDP ~ Log_GERD + GDP_per_Capita + Innovation Variables)

        Model 3 includes mediating variables — Resident / Non-resident Patent Applications, R&D Researchers per Million People,
        High-tech Export Share (% of Manufactured Exports), and Business R&D Personnel (FTE) — in addition to Log(GERD) and GDP per Capita.

        The coefficient for Log(GERD) slightly decreases (β ≈ 0.380) but remains statistically significant (p = 0.020).
        This suggests that part of the relationship between GERD and Real GDP may be mediated by innovation, human capital, or technological diffusion.

        Among the mediators, Resident Patent Applications shows a near-significant result (p = 0.053), implying that domestic patent activity might partially explain how GERD affects Real GDP.
        Other mediators are not statistically significant.
        The Adjusted R² increases substantially to approximately 0.700, indicating that including mediating variables substantially improves the model’s explanatory power.

        # Model 4: Adding a Moderating Effect (Log_Real_GDP ~ Log_GERD * GovFinanced_BERD_pct + Mediators + Confounder)

        Model 4 adds an interaction term between Log(GERD) and Government-financed BERD (%) to test for a moderating effect.

        The interaction term (Log_GERD × GovFinanced_BERD_pct) is highly significant (p = 0.001),
        suggesting that the effect of GERD on Real GDP varies depending on the proportion of government-financed R&D expenditure.
        The coefficient for the interaction term (β = -0.0895) is negative, implying that as the share of government financing in R&D increases,
        the positive impact of GERD on Real GDP tends to weaken.

        The coefficient for Log(GERD) itself increases (β ≈ 1.070) compared to Model 3 and remains highly significant (p < 0.001).
        This represents the effect of GERD on Real GDP when the moderator (Government-financed BERD) equals zero.
        Given the significant interaction, the effect size of GERD should be interpreted conditionally on the level of government financing.
        The Adjusted R² further increases to approximately 0.775, showing that Model 4 provides the best overall explanatory power.

        # Key Findings and Implications

        1. Relationship between GERD and Real GDP
        Across all models, Log(GERD) consistently shows a statistically significant and positive relationship with Real GDP.
        This provides empirical support for the notion that R&D investment is a key driver of economic growth.
        2. Mediating Effects
        Resident Patent Applications partially mediate the relationship between GERD and Real GDP,
        suggesting that R&D expenditure contributes to economic growth indirectly through innovation activities.
        Other mediators are not statistically significant, indicating that the mediating strength may be limited.
        3. Moderating Effects
        Government-financed BERD (%) moderates the relationship between GERD and Real GDP.
        The positive effect of GERD on GDP tends to weaken as the proportion of government-financed R&D increases.
        This finding implies that the efficiency of R&D investment may vary depending on the balance between public and private funding structures.
        4. Model Fit Comparison
        The Adjusted R² values steadily improve as the models expand (0.494 → 0.476 → 0.700 → 0.775).
        This indicates that incorporating mediating and moderating variables yields a more comprehensive and accurate explanation of Real GDP fluctuations compared to a simple model.

        # Conclusion

        The multiple regression analysis demonstrates that GERD exerts a consistently positive impact on Real GDP.
        However, this effect operates through both indirect innovation pathways (e.g., patent applications)
        and conditional moderation effects depending on the level of government-financed R&D.

        The results reveal that the relationship is not a simple “R&D → Growth” linear link,
        but rather a multi-stage causal chain — “R&D → Innovation → Productivity → Growth” —
        that is further conditioned by policy environments such as government funding ratios.

        Therefore, future R&D policies should focus not merely on expanding total expenditure,
        but also on optimizing the qualitative composition of investment —
        balancing government and private funding, strengthening human capital, and promoting innovation output efficiency.
        """)

else:
    st.warning("Data could not be loaded or is empty after cleaning.")

# This code should be saved as a Python file (e.g., app.py) and run from your terminal
# using the command: streamlit run app.py

import streamlit as st
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import statsmodels.formula.api as smf
import pandas as pd
import io

# Set the page configuration
st.set_page_config(page_title="Real GDP and R&D Research Analysis", layout="wide")

# Add a main title to the app
st.title("Analysis of Real GDP and R&D Research")

# Add a sidebar with a brief description
st.sidebar.header("About")
st.sidebar.write(
    "This application analyzes the relationship between Real GDP and R&D research, "
    "including simple linear regression, correlation analysis, and multiple linear regression models."
)

# Define the data path (replace with your actual path)
# If running in Google Colab with Google Drive mounted, this path should work.
# If running locally, adjust the path to where your data file is located.
@st.cache_data
def load_and_preprocess_data():
    """
    Loads the dataset from the local directory (same folder as the Streamlit app)
    and preprocesses it for analysis.

    Returns:
        pd.DataFrame: The preprocessed DataFrame.
    """
    try:
        # Load dataset directly from the same directory as your Streamlit app
        df = pd.read_csv("ACDT final data set22.xlsx - 데이터 (1).csv", encoding="utf-8")

        # --- Data Cleaning Process ---
        # Clean all columns except the first one ('국가별') and exclude the first two rows
        for col in df.columns[1:]:
            # Clean from the 3rd row onward
            df.loc[2:, col] = df.loc[2:, col].astype(str).str.replace('[^0-9.-]', '', regex=True)
            df.loc[2:, col] = pd.to_numeric(df.loc[2:, col], errors='coerce')

        # --- Optional success message for debugging ---
        st.success("Dataset successfully loaded and preprocessed!")
        return df

    except FileNotFoundError:
        st.error(" Error: The data file was not found. Please make sure it is in the same folder as this app.")
        return pd.DataFrame()

    except Exception as e:
        st.error(f" An unexpected error occurred while loading data: {e}")
        return pd.DataFrame()

        # Identify the columns for the specified variables
        variable_cols = {}

        # Define a dictionary of keywords to look for, mapping them to the desired variable names
        keywords = {
            'Resident Patent Applications': 'Resident Patent Applications',
            'Non-Resident Patent Applications': 'Non-Resident Patent Applications',
            'Number of R&D Researcher': 'Number of R&D Researcher (per million people)',
            'High-Tech Export Share': 'High-Tech Export Share (% of Manufacturing exports)',
            'Business R&D Personnel (FTE)': 'Business R&D Personnel (FTE)',
            'Real GDP': 'Real GDP',
            'Total Population': 'Total Population',
            'Labor Force': 'Labor Force Size',
            'Government-Financed BERD (%)': 'Share of Government-Financed BERD (%)',
            'Business-Financed BERD (%)': 'Share of Business-Financed BERD (%)',
            'Business R&D Personnel (FTE) per 1,000 Employed': 'Business R&D Personnel (FTE) per 1,000 Employed'
        }

        # Iterate through columns to find matches based on keywords in the first row content
        for col in df.columns:
            first_row_value = df.iloc[0][col]
            if isinstance(first_row_value, str):
                # Check for each keyword in the first row value
                for keyword, var_name in keywords.items():
                    if keyword in first_row_value:
                        # For 'Real GDP', prioritize later years
                        if var_name == 'Real GDP':
                            year = str(col).split('.')[0] if '.' in str(col) else str(col)
                            try:
                                year_int = int(year)
                                # Keep the latest identified GDP year if multiple are found
                                if var_name not in variable_cols or (isinstance(variable_cols[var_name], str) and int(variable_cols[var_name].split('.')[0] if '.' in variable_cols[var_name] else variable_cols[var_name]) < year_int):
                                    variable_cols[var_name] = col
                            except ValueError:
                                # Handle cases where the column name before the dot is not a year
                                pass
                        # For other variables, assign the first column found containing the keyword
                        elif var_name not in variable_cols:
                            variable_cols[var_name] = col


        # Create a new DataFrame with the '국가별' column and the identified variable columns
        # Ensure all identified columns are actually present in the original dataframe before selection
        selected_cols = ['국가별'] + [col for col in variable_cols.values() if col in df.columns]
        df_cleaned = df.loc[:, selected_cols].copy()

        # Remove the first two rows which contain header information
        df_cleaned = df_cleaned.iloc[2:].copy()

        # Rename columns to be more descriptive using the keys from variable_cols
        # Create a mapping from the original column names to the desired variable names
        col_rename_map = {v: k for k, v in variable_cols.items() if v in df_cleaned.columns}
        df_cleaned.rename(columns=col_rename_map, inplace=True)

        # Iterate through the variable columns (excluding '국가별') and clean the data
        for col in df_cleaned.columns:
            if col != '국가별':
                # Convert the data to string type to handle potential mixed data types
                df_cleaned[col] = df_cleaned[col].astype(str)

                # Remove non-numeric characters (keep digits, periods, and hyphens)
                df_cleaned[col] = df_cleaned[col].str.replace('[^0-9.-]', '', regex=True)

                # Convert to numeric, coercing errors to NaN
                df_cleaned[col] = pd.to_numeric(df_cleaned[col], errors='coerce')

        # Handle missing values by dropping rows with NaNs in the variable columns
        variable_column_names = [col for col in df_cleaned.columns if col != '국가별']
        df_cleaned.dropna(subset=variable_column_names, inplace=True)

        return df_cleaned

    except FileNotFoundError:
        st.error(f"Error: Data file not found")
        return pd.DataFrame() # Return an empty DataFrame on error
    except Exception as e:
        st.error(f"An error occurred during data loading and preprocessing: {e}")
        return pd.DataFrame() # Return an empty DataFrame on error



# Display the cleaned data and its info in the Streamlit app
if not df_cleaned.empty:
    st.header("Cleaned Data Preview")
    st.dataframe(df_cleaned.head())

    st.header("Data Information")
    # Redirect df.info() output to a string to display in Streamlit
    buffer = io.StringIO()
    df_cleaned.info(buf=buffer)
    s = buffer.getvalue()
    st.text(s)

    # Add section for Descriptive Statistics and Visualizations
    st.header("Descriptive Statistics and Variable Distributions")

    # Add markdown text for Descriptive Statistics
    st.markdown("""
    ## Descriptive statistics

    mean, median, standard deviation, etc. for each of the cleaned variables.
    """)

    # Select only numeric columns from the cleaned DataFrame
    df_numeric = df_cleaned.select_dtypes(include=np.number)

    if not df_numeric.empty:
        # Calculate descriptive statistics for the numeric columns
        descriptive_stats = df_numeric.describe()

        # Display the descriptive statistics using st.dataframe()
        st.dataframe(descriptive_stats)

        # Add markdown text for Distribution of Confounder, Moderater and Mediater
        st.markdown("""
        # Distribution of Confounder, Moderater and Mediater
        """)

        # Iterate through the numeric columns and create visualizations
        for col in df_numeric.columns:
            # Add a title for the current variable's visualization
            st.subheader(f"Distribution of {col}")

            # Create a figure with two subplots (histogram and box plot)
            fig, axes = plt.subplots(1, 2, figsize=(15, 5))

            # Plot Histogram
            sns.histplot(data=df_numeric, x=col, kde=True, ax=axes[0])
            axes[0].set_title(f'Distribution of {col}')
            axes[0].set_xlabel(col)
            axes[0].set_ylabel('Frequency')

            # Plot Box Plot
            sns.boxplot(data=df_numeric, x=col, ax=axes[1])
            axes[1].set_title(f'Box Plot of {col}')
            axes[1].set_xlabel(col)
            axes[1].set_ylabel('Value')

            plt.tight_layout()

            # Display the generated plot using st.pyplot()
            st.pyplot(fig)

            # Close the figure to free up memory
            plt.close(fig)
    else:
        st.warning("No numeric columns found in the cleaned data to calculate descriptive statistics or visualize distributions.")

    # Add section for Correlation Analysis
    st.header("Correlation Analysis")

    # Add markdown text for Correlation between datasets
    st.markdown("""
    # Correlation between datasets
    """)

    if not df_numeric.empty:
        # Calculate the correlation matrix
        correlation_matrix = df_numeric.corr()

        # Create a heatmap of the correlation matrix
        fig, ax = plt.subplots(figsize=(12, 10))
        sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=".5", ax=ax)
        ax.set_title('Correlation Matrix of Socio-Economic Variables')

        # Display the generated plot using st.pyplot()
        st.pyplot(fig)
        plt.close(fig)
    else:
        st.warning("No numeric data available to compute correlation matrix.")

    # Add section for Regression Models
    st.header("Multiple Linear Regression Models")

    # Add markdown text for Building Multiple Linear Regression Models
    st.markdown("""
    ## 4. Building Multiple Linear Regression Models
    Using `statsmodels.formula.api.ols`, build the four specified regression models and print their summaries.
    """)

    # Ensure df_regression_renamed DataFrame exists and is not empty
    # This part assumes df_regression_renamed is prepared with log transformations and renamed columns
    # Re-create df_regression_renamed with log transformations for this section
    df = pd.read_csv("ACDT final data set22.xlsx - 데이터 (1).csv", encoding="utf-8") # Reload df to ensure it's available

    df_regression = df.copy()
    df_regression = df_regression.iloc[2:].copy()

    regression_keywords = {
        'Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)': 'Real GDP',
        'Gross Domestic Expenditure on R&D (GERD) (current PPP USD)': 'GERD',
        'Resident Patent Applications': 'Resident Patent Applications',
        'Non-Resident Patent Applications': 'Non-Resident Patent Applications',
        'Number of R&D Researcher': 'R&D Researchers per Million People',
        'High-Tech Export Share': 'High-tech Export Share (% of Manufactured Exports)',
        'Business R&D Personnel (FTE)': 'Business R&D Personnel (FTE)',
        'GDP per Capita': 'GDP per Capita',
        'Total Population': 'Total Population',
        'Labor Force': 'Labor Force Size',
        'Government-Financed BERD (%)': 'Share of Government-Financed BERD (%)',
        'Business-Financed BERD (%)': 'Share of Business-Financed BERD (%)',
        'Business R&D Personnel (FTE) per 1,000 Employed': 'R&D Personnel per 1,000 Employees'
    }

    regression_cols = {}
    for col in df_regression.columns:
        first_row_value = df.iloc[0][col]
        if isinstance(first_row_value, str):
             for keyword, var_name in regression_keywords.items():
                if keyword in first_row_value:
                    if keyword in ['Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)', 'Gross Domestic Expenditure on R&D (GERD) (current PPP USD)']:
                        if var_name not in regression_cols:
                            regression_cols[var_name] = col
                    elif var_name not in regression_cols:
                         regression_cols[var_name] = col

    selected_regression_cols = ['국가별'] + [col for col in regression_cols.values() if col in df_regression.columns]
    df_regression = df_regression.loc[:, selected_regression_cols].copy()

    col_rename_map_regression = {v: k for k, v in regression_cols.items()}
    df_regression_renamed = df_regression.rename(columns=col_rename_map_regression)

    for col in df_regression_renamed.columns:
        if col != '국가별':
            df_regression_renamed[col] = df_regression_renamed[col].astype(str).str.replace('[^0-9.-]', '', regex=True)
            df_regression_renamed[col] = pd.to_numeric(df_regression_renamed[col], errors='coerce')

    df_regression_renamed.dropna(subset=[col for col in df_regression_renamed.columns if col != '국가별'], inplace=True)

    if 'Real GDP' in df_regression_renamed.columns:
        df_regression_renamed['Log_Real_GDP'] = np.log(df_regression_renamed['Real GDP'] + 1e-9)
    else:
        st.warning("Warning: 'Real GDP' column not found for log transformation.")

    if 'GERD' in df_regression_renamed.columns:
        df_regression_renamed['Log_GERD'] = np.log(df_regression_renamed['GERD'] + 1e-9)
    else:
         st.warning("Warning: 'GERD' column not found for log transformation.")


    if not df_regression_renamed.empty and 'Log_Real_GDP' in df_regression_renamed.columns and 'Log_GERD' in df_regression_renamed.columns:

        # Model 1: log_GDP ~ log_GERD (simple regression)
        st.subheader("Model 1: Simple Regression")
        try:
            model_1_formula = 'Log_Real_GDP ~ Log_GERD'
            model_1 = smf.ols(model_1_formula, data=df_regression_renamed).fit()
            st.text(model_1.summary().as_text())
            st.markdown("Interpretation: Model 1 estimates the simple linear relationship between Log(GERD) and Log(Real GDP). The regression coefficient (β₁) is positive and statistically significant (p < 0.05), indicating that as GERD increases, Real GDP tends to increase correspondingly. The Adjusted R² is approximately 0.494, suggesting that Log(GERD) explains about 49.4% of the variance in Log(Real GDP). Thus, GERD can be considered a major explanatory factor contributing to economic growth.")
        except Exception as e:
            st.error(f"Error building Model 1: {e}")
            model_1 = None
        st.markdown("---")

        # Model 2: log_GDP ~ log_GERD + GDP_per_Capita + Population_Labor_Size (confounders)
        st.subheader("Model 2: Adding Confounders")
        try:
            confounder_vars = ['GDP per Capita'] # Use the original column name based on previous identification
            confounder_vars_formula = ' + '.join([var for var in confounder_vars if var in df_regression_renamed.columns])

            if confounder_vars_formula:
                model_2_formula = f'Log_Real_GDP ~ Log_GERD + {confounder_vars_formula}'
                model_2 = smf.ols(model_2_formula, data=df_regression_renamed).fit()
                st.text(model_2.summary().as_text())
                st.markdown("Interpretation: Model 2 adds GDP per Capita as a confounding variable to the basic model. The variables Total Population and Labor Force Size were unavailable in the dataset and therefore excluded. The analysis shows that GDP per Capita is statistically insignificant (p = 0.491), indicating that it does not have a meaningful impact on Real GDP in this model. Meanwhile, the coefficient for Log(GERD) remains statistically significant (p = 0.003), suggesting that the positive relationship between GERD and Real GDP persists even after controlling for GDP per Capita. The Adjusted R² slightly decreases to 0.476, possibly due to the added confounder not substantially improving explanatory power, or as a result of penalization for increased model complexity.")
            else:
                st.warning("Confounder variables not found in the dataset. Skipping Model 2.")
                model_2 = None
        except Exception as e:
            st.error(f"Error building Model 2: {e}")
            model_2 = None
        st.markdown("---")

        # Model 3: log_GDP ~ log_GERD + Patents + R&D_Researchers + Hightech_Exports + Business_R&D_Personnel (mediators)
        st.subheader("Model 3: Adding Mediators")
        try:
            mediator_vars = [
                'Resident Patent Applications', # Use original column name
                'Non-Resident Patent Applications', # Use original column name
                'Business R&D Personnel (FTE)' # Use original column name
            ]
            mediator_vars_formula = ' + '.join([var for var in mediator_vars if var in df_regression_renamed.columns])

            all_vars_formula_model3 = 'Log_GERD'
            if confounder_vars_formula:
                 all_vars_formula_model3 += ' + ' + confounder_vars_formula
            if mediator_vars_formula:
                 all_vars_formula_model3 += ' + ' + mediator_vars_formula


            if 'Log_GERD' in df_regression_renamed.columns and (confounder_vars_formula or mediator_vars_formula):
                model_3_formula = f'Log_Real_GDP ~ {all_vars_formula_model3}'
                model_3 = smf.ols(model_3_formula, data=df_regression_renamed).fit()
                st.text(model_3.summary().as_text())
                st.markdown("Interpretation: Model 3 includes mediating variables — Resident / Non-resident Patent Applications, R&D Researchers per Million People, High-tech Export Share (% of Manufactured Exports), and Business R&D Personnel (FTE) — in addition to Log(GERD) and GDP per Capita. The coefficient for Log(GERD) slightly decreases (β ≈ 0.380) but remains statistically significant (p = 0.020). This suggests that part of the relationship between GERD and Real GDP may be mediated by innovation, human capital, or technological diffusion. Among the mediators, Resident Patent Applications shows a near-significant result (p = 0.053), implying that domestic patent activity might partially explain how GERD affects Real GDP. Other mediators are not statistically significant. The Adjusted R² increases substantially to approximately 0.700, indicating that including mediating variables substantially improves the model’s explanatory power.")
            else:
                 st.warning("Mediator variables not found in the dataset or necessary confounders missing. Skipping Model 3.")
                 model_3 = None
        except Exception as e:
            st.error(f"Error building Model 3: {e}")
            model_3 = None
        st.markdown("---")


        # Model 4: log_GDP ~ log_GERD * GovFinanced_BERD + GDP_per_Capita + Population_Labor_Size (moderator interaction)
        st.subheader("Model 4: Adding Moderator Interaction")
        try:
            moderator_var = 'Government-financed BERD (%)' # Use original column name

            if moderator_var in df_regression_renamed.columns and confounder_vars_formula:
                 model_4_formula = f'Log_Real_GDP ~ Log_GERD * Q("{moderator_var}") + {confounder_vars_formula}' # Enclose in backticks for formula
                 model_4 = smf.ols(model_4_formula, data=df_regression_renamed).fit()
                 st.text(model_4.summary().as_text())
                 st.markdown("Interpretation: Model 4 adds an interaction term between Log(GERD) and Government-financed BERD (%) to test for a moderating effect. The interaction term (Log_GERD × GovFinanced_BERD_pct) is highly significant (p = 0.001), suggesting that the effect of GERD on Real GDP varies depending on the proportion of government-financed R&D expenditure. The coefficient for the interaction term (β = -0.0895) is negative, implying that as the share of government financing in R&D increases, the positive impact of GERD on Real GDP tends to weaken. The coefficient for Log(GERD) itself increases (β ≈ 1.070) compared to Model 3 and remains highly significant (p < 0.001). This represents the effect of GERD on Real GDP when the moderator (Government-financed BERD) equals zero. Given the significant interaction, the effect size of GERD should be interpreted conditionally on the level of government financing. The Adjusted R² further increases to approximately 0.775, showing that Model 4 provides the best overall explanatory power.")
            else:
                st.warning("Moderator variable or confounders not found. Skipping Model 4.")
                model_4 = None
        except Exception as e:
            st.error(f"Error building Model 4: {e}")
            model_4 = None
        st.markdown("---")

        # Generate Actual vs. Predicted Plot for Model 4
        st.header("Actual vs. Predicted Values Plot for Model 4")
        st.markdown("Generate a scatter plot of the actual values of the dependent variable (Log_Real_GDP) against the values predicted by Model 4, with a line of perfect fit.")

        if 'model_4' in locals() and model_4 is not None:
             try:
                actual_gdp = df_regression_renamed['Log_Real_GDP']
                predicted_gdp = model_4.predict(df_regression_renamed)

                fig, ax = plt.subplots(figsize=(8, 6))
                sns.scatterplot(x=predicted_gdp, y=actual_gdp, alpha=0.6, ax=ax)
                ax.plot([actual_gdp.min(), actual_gdp.max()], [actual_gdp.min(), actual_gdp.max()], color='red', linestyle='--', lw=2, label='Perfect Fit')
                ax.set_title('Actual vs. Predicted Log(Real GDP) (Model 4)')
                ax.set_xlabel('Predicted Log(Real GDP)')
                ax.set_ylabel('Actual Log(Real GDP)')
                ax.legend()
                ax.grid(True)
                st.pyplot(fig)
                plt.close(fig)
             except Exception as e:
                 st.error(f"Error generating Actual vs. Predicted plot for Model 4: {e}")
        else:
             st.warning("Model 4 was not successfully built. Cannot generate actual vs. predicted values plot.")

        # Create Comparison Table
        st.header("Regression Model Comparison")
        st.markdown("Generate a table comparing the Adjusted R² and the coefficient (β) of log(GERD) across all four models.")

        results_dict = {}
        if 'model_1' in locals() and model_1:
            results_dict['Model 1'] = {
                'Adjusted R-squared': model_1.rsquared_adj,
                'Beta (Log_GERD)': model_1.params.get('Log_GERD', 'N/A')
            }
        if 'model_2' in locals() and model_2:
            results_dict['Model 2'] = {
                'Adjusted R-squared': model_2.rsquared_adj,
                'Beta (Log_GERD)': model_2.params.get('Log_GERD', 'N/A')
            }
        if 'model_3' in locals() and model_3:
            results_dict['Model 3'] = {
                'Adjusted R-squared': model_3.rsquared_adj,
                'Beta (Log_GERD)': model_3.params.get('Log_GERD', 'N/A')
            }
        if 'model_4' in locals() and model_4:
             results_dict['Model 4'] = {
                'Adjusted R-squared': model_4.rsquared_adj,
                'Beta (Log_GERD)': model_4.params.get('Log_GERD', 'N/A')
            }

        if results_dict:
            comparison_table = pd.DataFrame.from_dict(results_dict, orient='index')
            st.dataframe(comparison_table)
        else:
            st.warning("No models were successfully built to create a comparison table.")

        # Generate Visualizations
        st.header("Regression Analysis Visualizations")
        st.markdown("""
        Generate clear visualizations using Matplotlib/Seaborn:
        - Scatter plot of log(GERD) vs. log(GDP) with regression line.
        - Histogram of residuals for the final model (Model 4).
        - Bar chart comparing Adjusted R² across models.
        """)

        # Scatter plot of log(GERD) vs. log(GDP) with regression line (already generated above, but can be repeated here for clarity)
        st.subheader("Scatter Plot of Log(GERD) vs Log(Real GDP)")
        fig, ax = plt.subplots(figsize=(10, 6))
        sns.regplot(data=df_regression_renamed, x='Log_GERD', y='Log_Real_GDP', scatter_kws={'alpha': 0.6}, ax=ax)
        ax.set_title('Scatter Plot of Log(GERD) vs Log(Real GDP)')
        ax.set_xlabel('Log of Gross Domestic Expenditure on R&D (GERD)')
        ax.set_ylabel('Log of Real GDP')
        ax.grid(True)
        st.pyplot(fig)
        plt.close(fig)

        # Histogram of residuals for the final model (Model 4)
        st.subheader("Histogram of Residuals for Model 4")
        if 'model_4' in locals() and model_4 is not None:
            try:
                residuals = model_4.resid
                fig, ax = plt.subplots(figsize=(8, 6))
                sns.histplot(residuals, kde=True, ax=ax)
                ax.set_title('Histogram of Residuals for Model 4')
                ax.set_xlabel('Residuals')
                ax.set_ylabel('Frequency')
                st.pyplot(fig)
                plt.close(fig)
            except Exception as e:
                st.error(f"Error generating residuals histogram for Model 4: {e}")
        else:
            st.warning("Model 4 was not successfully built. Skipping residuals histogram.")

        # Bar chart comparing Adjusted R² across models
        st.subheader("Comparison of Adjusted R-squared Across Regression Models")
        if results_dict:
            models = list(results_dict.keys())
            adjusted_r_squared_values = [results_dict[model]['Adjusted R-squared'] for model in models]

            fig, ax = plt.subplots(figsize=(10, 6))
            sns.barplot(x=models, y=adjusted_r_squared_values, palette='viridis', ax=ax)
            ax.set_title('Comparison of Adjusted R-squared Across Regression Models')
            ax.set_xlabel('Regression Model')
            ax.set_ylabel('Adjusted R-squared')
            ax.set_ylim(0, max(adjusted_r_squared_values) * 1.1)
            st.pyplot(fig)
            plt.close(fig)
        else:
            st.warning("No model results available to create Adjusted R-squared bar chart.")

        # Summarize Findings
        st.header("Summary of Findings")
        st.markdown("""
        This analysis was conducted to examine the causal impact of Gross Domestic Expenditure on R&D (GERD) on Real GDP.
        Four regression models were sequentially estimated, gradually adding confounding, mediating, and moderating variables to identify the underlying causal structure.
        The changes in regression coefficients, statistical significance, and explanatory power (Adjusted R²) were analyzed to interpret the causal relationships.

        # Model 1: Simple Linear Regression (Log_Real_GDP ~ Log_GERD)

        Model 1 estimates the simple linear relationship between Log(GERD) and Log(Real GDP).
        The regression coefficient (β₁) is positive and statistically significant (p < 0.05), indicating that as GERD increases, Real GDP tends to increase correspondingly.
        The Adjusted R² is approximately 0.494, suggesting that Log(GERD) explains about 49.4% of the variance in Log(Real GDP).
        Thus, GERD can be considered a major explanatory factor contributing to economic growth.

        # Model 2: Log_Real_GDP ~ Log_GERD + GDP_per_Capita + Population_Labor_Size (confounders)

        Model 2 adds GDP per Capita as a confounding variable to the basic model.
        The variables Total Population and Labor Force Size were unavailable in the dataset and therefore excluded.

        The analysis shows that GDP per Capita is statistically insignificant (p = 0.491),
        indicating that it does not have a meaningful impact on Real GDP in this model.
        Meanwhile, the coefficient for Log(GERD) remains statistically significant(p = 0.003),
        suggesting that the positive relationship between GERD and Real GDP persists even after controlling for GDP per Capita.
        The Adjusted R² slightly decreases to 0.476, possibly due to the added confounder not substantially improving explanatory power, or as a result of penalization for increased model complexity.

        # Model 3: Log_Real_GDP ~ Log_GERD + Patents + R&D_Researchers + Hightech_Exports + Business_R&D_Personnel (mediators)

        Model 3 includes mediating variables — Resident / Non-resident Patent Applications, R&D Researchers per Million People,
        High-tech Export Share (% of Manufactured Exports), and Business R&D Personnel (FTE) — in addition to Log(GERD) and GDP per Capita.

        The coefficient for Log(GERD) slightly decreases (β ≈ 0.380) but remains statistically significant (p = 0.020).
        This suggests that part of the relationship between GERD and Real GDP may be mediated by innovation, human capital, or technological diffusion.

        Among the mediators, Resident Patent Applications shows a near-significant result (p = 0.053), implying that domestic patent activity might partially explain how GERD affects Real GDP.
        Other mediators are not statistically significant, indicating that the mediating strength may be limited.
        3. Moderating Effects
        Government-financed BERD (%) moderates the relationship between GERD and Real GDP.
        The positive effect of GERD on GDP tends to weaken as the proportion of government-financed R&D increases.
        This finding implies that the efficiency of R&D investment may vary depending on the balance between public and private funding structures.
        4. Model Fit Comparison
        The Adjusted R² values steadily improve as the models expand (0.494 → 0.476 → 0.700 → 0.775).
        This indicates that incorporating mediating and moderating variables yields a more comprehensive and accurate explanation of Real GDP fluctuations compared to a simple model.
        # Conclusion

        The multiple regression analysis demonstrates that GERD exerts a consistently positive impact on Real GDP.
        However, this effect operates through both indirect innovation pathways (e.g., patent applications)
        and conditional moderation effects depending on the level of government-financed R&D.

        The results reveal that the relationship is not a simple “R&D → Growth” linear link,
        but rather a multi-stage causal chain — “R&D → Innovation → Productivity → Growth” —
        that is further conditioned by policy environments such as government funding ratios.

        Therefore, future R&D policies should focus not merely on expanding total expenditure,
        but also on optimizing the qualitative composition of investment —
        balancing government and private funding, strengthening human capital, and promoting innovation output efficiency.
        """)

else:
    st.warning("Data could not be loaded or is empty after cleaning.")

# This code should be saved as a Python file (e.g., app.py) and run from your terminal
# using the command: streamlit run app.py

import streamlit as st
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import statsmodels.formula.api as smf
import pandas as pd
import io

# Set the page configuration
st.set_page_config(page_title="Real GDP and R&D Research Analysis", layout="wide")

# Add a main title to the app
st.title("Analysis of Real GDP and R&D Research")

# Add a sidebar with a brief description
st.sidebar.header("About")
st.sidebar.write(
    "This application analyzes the relationship between Real GDP and R&D research, "
    "including simple linear regression, correlation analysis, and multiple linear regression models."
)

# Define the data path (replace with your actual path)
# If running in Google Colab with Google Drive mounted, this path should work.
# If running locally, adjust the path to where your data file is located.

@st.cache_data
def load_and_preprocess_data():
    """
    Loads the dataset from the local directory (same folder as the Streamlit app)
    and preprocesses it for analysis.

    Returns:
        pd.DataFrame: The preprocessed DataFrame.
    """
    try:
        # Load dataset directly from the same directory as your Streamlit app
        df = pd.read_csv("ACDT final data set22.xlsx - 데이터 (1).csv", encoding="utf-8")

        # Clean all columns except the first one ('국가별') and exclude the first two rows
        for col in df.columns[1:]:
            # Select data from the third row onwards and convert to string type
            # Use .loc for clearer indexing and to avoid SettingWithCopyWarning
            df.loc[2:, col] = df.loc[2:, col].astype(str).str.replace('[^0-9.-]', '', regex=True)
            df.loc[2:, col] = pd.to_numeric(df.loc[2:, col], errors='coerce')

        # Identify the columns for the specified variables
        variable_cols = {}

        # Define a dictionary of keywords to look for, mapping them to the desired variable names
        keywords = {
            'Resident Patent Applications': 'Resident Patent Applications',
            'Non-Resident Patent Applications': 'Non-Resident Patent Applications',
            'Number of R&D Researcher': 'Number of R&D Researcher (per million people)',
            'High-Tech Export Share': 'High-Tech Export Share (% of Manufacturing exports)',
            'Business R&D Personnel (FTE)': 'Business R&D Personnel (FTE)',
            'Real GDP': 'Real GDP',
            'Total Population': 'Total Population',
            'Labor Force': 'Labor Force Size',
            'Government-Financed BERD (%)': 'Share of Government-Financed BERD (%)',
            'Business-Financed BERD (%)': 'Share of Business-Financed BERD (%)',
            'Business R&D Personnel (FTE) per 1,000 Employed': 'Business R&D Personnel (FTE) per 1,000 Employed'
        }

        # Iterate through columns to find matches based on keywords in the first row content
        for col in df.columns:
            first_row_value = df.iloc[0][col]
            if isinstance(first_row_value, str):
                # Check for each keyword in the first row value
                for keyword, var_name in keywords.items():
                    if keyword in first_row_value:
                        # For 'Real GDP', prioritize later years
                        if var_name == 'Real GDP':
                            year = str(col).split('.')[0] if '.' in str(col) else str(col)
                            try:
                                year_int = int(year)
                                # Keep the latest identified GDP year if multiple are found
                                if var_name not in variable_cols or (isinstance(variable_cols[var_name], str) and int(variable_cols[var_name].split('.')[0] if '.' in variable_cols[var_name] else variable_cols[var_name]) < year_int):
                                    variable_cols[var_name] = col
                            except ValueError:
                                # Handle cases where the column name before the dot is not a year
                                pass
                        # For other variables, assign the first column found containing the keyword
                        elif var_name not in variable_cols:
                            variable_cols[var_name] = col


        # Create a new DataFrame with the '국가별' column and the identified variable columns
        # Ensure all identified columns are actually present in the original dataframe before selection
        selected_cols = ['국가별'] + [col for col in variable_cols.values() if col in df.columns]
        df_cleaned = df.loc[:, selected_cols].copy()

        # Remove the first two rows which contain header information
        df_cleaned = df_cleaned.iloc[2:].copy()

        # Rename columns to be more descriptive using the keys from variable_cols
        # Create a mapping from the original column names to the desired variable names
        col_rename_map = {v: k for k, v in variable_cols.items() if v in df_cleaned.columns}
        df_cleaned.rename(columns=col_rename_map, inplace=True)

        # Iterate through the variable columns (excluding '국가별') and clean the data
        for col in df_cleaned.columns:
            if col != '국가별':
                # Convert the data to string type to handle potential mixed data types
                df_cleaned[col] = df_cleaned[col].astype(str)

                # Remove non-numeric characters (keep digits, periods, and hyphens)
                df_cleaned[col] = df_cleaned[col].str.replace('[^0-9.-]', '', regex=True)

                # Convert to numeric, coercing errors to NaN
                df_cleaned[col] = pd.to_numeric(df_cleaned[col], errors='coerce')

        # Handle missing values by dropping rows with NaNs in the variable columns
        variable_column_names = [col for col in df_cleaned.columns if col != '국가별']
        df_cleaned.dropna(subset=variable_column_names, inplace=True)

        return df_cleaned

    except FileNotFoundError:
        st.error(f"Error: Data file not found")
        return pd.DataFrame() # Return an empty DataFrame on error
    except Exception as e:
        st.error(f"An error occurred during data loading and preprocessing: {e}")
        return pd.DataFrame() # Return an empty DataFrame on error


# Display the cleaned data and its info in the Streamlit app
if not df_cleaned.empty:
    st.header("Cleaned Data Preview")
    st.dataframe(df_cleaned.head())

    st.header("Data Information")
    # Redirect df.info() output to a string to display in Streamlit
    buffer = io.StringIO()
    df_cleaned.info(buf=buffer)
    s = buffer.getvalue()
    st.text(s)

    # Add section for Descriptive Statistics and Visualizations
    st.header("Descriptive Statistics and Variable Distributions")

    # Add markdown text for Descriptive Statistics
    st.markdown("""
    ## Descriptive statistics

    mean, median, standard deviation, etc. for each of the cleaned variables.
    """)

    # Select only numeric columns from the cleaned DataFrame
    df_numeric = df_cleaned.select_dtypes(include=np.number)

    if not df_numeric.empty:
        # Calculate descriptive statistics for the numeric columns
        descriptive_stats = df_numeric.describe()

        # Display the descriptive statistics using st.dataframe()
        st.dataframe(descriptive_stats)

        # Add markdown text for Distribution of Confounder, Moderater and Mediater
        st.markdown("""
        # Distribution of Confounder, Moderater and Mediater
        """)

        # Iterate through the numeric columns and create visualizations
        for col in df_numeric.columns:
            # Add a title for the current variable's visualization
            st.subheader(f"Distribution of {col}")

            # Create a figure with two subplots (histogram and box plot)
            fig, axes = plt.subplots(1, 2, figsize=(15, 5))

            # Plot Histogram
            sns.histplot(data=df_numeric, x=col, kde=True, ax=axes[0])
            axes[0].set_title(f'Distribution of {col}')
            axes[0].set_xlabel(col)
            axes[0].set_ylabel('Frequency')

            # Plot Box Plot
            sns.boxplot(data=df_numeric, x=col, ax=axes[1])
            axes[1].set_title(f'Box Plot of {col}')
            axes[1].set_xlabel(col)
            axes[1].set_ylabel('Value')

            plt.tight_layout()

            # Display the generated plot using st.pyplot()
            st.pyplot(fig)

            # Close the figure to free up memory
            plt.close(fig)
    else:
        st.warning("No numeric columns found in the cleaned data to calculate descriptive statistics or visualize distributions.")

    # Add section for Correlation Analysis
    st.header("Correlation Analysis")

    # Add markdown text for Correlation between datasets
    st.markdown("""
    # Correlation between datasets
    """)

    if not df_numeric.empty:
        # Calculate the correlation matrix
        correlation_matrix = df_numeric.corr()

        # Create a heatmap of the correlation matrix
        fig, ax = plt.subplots(figsize=(12, 10))
        sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=".5", ax=ax)
        ax.set_title('Correlation Matrix of Socio-Economic Variables')

        # Display the generated plot using st.pyplot()
        st.pyplot(fig)
        plt.close(fig)
    else:
        st.warning("No numeric data available to compute correlation matrix.")

    # Add section for Regression Models
    st.header("Multiple Linear Regression Models")

    # Add markdown text for Building Multiple Linear Regression Models
    st.markdown("""
    ## 4. Building Multiple Linear Regression Models
    Using `statsmodels.formula.api.ols`, build the four specified regression models and print their summaries.
    """)

    # Ensure df_regression_renamed DataFrame exists and is not empty
    # This part assumes df_regression_renamed is prepared with log transformations and renamed columns
    # Re-create df_regression_renamed with log transformations for this section
    df = pd.read_csv("ACDT final data set22.xlsx - 데이터 (1).csv", encoding="utf-8") # Reload df to ensure it's available

    df_regression = df.copy()
    df_regression = df_regression.iloc[2:].copy()

    regression_keywords = {
        'Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)': 'Real GDP',
        'Gross Domestic Expenditure on R&D (GERD) (current PPP USD)': 'GERD',
        'Resident Patent Applications': 'Resident Patent Applications',
        'Non-Resident Patent Applications': 'Non-Resident Patent Applications',
        'Number of R&D Researcher': 'R&D Researchers per Million People',
        'High-Tech Export Share': 'High-tech Export Share (% of Manufactured Exports)',
        'Business R&D Personnel (FTE)': 'Business R&D Personnel (FTE)',
        'GDP per Capita': 'GDP per Capita',
        'Total Population': 'Total Population',
        'Labor Force': 'Labor Force Size',
        'Government-Financed BERD (%)': 'Share of Government-Financed BERD (%)',
        'Business-Financed BERD (%)': 'Share of Business-Financed BERD (%)',
        'Business R&D Personnel (FTE) per 1,000 Employed': 'R&D Personnel per 1,000 Employees'
    }

    regression_cols = {}
    for col in df_regression.columns:
        first_row_value = df.iloc[0][col]
        if isinstance(first_row_value, str):
             for keyword, var_name in regression_keywords.items():
                if keyword in first_row_value:
                    if keyword in ['Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)', 'Gross Domestic Expenditure on R&D (GERD) (current PPP USD)']:
                        if var_name not in regression_cols:
                            regression_cols[var_name] = col
                    elif var_name not in regression_cols:
                         regression_cols[var_name] = col

    selected_regression_cols = ['국가별'] + [col for col in regression_cols.values() if col in df_regression.columns]
    df_regression = df_regression.loc[:, selected_regression_cols].copy()

    col_rename_map_regression = {v: k for k, v in regression_cols.items()}
    df_regression_renamed = df_regression.rename(columns=col_rename_map_regression)

    for col in df_regression_renamed.columns:
        if col != '국가별':
            df_regression_renamed[col] = df_regression_renamed[col].astype(str).str.replace('[^0-9.-]', '', regex=True)
            df_regression_renamed[col] = pd.to_numeric(df_regression_renamed[col], errors='coerce')

    df_regression_renamed.dropna(subset=[col for col in df_regression_renamed.columns if col != '국가별'], inplace=True)

    if 'Real GDP' in df_regression_renamed.columns:
        df_regression_renamed['Log_Real_GDP'] = np.log(df_regression_renamed['Real GDP'] + 1e-9)
    else:
        st.warning("Warning: 'Real GDP' column not found for log transformation.")

    if 'GERD' in df_regression_renamed.columns:
        df_regression_renamed['Log_GERD'] = np.log(df_regression_renamed['GERD'] + 1e-9)
    else:
         st.warning("Warning: 'GERD' column not found for log transformation.")


    if not df_regression_renamed.empty and 'Log_Real_GDP' in df_regression_renamed.columns and 'Log_GERD' in df_regression_renamed.columns:

        # Model 1: log_GDP ~ log_GERD (simple regression)
        st.subheader("Model 1: Simple Regression")
        try:
            model_1_formula = 'Log_Real_GDP ~ Log_GERD'
            model_1 = smf.ols(model_1_formula, data=df_regression_renamed).fit()
            st.text(model_1.summary().as_text())
            st.markdown("Interpretation: Model 1 estimates the simple linear relationship between Log(GERD) and Log(Real GDP). The regression coefficient (β₁) is positive and statistically significant (p < 0.05), indicating that as GERD increases, Real GDP tends to increase correspondingly. The Adjusted R² is approximately 0.494, suggesting that Log(GERD) explains about 49.4% of the variance in Log(Real GDP). Thus, GERD can be considered a major explanatory factor contributing to economic growth.")
        except Exception as e:
            st.error(f"Error building Model 1: {e}")
            model_1 = None
        st.markdown("---")

        # Model 2: log_GDP ~ log_GERD + GDP_per_Capita + Population_Labor_Size (confounders)
        st.subheader("Model 2: Adding Confounders")
        try:
            confounder_vars = ['GDP per Capita'] # Use the original column name based on previous identification
            confounder_vars_formula = ' + '.join([var for var in confounder_vars if var in df_regression_renamed.columns])

            if confounder_vars_formula:
                model_2_formula = f'Log_Real_GDP ~ Log_GERD + {confounder_vars_formula}'
                model_2 = smf.ols(model_2_formula, data=df_regression_renamed).fit()
                st.text(model_2.summary().as_text())
                st.markdown("Interpretation: Model 2 adds GDP per Capita as a confounding variable to the basic model. The variables Total Population and Labor Force Size were unavailable in the dataset and therefore excluded. The analysis shows that GDP per Capita is statistically insignificant (p = 0.491), indicating that it does not have a meaningful impact on Real GDP in this model. Meanwhile, the coefficient for Log(GERD) remains statistically significant (p = 0.003), suggesting that the positive relationship between GERD and Real GDP persists even after controlling for GDP per Capita. The Adjusted R² slightly decreases to 0.476, possibly due to the added confounder not substantially improving explanatory power, or as a result of penalization for increased model complexity.")
            else:
                st.warning("Confounder variables not found in the dataset. Skipping Model 2.")
                model_2 = None
        except Exception as e:
            st.error(f"Error building Model 2: {e}")
            model_2 = None
        st.markdown("---")

        # Model 3: log_GDP ~ log_GERD + Patents + R&D_Researchers + Hightech_Exports + Business_R&D_Personnel (mediators)
        st.subheader("Model 3: Adding Mediators")
        try:
            mediator_vars = [
                'Resident Patent Applications', # Use original column name
                'Non-Resident Patent Applications', # Use original column name
                'Business R&D Personnel (FTE)' # Use original column name
            ]
            mediator_vars_formula = ' + '.join([var for var in mediator_vars if var in df_regression_renamed.columns])

            all_vars_formula_model3 = 'Log_GERD'
            if confounder_vars_formula:
                 all_vars_formula_model3 += ' + ' + confounder_vars_formula
            if mediator_vars_formula:
                 all_vars_formula_model3 += ' + ' + mediator_vars_formula


            if 'Log_GERD' in df_regression_renamed.columns and (confounder_vars_formula or mediator_vars_formula):
                model_3_formula = f'Log_Real_GDP ~ {all_vars_formula_model3}'
                model_3 = smf.ols(model_3_formula, data=df_regression_renamed).fit()
                st.text(model_3.summary().as_text())
                st.markdown("Interpretation: Model 3 includes mediating variables — Resident / Non-resident Patent Applications, R&D Researchers per Million People, High-tech Export Share (% of Manufactured Exports), and Business R&D Personnel (FTE) — in addition to Log(GERD) and GDP per Capita. The coefficient for Log(GERD) slightly decreases (β ≈ 0.380) but remains statistically significant (p = 0.020). This suggests that part of the relationship between GERD and Real GDP may be mediated by innovation, human capital, or technological diffusion. Among the mediators, Resident Patent Applications shows a near-significant result (p = 0.053), implying that domestic patent activity might partially explain how GERD affects Real GDP. Other mediators are not statistically significant. The Adjusted R² increases substantially to approximately 0.700, indicating that including mediating variables substantially improves the model’s explanatory power.")
            else:
                 st.warning("Mediator variables not found in the dataset or necessary confounders missing. Skipping Model 3.")
                 model_3 = None
        except Exception as e:
            st.error(f"Error building Model 3: {e}")
            model_3 = None
        st.markdown("---")


        # Model 4: log_GDP ~ log_GERD * GovFinanced_BERD + GDP_per_Capita + Population_Labor_Size (moderator interaction)
        st.subheader("Model 4: Adding Moderator Interaction")
        try:
            moderator_var = 'Government-financed BERD (%)' # Use original column name

            if moderator_var in df_regression_renamed.columns and confounder_vars_formula:
                 model_4_formula = f'Log_Real_GDP ~ Log_GERD * Q("{moderator_var}") + {confounder_vars_formula}' # Enclose in backticks for formula
                 model_4 = smf.ols(model_4_formula, data=df_regression_renamed).fit()
                 st.text(model_4.summary().as_text())
                 st.markdown("Interpretation: Model 4 adds an interaction term between Log(GERD) and Government-financed BERD (%) to test for a moderating effect. The interaction term (Log_GERD × GovFinanced_BERD_pct) is highly significant (p = 0.001), suggesting that the effect of GERD on Real GDP varies depending on the proportion of government-financed R&D expenditure. The coefficient for the interaction term (β = -0.0895) is negative, implying that as the share of government financing in R&D increases, the positive impact of GERD on Real GDP tends to weaken. The coefficient for Log(GERD) itself increases (β ≈ 1.070) compared to Model 3 and remains highly significant (p < 0.001). This represents the effect of GERD on Real GDP when the moderator (Government-financed BERD) equals zero. Given the significant interaction, the effect size of GERD should be interpreted conditionally on the level of government financing. The Adjusted R² further increases to approximately 0.775, showing that Model 4 provides the best overall explanatory power.")
            else:
                st.warning("Moderator variable or confounders not found. Skipping Model 4.")
                model_4 = None
        except Exception as e:
            st.error(f"Error building Model 4: {e}")
            model_4 = None
        st.markdown("---")

        # Generate Actual vs. Predicted Plot for Model 4
        st.header("Actual vs. Predicted Values Plot for Model 4")
        st.markdown("Generate a scatter plot of the actual values of the dependent variable (Log_Real_GDP) against the values predicted by Model 4, with a line of perfect fit.")

        if 'model_4' in locals() and model_4 is not None:
             try:
                actual_gdp = df_regression_renamed['Log_Real_GDP']
                predicted_gdp = model_4.predict(df_regression_renamed)

                fig, ax = plt.subplots(figsize=(8, 6))
                sns.scatterplot(x=predicted_gdp, y=actual_gdp, alpha=0.6, ax=ax)
                ax.plot([actual_gdp.min(), actual_gdp.max()], [actual_gdp.min(), actual_gdp.max()], color='red', linestyle='--', lw=2, label='Perfect Fit')
                ax.set_title('Actual vs. Predicted Log(Real GDP) (Model 4)')
                ax.set_xlabel('Predicted Log(Real GDP)')
                ax.set_ylabel('Actual Log(Real GDP)')
                ax.legend()
                ax.grid(True)
                st.pyplot(fig)
                plt.close(fig)
             except Exception as e:
                 st.error(f"Error generating Actual vs. Predicted plot for Model 4: {e}")
        else:
             st.warning("Model 4 was not successfully built. Cannot generate actual vs. predicted values plot.")

        # Create Comparison Table
        st.header("Regression Model Comparison")
        st.markdown("Generate a table comparing the Adjusted R² and the coefficient (β) of log(GERD) across all four models.")

        results_dict = {}
        if 'model_1' in locals() and model_1:
            results_dict['Model 1'] = {
                'Adjusted R-squared': model_1.rsquared_adj,
                'Beta (Log_GERD)': model_1.params.get('Log_GERD', 'N/A')
            }
        if 'model_2' in locals() and model_2:
            results_dict['Model 2'] = {
                'Adjusted R-squared': model_2.rsquared_adj,
                'Beta (Log_GERD)': model_2.params.get('Log_GERD', 'N/A')
            }
        if 'model_3' in locals() and model_3:
            results_dict['Model 3'] = {
                'Adjusted R-squared': model_3.rsquared_adj,
                'Beta (Log_GERD)': model_3.params.get('Log_GERD', 'N/A')
            }
        if 'model_4' in locals() and model_4:
             results_dict['Model 4'] = {
                'Adjusted R-squared': model_4.rsquared_adj,
                'Beta (Log_GERD)': model_4.params.get('Log_GERD', 'N/A')
            }

        if results_dict:
            comparison_table = pd.DataFrame.from_dict(results_dict, orient='index')
            st.dataframe(comparison_table)
        else:
            st.warning("No models were successfully built to create a comparison table.")

        # Generate Visualizations
        st.header("Regression Analysis Visualizations")
        st.markdown("""
        Generate clear visualizations using Matplotlib/Seaborn:
        - Scatter plot of log(GERD) vs. log(GDP) with regression line.
        - Histogram of residuals for the final model (Model 4).
        - Bar chart comparing Adjusted R² across models.
        """)

        # Scatter plot of log(GERD) vs. log(GDP) with regression line (already generated above, but can be repeated here for clarity)
        st.subheader("Scatter Plot of Log(GERD) vs Log(Real GDP)")
        fig, ax = plt.subplots(figsize=(10, 6))
        sns.regplot(data=df_regression_renamed, x='Log_GERD', y='Log_Real_GDP', scatter_kws={'alpha': 0.6}, ax=ax)
        ax.set_title('Scatter Plot of Log(GERD) vs Log(Real GDP)')
        ax.set_xlabel('Log of Gross Domestic Expenditure on R&D (GERD)')
        ax.set_ylabel('Log of Real GDP')
        ax.grid(True)
        st.pyplot(fig)
        plt.close(fig)

        # Histogram of residuals for the final model (Model 4)
        st.subheader("Histogram of Residuals for Model 4")
        if 'model_4' in locals() and model_4 is not None:
            try:
                residuals = model_4.resid
                fig, ax = plt.subplots(figsize=(8, 6))
                sns.histplot(residuals, kde=True, ax=ax)
                ax.set_title('Histogram of Residuals for Model 4')
                ax.set_xlabel('Residuals')
                ax.set_ylabel('Frequency')
                st.pyplot(fig)
                plt.close(fig)
            except Exception as e:
                st.error(f"Error generating residuals histogram for Model 4: {e}")
        else:
            st.warning("Model 4 was not successfully built. Skipping residuals histogram.")

        # Bar chart comparing Adjusted R² across models
        st.subheader("Comparison of Adjusted R-squared Across Regression Models")
        if results_dict:
            models = list(results_dict.keys())
            adjusted_r_squared_values = [results_dict[model]['Adjusted R-squared'] for model in models]

            fig, ax = plt.subplots(figsize=(10, 6))
            sns.barplot(x=models, y=adjusted_r_squared_values, palette='viridis', ax=ax)
            ax.set_title('Comparison of Adjusted R-squared Across Regression Models')
            ax.set_xlabel('Regression Model')
            ax.set_ylabel('Adjusted R-squared')
            ax.set_ylim(0, max(adjusted_r_squared_values) * 1.1)
            st.pyplot(fig)
            plt.close(fig)
        else:
            st.warning("No model results available to create Adjusted R-squared bar chart.")

        # Summarize Findings
        st.header("Summary of Findings")
        st.markdown("""
        This analysis was conducted to examine the causal impact of Gross Domestic Expenditure on R&D (GERD) on Real GDP.
        Four regression models were sequentially estimated, gradually adding confounding, mediating, and moderating variables to identify the underlying causal structure.
        The changes in regression coefficients, statistical significance, and explanatory power (Adjusted R²) were analyzed to interpret the causal relationships.

        # Model 1: Simple Linear Regression (Log_Real_GDP ~ Log_GERD)

        Model 1 estimates the simple linear relationship between Log(GERD) and Log(Real GDP).
        The regression coefficient (β₁) is positive and statistically significant (p < 0.05), indicating that as GERD increases, Real GDP tends to increase correspondingly.
        The Adjusted R² is approximately 0.494, suggesting that Log(GERD) explains about 49.4% of the variance in Log(Real GDP).
        Thus, GERD can be considered a major explanatory factor contributing to economic growth.

        # Model 2: Adding a Confounding Variable (Log_Real_GDP ~ Log_GERD + GDP_per_Capita)

        Model 2 adds GDP per Capita as a confounding variable to the basic model.
        The variables Total Population and Labor Force Size were unavailable in the dataset and therefore excluded.

        The analysis shows that GDP per Capita is statistically insignificant (p = 0.491),
        indicating that it does not have a meaningful impact on Real GDP in this model.
        Meanwhile, the coefficient for Log(GERD) remains statistically significant(p = 0.003),
        suggesting that the positive relationship between GERD and Real GDP persists even after controlling for GDP per Capita.
        The Adjusted R² slightly decreases to 0.476, possibly due to the added confounder not substantially improving explanatory power, or as a result of penalization for increased model complexity.

        # Model 3: Adding Mediating Variables (Log_Real_GDP ~ Log_GERD + GDP per Capita + Innovation Variables)

        Model 3 includes mediating variables — Resident / Non-resident Patent Applications, R&D Researchers per Million People,
        High-tech Export Share (% of Manufactured Exports), and Business R&D Personnel (FTE) — in addition to Log(GERD) and GDP per Capita.

        The coefficient for Log(GERD) slightly decreases (β ≈ 0.380) but remains statistically significant (p = 0.020).
        This suggests that part of the relationship between GERD and Real GDP may be mediated by innovation, human capital, or technological diffusion.

        Among the mediators, Resident Patent Applications shows a near-significant result (p = 0.053), implying that domestic patent activity might partially explain how GERD affects Real GDP.
        Other mediators are not statistically significant, indicating that the mediating strength may be limited.
        3. Moderating Effects
        Government-financed BERD (%) moderates the relationship between GERD and Real GDP.
        The positive effect of GERD on GDP tends to weaken as the proportion of government-financed R&D increases.
        This finding implies that the efficiency of R&D investment may vary depending on the balance between public and private funding structures.
        4. Model Fit Comparison
        The Adjusted R² values steadily improve as the models expand (0.494 → 0.476 → 0.700 → 0.775).
        This indicates that incorporating mediating and moderating variables yields a more comprehensive and accurate explanation of Real GDP fluctuations compared to a simple model.
        # Conclusion

        The multiple regression analysis demonstrates that GERD exerts a consistently positive impact on Real GDP.
        However, this effect operates through both indirect innovation pathways (e.g., patent applications)
        and conditional moderation effects depending on the level of government-financed R&D.

        The results reveal that the relationship is not a simple “R&D → Growth” linear link,
        but rather a multi-stage causal chain — “R&D → Innovation → Productivity → Growth” —
        that is further conditioned by policy environments such as government funding ratios.

        Therefore, future R&D policies should focus not merely on expanding total expenditure,
        but also on optimizing the qualitative composition of investment —
        balancing government and private funding, strengthening human capital, and promoting innovation output efficiency.
        """)

else:
    st.warning("Data could not be loaded or is empty after cleaning.")

# This code should be saved as a Python file (e.g., app.py) and run from your terminal
# using the command: streamlit run app.py

import streamlit as st
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import statsmodels.formula.api as smf
import pandas as pd
import io

# Set the page configuration
st.set_page_config(page_title="Real GDP and R&D Research Analysis", layout="wide")

# Add a main title to the app
st.title("Analysis of Real GDP and R&D Research")

# Add a sidebar with a brief description
st.sidebar.header("About")
st.sidebar.write(
    "This application analyzes the relationship between Real GDP and R&D research, "
    "including simple linear regression, correlation analysis, and multiple linear regression models."
)

# Define the data path (replace with your actual path)
# If running in Google Colab with Google Drive mounted, this path should work.
# If running locally, adjust the path to where your data file is located.


@st.cache_data
def load_and_preprocess_data():
    """
    Loads the dataset from the local directory (same folder as the Streamlit app)
    and preprocesses it for analysis.

    Returns:
        pd.DataFrame: The preprocessed DataFrame.
    """
    try:
        # Load dataset directly from the same directory as your Streamlit app
        df = pd.read_csv("ACDT final data set22.xlsx - 데이터 (1).csv", encoding="utf-8")

        # Clean all columns except the first one ('국가별') and exclude the first two rows
        for col in df.columns[1:]:
            # Select data from the third row onwards and convert to string type
            # Use .loc for clearer indexing and to avoid SettingWithCopyWarning
            df.loc[2:, col] = df.loc[2:, col].astype(str).str.replace('[^0-9.-]', '', regex=True)
            df.loc[2:, col] = pd.to_numeric(df.loc[2:, col], errors='coerce')

        # Identify the columns for the specified variables
        variable_cols = {}

        # Define a dictionary of keywords to look for, mapping them to the desired variable names
        keywords = {
            'Resident Patent Applications': 'Resident Patent Applications',
            'Non-Resident Patent Applications': 'Non-Resident Patent Applications',
            'Number of R&D Researcher': 'Number of R&D Researcher (per million people)',
            'High-Tech Export Share': 'High-Tech Export Share (% of Manufacturing exports)',
            'Business R&D Personnel (FTE)': 'Business R&D Personnel (FTE)',
            'Real GDP': 'Real GDP',
            'Total Population': 'Total Population',
            'Labor Force': 'Labor Force Size',
            'Government-Financed BERD (%)': 'Share of Government-Financed BERD (%)',
            'Business-Financed BERD (%)': 'Share of Business-Financed BERD (%)',
            'Business R&D Personnel (FTE) per 1,000 Employed': 'Business R&D Personnel (FTE) per 1,000 Employed'
        }

        # Iterate through columns to find matches based on keywords in the first row content
        for col in df.columns:
            first_row_value = df.iloc[0][col]
            if isinstance(first_row_value, str):
                # Check for each keyword in the first row value
                for keyword, var_name in keywords.items():
                    if keyword in first_row_value:
                        # For 'Real GDP', prioritize later years
                        if var_name == 'Real GDP':
                            year = str(col).split('.')[0] if '.' in str(col) else str(col)
                            try:
                                year_int = int(year)
                                # Keep the latest identified GDP year if multiple are found
                                if var_name not in variable_cols or (isinstance(variable_cols[var_name], str) and int(variable_cols[var_name].split('.')[0] if '.' in variable_cols[var_name] else variable_cols[var_name]) < year_int):
                                    variable_cols[var_name] = col
                            except ValueError:
                                # Handle cases where the column name before the dot is not a year
                                pass
                        # For other variables, assign the first column found containing the keyword
                        elif var_name not in variable_cols:
                            variable_cols[var_name] = col


        # Create a new DataFrame with the '국가별' column and the identified variable columns
        # Ensure all identified columns are actually present in the original dataframe before selection
        selected_cols = ['국가별'] + [col for col in variable_cols.values() if col in df.columns]
        df_cleaned = df.loc[:, selected_cols].copy()

        # Remove the first two rows which contain header information
        df_cleaned = df_cleaned.iloc[2:].copy()

        # Rename columns to be more descriptive using the keys from variable_cols
        # Create a mapping from the original column names to the desired variable names
        col_rename_map = {v: k for k, v in variable_cols.items() if v in df_cleaned.columns}
        df_cleaned.rename(columns=col_rename_map, inplace=True)

        # Iterate through the variable columns (excluding '국가별') and clean the data
        for col in df_cleaned.columns:
            if col != '국가별':
                # Convert the data to string type to handle potential mixed data types
                df_cleaned[col] = df_cleaned[col].astype(str)

                # Remove non-numeric characters (keep digits, periods, and hyphens)
                df_cleaned[col] = df_cleaned[col].str.replace('[^0-9.-]', '', regex=True)

                # Convert to numeric, coercing errors to NaN
                df_cleaned[col] = pd.to_numeric(df_cleaned[col], errors='coerce')

        # Handle missing values by dropping rows with NaNs in the variable columns
        variable_column_names = [col for col in df_cleaned.columns if col != '국가별']
        df_cleaned.dropna(subset=variable_column_names, inplace=True)

        return df_cleaned

    except FileNotFoundError:
        st.error(f"Error: Data file not found")
        return pd.DataFrame() # Return an empty DataFrame on error
    except Exception as e:
        st.error(f"An error occurred during data loading and preprocessing: {e}")
        return pd.DataFrame() # Return an empty DataFrame on error



# Display the cleaned data and its info in the Streamlit app
if not df_cleaned.empty:
    st.header("Cleaned Data Preview")
    st.dataframe(df_cleaned.head())

    st.header("Data Information")
    # Redirect df.info() output to a string to display in Streamlit
    buffer = io.StringIO()
    df_cleaned.info(buf=buffer)
    s = buffer.getvalue()
    st.text(s)

    # Add section for Descriptive Statistics and Visualizations
    st.header("Descriptive Statistics and Variable Distributions")

    # Add markdown text for Descriptive Statistics
    st.markdown("""
    ## Descriptive statistics

    mean, median, standard deviation, etc. for each of the cleaned variables.
    """)

    # Select only numeric columns from the cleaned DataFrame
    df_numeric = df_cleaned.select_dtypes(include=np.number)

    if not df_numeric.empty:
        # Calculate descriptive statistics for the numeric columns
        descriptive_stats = df_numeric.describe()

        # Display the descriptive statistics using st.dataframe()
        st.dataframe(descriptive_stats)

        # Add markdown text for Distribution of Confounder, Moderater and Mediater
        st.markdown("""
        # Distribution of Confounder, Moderater and Mediater
        """)

        # Iterate through the numeric columns and create visualizations
        for col in df_numeric.columns:
            # Add a title for the current variable's visualization
            st.subheader(f"Distribution of {col}")

            # Create a figure with two subplots (histogram and box plot)
            fig, axes = plt.subplots(1, 2, figsize=(15, 5))

            # Plot Histogram
            sns.histplot(data=df_numeric, x=col, kde=True, ax=axes[0])
            axes[0].set_title(f'Distribution of {col}')
            axes[0].set_xlabel(col)
            axes[0].set_ylabel('Frequency')

            # Plot Box Plot
            sns.boxplot(data=df_numeric, x=col, ax=axes[1])
            axes[1].set_title(f'Box Plot of {col}')
            axes[1].set_xlabel(col)
            axes[1].set_ylabel('Value')

            plt.tight_layout()

            # Display the generated plot using st.pyplot()
            st.pyplot(fig)

            # Close the figure to free up memory
            plt.close(fig)
    else:
        st.warning("No numeric columns found in the cleaned data to calculate descriptive statistics or visualize distributions.")

    # Add section for Correlation Analysis
    st.header("Correlation Analysis")

    # Add markdown text for Correlation between datasets
    st.markdown("""
    # Correlation between datasets
    """)

    if not df_numeric.empty:
        # Calculate the correlation matrix
        correlation_matrix = df_numeric.corr()

        # Create a heatmap of the correlation matrix
        fig, ax = plt.subplots(figsize=(12, 10))
        sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=".5", ax=ax)
        ax.set_title('Correlation Matrix of Socio-Economic Variables')

        # Display the generated plot using st.pyplot()
        st.pyplot(fig)
        plt.close(fig)
    else:
        st.warning("No numeric data available to compute correlation matrix.")

    # Add section for Regression Models
    st.header("Multiple Linear Regression Models")

    # Add markdown text for Building Multiple Linear Regression Models
    st.markdown("""
    ## 4. Building Multiple Linear Regression Models
    Using `statsmodels.formula.api.ols`, build the four specified regression models and print their summaries.
    """)

    # Ensure df_regression_renamed DataFrame exists and is not empty
    # This part assumes df_regression_renamed is prepared with log transformations and renamed columns
    # Re-create df_regression_renamed with log transformations for this section
    df = pd.read_csv("ACDT final data set22.xlsx - 데이터 (1).csv", encoding="utf-8") # Reload df to ensure it's available

    df_regression = df.copy()
    df_regression = df_regression.iloc[2:].copy()

    regression_keywords = {
        'Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)': 'Real GDP',
        'Gross Domestic Expenditure on R&D (GERD) (current PPP USD)': 'GERD',
        'Resident Patent Applications': 'Resident Patent Applications',
        'Non-Resident Patent Applications': 'Non-Resident Patent Applications',
        'Number of R&D Researcher': 'R&D Researchers per Million People',
        'High-Tech Export Share': 'High-tech Export Share (% of Manufactured Exports)',
        'Business R&D Personnel (FTE)': 'Business R&D Personnel (FTE)',
        'GDP per Capita': 'GDP per Capita',
        'Total Population': 'Total Population',
        'Labor Force': 'Labor Force Size',
        'Government-Financed BERD (%)': 'Share of Government-Financed BERD (%)',
        'Business-Financed BERD (%)': 'Share of Business-Financed BERD (%)',
        'Business R&D Personnel (FTE) per 1,000 Employed': 'R&D Personnel per 1,000 Employees'
    }

    regression_cols = {}
    for col in df_regression.columns:
        first_row_value = df.iloc[0][col]
        if isinstance(first_row_value, str):
             for keyword, var_name in regression_keywords.items():
                if keyword in first_row_value:
                    if keyword in ['Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)', 'Gross Domestic Expenditure on R&D (GERD) (current PPP USD)']:
                        if var_name not in regression_cols:
                            regression_cols[var_name] = col
                    elif var_name not in regression_cols:
                         regression_cols[var_name] = col

    selected_regression_cols = ['국가별'] + [col for col in regression_cols.values() if col in df_regression.columns]
    df_regression = df_regression.loc[:, selected_regression_cols].copy()

    col_rename_map_regression = {v: k for k, v in regression_cols.items()}
    df_regression_renamed = df_regression.rename(columns=col_rename_map_regression)

    for col in df_regression_renamed.columns:
        if col != '국가별':
            df_regression_renamed[col] = df_regression_renamed[col].astype(str).str.replace('[^0-9.-]', '', regex=True)
            df_regression_renamed[col] = pd.to_numeric(df_regression_renamed[col], errors='coerce')

    df_regression_renamed.dropna(subset=[col for col in df_regression_renamed.columns if col != '국가별'], inplace=True)

    if 'Real GDP' in df_regression_renamed.columns:
        df_regression_renamed['Log_Real_GDP'] = np.log(df_regression_renamed['Real GDP'] + 1e-9)
    else:
        st.warning("Warning: 'Real GDP' column not found for log transformation.")

    if 'GERD' in df_regression_renamed.columns:
        df_regression_renamed['Log_GERD'] = np.log(df_regression_renamed['GERD'] + 1e-9)
    else:
         st.warning("Warning: 'GERD' column not found for log transformation.")


    if not df_regression_renamed.empty and 'Log_Real_GDP' in df_regression_renamed.columns and 'Log_GERD' in df_regression_renamed.columns:

        # Model 1: log_GDP ~ log_GERD (simple regression)
        st.subheader("Model 1: Simple Regression")
        try:
            model_1_formula = 'Log_Real_GDP ~ Log_GERD'
            model_1 = smf.ols(model_1_formula, data=df_regression_renamed).fit()
            st.text(model_1.summary().as_text())
            st.markdown("Interpretation: Model 1 estimates the simple linear relationship between Log(GERD) and Log(Real GDP). The regression coefficient (β₁) is positive and statistically significant (p < 0.05), indicating that as GERD increases, Real GDP tends to increase correspondingly. The Adjusted R² is approximately 0.494, suggesting that Log(GERD) explains about 49.4% of the variance in Log(Real GDP). Thus, GERD can be considered a major explanatory factor contributing to economic growth.")
        except Exception as e:
            st.error(f"Error building Model 1: {e}")
            model_1 = None
        st.markdown("---")

        # Model 2: log_GDP ~ log_GERD + GDP_per_Capita + Population_Labor_Size (confounders)
        st.subheader("Model 2: Adding Confounders")
        try:
            confounder_vars = ['GDP per Capita'] # Use the original column name based on previous identification
            confounder_vars_formula = ' + '.join([var for var in confounder_vars if var in df_regression_renamed.columns])

            if confounder_vars_formula:
                model_2_formula = f'Log_Real_GDP ~ Log_GERD + {confounder_vars_formula}'
                model_2 = smf.ols(model_2_formula, data=df_regression_renamed).fit()
                st.text(model_2.summary().as_text())
                st.markdown("Interpretation: Model 2 adds GDP per Capita as a confounding variable to the basic model. The variables Total Population and Labor Force Size were unavailable in the dataset and therefore excluded. The analysis shows that GDP per Capita is statistically insignificant (p = 0.491), indicating that it does not have a meaningful impact on Real GDP in this model. Meanwhile, the coefficient for Log(GERD) remains statistically significant (p = 0.003), suggesting that the positive relationship between GERD and Real GDP persists even after controlling for GDP per Capita. The Adjusted R² slightly decreases to 0.476, possibly due to the added confounder not substantially improving explanatory power, or as a result of penalization for increased model complexity.")
            else:
                st.warning("Confounder variables not found in the dataset. Skipping Model 2.")
                model_2 = None
        except Exception as e:
            st.error(f"Error building Model 2: {e}")
            model_2 = None
        st.markdown("---")

        # Model 3: log_GDP ~ log_GERD + Patents + R&D_Researchers + Hightech_Exports + Business_R&D_Personnel (mediators)
        st.subheader("Model 3: Adding Mediators")
        try:
            mediator_vars = [
                'Resident Patent Applications', # Use original column name
                'Non-Resident Patent Applications', # Use original column name
                'Business R&D Personnel (FTE)' # Use original column name
            ]
            mediator_vars_formula = ' + '.join([var for var in mediator_vars if var in df_regression_renamed.columns])

            all_vars_formula_model3 = 'Log_GERD'
            if confounder_vars_formula:
                 all_vars_formula_model3 += ' + ' + confounder_vars_formula
            if mediator_vars_formula:
                 all_vars_formula_model3 += ' + ' + mediator_vars_formula


            if 'Log_GERD' in df_regression_renamed.columns and (confounder_vars_formula or mediator_vars_formula):
                model_3_formula = f'Log_Real_GDP ~ {all_vars_formula_model3}'
                model_3 = smf.ols(model_3_formula, data=df_regression_renamed).fit()
                st.text(model_3.summary().as_text())
                st.markdown("Interpretation: Model 3 includes mediating variables — Resident / Non-resident Patent Applications, R&D Researchers per Million People, High-tech Export Share (% of Manufactured Exports), and Business R&D Personnel (FTE) — in addition to Log(GERD) and GDP per Capita. The coefficient for Log(GERD) slightly decreases (β ≈ 0.380) but remains statistically significant (p = 0.020). This suggests that part of the relationship between GERD and Real GDP may be mediated by innovation, human capital, or technological diffusion. Among the mediators, Resident Patent Applications shows a near-significant result (p = 0.053), implying that domestic patent activity might partially explain how GERD affects Real GDP. Other mediators are not statistically significant. The Adjusted R² increases substantially to approximately 0.700, indicating that including mediating variables substantially improves the model’s explanatory power.")
            else:
                 st.warning("Mediator variables not found in the dataset or necessary confounders missing. Skipping Model 3.")
                 model_3 = None
        except Exception as e:
            st.error(f"Error building Model 3: {e}")
            model_3 = None
        st.markdown("---")


        # Model 4: log_GDP ~ log_GERD * GovFinanced_BERD + GDP_per_Capita + Population_Labor_Size (moderator interaction)
        st.subheader("Model 4: Adding Moderator Interaction")
        try:
            moderator_var = 'Government-financed BERD (%)' # Use original column name

            if moderator_var in df_regression_renamed.columns and confounder_vars_formula:
                 model_4_formula = f'Log_Real_GDP ~ Log_GERD * Q("{moderator_var}") + {confounder_vars_formula}' # Enclose in backticks for formula
                 model_4 = smf.ols(model_4_formula, data=df_regression_renamed).fit()
                 st.text(model_4.summary().as_text())
                 st.markdown("Interpretation: Model 4 adds an interaction term between Log(GERD) and Government-financed BERD (%) to test for a moderating effect. The interaction term (Log_GERD × GovFinanced_BERD_pct) is highly significant (p = 0.001), suggesting that the effect of GERD on Real GDP varies depending on the proportion of government-financed R&D expenditure. The coefficient for the interaction term (β = -0.0895) is negative, implying that as the share of government financing in R&D increases, the positive impact of GERD on Real GDP tends to weaken. The coefficient for Log(GERD) itself increases (β ≈ 1.070) compared to Model 3 and remains highly significant (p < 0.001). This represents the effect of GERD on Real GDP when the moderator (Government-financed BERD) equals zero. Given the significant interaction, the effect size of GERD should be interpreted conditionally on the level of government financing. The Adjusted R² further increases to approximately 0.775, showing that Model 4 provides the best overall explanatory power.")
            else:
                st.warning("Moderator variable or confounders not found. Skipping Model 4.")
                model_4 = None
        except Exception as e:
            st.error(f"Error building Model 4: {e}")
            model_4 = None
        st.markdown("---")

        # Generate Actual vs. Predicted Plot for Model 4
        st.header("Actual vs. Predicted Values Plot for Model 4")
        st.markdown("Generate a scatter plot of the actual values of the dependent variable (Log_Real_GDP) against the values predicted by Model 4, with a line of perfect fit.")

        if 'model_4' in locals() and model_4 is not None:
             try:
                actual_gdp = df_regression_renamed['Log_Real_GDP']
                predicted_gdp = model_4.predict(df_regression_renamed)

                fig, ax = plt.subplots(figsize=(8, 6))
                sns.scatterplot(x=predicted_gdp, y=actual_gdp, alpha=0.6, ax=ax)
                ax.plot([actual_gdp.min(), actual_gdp.max()], [actual_gdp.min(), actual_gdp.max()], color='red', linestyle='--', lw=2, label='Perfect Fit')
                ax.set_title('Actual vs. Predicted Log(Real GDP) (Model 4)')
                ax.set_xlabel('Predicted Log(Real GDP)')
                ax.set_ylabel('Actual Log(Real GDP)')
                ax.legend()
                ax.grid(True)
                st.pyplot(fig)
                plt.close(fig)
             except Exception as e:
                 st.error(f"Error generating Actual vs. Predicted plot for Model 4: {e}")
        else:
             st.warning("Model 4 was not successfully built. Cannot generate actual vs. predicted values plot.")

        # Create Comparison Table
        st.header("Regression Model Comparison")
        st.markdown("Generate a table comparing the Adjusted R² and the coefficient (β) of log(GERD) across all four models.")

        results_dict = {}
        if 'model_1' in locals() and model_1:
            results_dict['Model 1'] = {
                'Adjusted R-squared': model_1.rsquared_adj,
                'Beta (Log_GERD)': model_1.params.get('Log_GERD', 'N/A')
            }
        if 'model_2' in locals() and model_2:
            results_dict['Model 2'] = {
                'Adjusted R-squared': model_2.rsquared_adj,
                'Beta (Log_GERD)': model_2.params.get('Log_GERD', 'N/A')
            }
        if 'model_3' in locals() and model_3:
            results_dict['Model 3'] = {
                'Adjusted R-squared': model_3.rsquared_adj,
                'Beta (Log_GERD)': model_3.params.get('Log_GERD', 'N/A')
            }
        if 'model_4' in locals() and model_4:
             results_dict['Model 4'] = {
                'Adjusted R-squared': model_4.rsquared_adj,
                'Beta (Log_GERD)': model_4.params.get('Log_GERD', 'N/A')
            }

        if results_dict:
            comparison_table = pd.DataFrame.from_dict(results_dict, orient='index')
            st.dataframe(comparison_table)
        else:
            st.warning("No models were successfully built to create a comparison table.")

        # Generate Visualizations
        st.header("Regression Analysis Visualizations")
        st.markdown("""
        Generate clear visualizations using Matplotlib/Seaborn:
        - Scatter plot of log(GERD) vs. log(GDP) with regression line.
        - Histogram of residuals for the final model (Model 4).
        - Bar chart comparing Adjusted R² across models.
        """)

        # Scatter plot of log(GERD) vs. log(GDP) with regression line (already generated above, but can be repeated here for clarity)
        st.subheader("Scatter Plot of Log(GERD) vs Log(Real GDP)")
        fig, ax = plt.subplots(figsize=(10, 6))
        sns.regplot(data=df_regression_renamed, x='Log_GERD', y='Log_Real_GDP', scatter_kws={'alpha': 0.6}, ax=ax)
        ax.set_title('Scatter Plot of Log(GERD) vs Log(Real GDP)')
        ax.set_xlabel('Log of Gross Domestic Expenditure on R&D (GERD)')
        ax.set_ylabel('Log of Real GDP')
        ax.grid(True)
        st.pyplot(fig)
        plt.close(fig)

        # Histogram of residuals for the final model (Model 4)
        st.subheader("Histogram of Residuals for Model 4")
        if 'model_4' in locals() and model_4 is not None:
            try:
                residuals = model_4.resid
                fig, ax = plt.subplots(figsize=(8, 6))
                sns.histplot(residuals, kde=True, ax=ax)
                ax.set_title('Histogram of Residuals for Model 4')
                ax.set_xlabel('Residuals')
                ax.set_ylabel('Frequency')
                st.pyplot(fig)
                plt.close(fig)
            except Exception as e:
                st.error(f"Error generating residuals histogram for Model 4: {e}")
        else:
            st.warning("Model 4 was not successfully built. Skipping residuals histogram.")

        # Bar chart comparing Adjusted R² across models
        st.subheader("Comparison of Adjusted R-squared Across Regression Models")
        if results_dict:
            models = list(results_dict.keys())
            adjusted_r_squared_values = [results_dict[model]['Adjusted R-squared'] for model in models]

            fig, ax = plt.subplots(figsize=(10, 6))
            sns.barplot(x=models, y=adjusted_r_squared_values, palette='viridis', ax=ax)
            ax.set_title('Comparison of Adjusted R-squared Across Regression Models')
            ax.set_xlabel('Regression Model')
            ax.set_ylabel('Adjusted R-squared')
            ax.set_ylim(0, max(adjusted_r_squared_values) * 1.1)
            st.pyplot(fig)
            plt.close(fig)
        else:
            st.warning("No model results available to create Adjusted R-squared bar chart.")

        # Summarize Findings
        st.header("Summary of Findings")
        st.markdown("""
        This analysis was conducted to examine the causal impact of Gross Domestic Expenditure on R&D (GERD) on Real GDP.
        Four regression models were sequentially estimated, gradually adding confounding, mediating, and moderating variables to identify the underlying causal structure.
        The changes in regression coefficients, statistical significance, and explanatory power (Adjusted R²) were analyzed to interpret the causal relationships.

        # Model 1: Simple Linear Regression (Log_Real_GDP ~ Log_GERD)

        Model 1 estimates the simple linear relationship between Log(GERD) and Log(Real GDP).
        The regression coefficient (β₁) is positive and statistically significant (p < 0.05), indicating that as GERD increases, Real GDP tends to increase correspondingly.
        The Adjusted R² is approximately 0.494, suggesting that Log(GERD) explains about 49.4% of the variance in Log(Real GDP).
        Thus, GERD can be considered a major explanatory factor contributing to economic growth.

        # Model 2: Adding a Confounding Variable (Log_Real_GDP ~ Log_GERD + GDP_per_Capita)

        Model 2 adds GDP per Capita as a confounding variable to the basic model.
        The variables Total Population and Labor Force Size were unavailable in the dataset and therefore excluded.

        The analysis shows that GDP per Capita is statistically insignificant (p = 0.491),
        indicating that it does not have a meaningful impact on Real GDP in this model.
        Meanwhile, the coefficient for Log(GERD) remains statistically significant(p = 0.003),
        suggesting that the positive relationship between GERD and Real GDP persists even after controlling for GDP per Capita.
        The Adjusted R² slightly decreases to 0.476, possibly due to the added confounder not substantially improving explanatory power, or as a result of penalization for increased model complexity.

        # Model 3: Adding Mediating Variables (Log_Real_GDP ~ Log_GERD + GDP per Capita + Innovation Variables)

        Model 3 includes mediating variables — Resident / Non-resident Patent Applications, R&D Researchers per Million People,
        High-tech Export Share (% of Manufactured Exports), and Business R&D Personnel (FTE) — in addition to Log(GERD) and GDP per Capita.

        The coefficient for Log(GERD) slightly decreases (β ≈ 0.380) but remains statistically significant (p = 0.020).
        This suggests that part of the relationship between GERD and Real GDP may be mediated by innovation, human capital, or technological diffusion.

        Among the mediators, Resident Patent Applications shows a near-significant result (p = 0.053), implying that domestic patent activity might partially explain how GERD affects Real GDP.
        Other mediators are not statistically significant.
        The Adjusted R² increases substantially to approximately 0.700, indicating that including mediating variables substantially improves the model’s explanatory power.

        # Model 4: Adding a Moderating Effect (Log_Real_GDP ~ Log_Real_GDP ~ Log_GERD * GovFinanced_BERD_pct + Mediators + Confounder)

        Model 4 adds an interaction term between Log(GERD) and Government-financed BERD (%) to test for a moderating effect.

        The interaction term (Log_GERD × GovFinanced_BERD_pct) is highly significant (p = 0.001),
        suggesting that the effect of GERD on Real GDP varies depending on the proportion of government-financed R&D expenditure.
        The coefficient for the interaction term (β = -0.0895) is negative, implying that as the share of government financing in R&D increases,
        the positive impact of GERD on Real GDP tends to weaken.

        The coefficient for Log(GERD) itself increases (β ≈ 1.070) compared to Model 3 and remains highly significant (p < 0.001).
        This represents the effect of GERD on Real GDP when the moderator (Government-financed BERD) equals zero.
        Given the significant interaction, the effect size of GERD should be interpreted conditionally on the level of government financing.
        The Adjusted R² further increases to approximately 0.775, showing that Model 4 provides the best overall explanatory power.

        # Key Findings and Implications

        1. Relationship between GERD and Real GDP
        Across all models, Log(GERD) consistently shows a statistically significant and positive relationship with Real GDP.
        This provides empirical support for the notion that R&D investment is a key driver of economic growth.
        2. Mediating Effects
        Resident Patent Applications partially mediate the relationship between GERD and Real GDP,
        suggesting that R&D expenditure contributes to economic growth indirectly through innovation activities.
        Other mediators are not statistically significant, indicating that the mediating strength may be limited.
        3. Moderating Effects
        Government-financed BERD (%) moderates the relationship between GERD and Real GDP.
        The positive effect of GERD on GDP tends to weaken as the proportion of government-financed R&D increases.
        This finding implies that the efficiency of R&D investment may vary depending on the balance between public and private funding structures.
        4. Model Fit Comparison
        The Adjusted R² values steadily improve as the models expand (0.494 → 0.476 → 0.700 → 0.775).
        This indicates that incorporating mediating and moderating variables yields a more comprehensive and accurate explanation of Real GDP fluctuations compared to a simple model.
        # Conclusion

        The multiple regression analysis demonstrates that GERD exerts a consistently positive impact on Real GDP.
        However, this effect operates through both indirect innovation pathways (e.g., patent applications)
        and conditional moderation effects depending on the level of government-financed R&D.

        The results reveal that the relationship is not a simple “R&D → Growth” linear link,
        but rather a multi-stage causal chain — “R&D → Innovation → Productivity → Growth” —
        that is further conditioned by policy environments such as government funding ratios.

        Therefore, future R&D policies should focus not merely on expanding total expenditure,
        but also on optimizing the qualitative composition of investment —
        balancing government and private funding, strengthening human capital, and promoting innovation output efficiency.
        """)

else:
    st.warning("Data could not be loaded or is empty after cleaning.")

import streamlit as st
import statsmodels.formula.api as smf
import pandas as pd
import numpy as np

# Add a section title for regression analysis
st.header("Multiple Linear Regression Models")

# Ensure df_regression_renamed DataFrame exists and is not empty
# Assuming df_regression_renamed was created and populated in a previous step
if 'df_regression_renamed' in locals() and df_regression_renamed is not None and not df_regression_renamed.empty:

    # Model 1: log_GDP ~ log_GERD (simple regression)
    st.subheader("Model 1: Simple Regression")
    try:
        model_1_formula = 'Log_Real_GDP ~ Log_GERD'
        model_1 = smf.ols(model_1_formula, data=df_regression_renamed).fit()
        st.text(model_1.summary().as_text())
        st.markdown("Interpretation: Model 1 shows the direct relationship between log(GERD) and log(Real GDP).")
    except Exception as e:
        st.error(f"Error building Model 1: {e}")
        model_1 = None
    st.markdown("---") # Add a separator

    # Model 2: log_GDP ~ log_GERD + GDP_per_Capita + Population_Labor_Size (confounders)
    st.subheader("Model 2: Adding Confounders")
    try:
        # Check if confounder variables were successfully renamed and exist
        # Based on previous output, 'GDP_per_Capita' was found, 'Total Population' and 'Labor Force Size' were not.
        confounder_vars = ['GDP_per_Capita'] # Use the renamed column name
        confounder_vars_formula = ' + '.join([var for var in confounder_vars if var in df_regression_renamed.columns])

        if confounder_vars_formula:
            model_2_formula = f'Log_Real_GDP ~ Log_GERD + {confounder_vars_formula}'
            model_2 = smf.ols(model_2_formula, data=df_regression_renamed).fit()
            st.text(model_2.summary().as_text())
            st.markdown("Interpretation: Model 2 includes confounders to see their effect and the effect of log(GERD) after accounting for them.")
        else:
            st.warning("Confounder variables not found in the dataset. Skipping Model 2.")
            model_2 = None
    except Exception as e:
        st.error(f"Error building Model 2: {e}")
        model_2 = None
    st.markdown("---") # Add a separator

    # Model 3: log_GDP ~ log_GERD + Patents + R&D_Researchers + Hightech_Exports + Business_R&D_Personnel (mediators)
    st.subheader("Model 3: Adding Mediators")
    try:
        # Check if mediator variables were successfully renamed and exist
        # Based on previous output, these columns were renamed:
        # 'Resident Patent Applications' -> 'Resident_Patent_Applications'
        # 'Non-Resident Patent Applications' -> 'Non_Resident_Patent_Applications'
        # 'R&D Researchers per Million People' -> 'R_and_D_Researchers_per_Million_People' (was not found in previous step, exclude)
        # 'High-tech Export Share (% of Manufacturing exports)' -> 'Hightech_Export_Share' (was not found in previous step, exclude)
        # 'Business R&D Personnel (FTE)' -> 'Business_R_and_D_Personnel_FTE'

        mediator_vars = [
            'Resident_Patent_Applications',
            'Non_Resident_Patent_Applications',
            'Business_R_and_D_Personnel_FTE' # Use the renamed column name
            # Exclude 'R_and_D_Researchers_per_Million_People' and 'Hightech_Export_Share' as they were not definitively found
        ]
        mediator_vars_formula = ' + '.join([var for var in mediator_vars if var in df_regression_renamed.columns])

        # Also include confounders if they were found for Model 2
        all_vars_formula_model3 = 'Log_GERD'
        if confounder_vars_formula:
             all_vars_formula_model3 += ' + ' + confounder_vars_formula
        if mediator_vars_formula:
             all_vars_formula_model3 += ' + ' + mediator_vars_formula


        if 'Log_GERD' in df_regression_renamed.columns and (confounder_vars_formula or mediator_vars_formula):
            model_3_formula = f'Log_Real_GDP ~ {all_vars_formula_model3}'
            model_3 = smf.ols(model_3_formula, data=df_regression_renamed).fit()
            st.text(model_3.summary().as_text())
            st.markdown("Interpretation: Model 3 adds potential mediators to examine their influence and the change in the effect of log(GERD).")
        else:
             st.warning("Mediator variables not found in the dataset or necessary confounders missing. Skipping Model 3.")
             model_3 = None
    except Exception as e:
        st.error(f"Error building Model 3: {e}")
        model_3 = None
    st.markdown("---") # Add a separator


    # Model 4: log_GDP ~ log_GERD * GovFinanced_BERD + GDP_per_Capita + Population_Labor_Size (moderator interaction)
    st.subheader("Model 4: Adding Moderator Interaction")
    try:
        # Check if moderator and other necessary variables exist after renaming
        # Based on previous output:
        # 'Government-financed BERD (%)' -> 'GovFinanced_BERD_pct'
        moderator_var = 'GovFinanced_BERD_pct' # Use the renamed column name

        if moderator_var in df_regression_renamed.columns and confounder_vars_formula:
             # Construct the formula with interaction term using '*'
             model_4_formula = f'Log_Real_GDP ~ Log_GERD * {moderator_var} + {confounder_vars_formula}'
             model_4 = smf.ols(model_4_formula, data=df_regression_renamed).fit()
             st.text(model_4.summary().as_text())
             st.markdown(f"Interpretation: Model 4 includes an interaction term between log(GERD) and {moderator_var} to test for moderation.")
        else:
            st.warning("Moderator variable or confounders not found. Skipping Model 4.")
            model_4 = None
    except Exception as e:
        st.error(f"Error building Model 4: {e}")
        model_4 = None
    st.markdown("---") # Add a separator

else:
    st.warning("Cleaned and renamed DataFrame 'df_regression_renamed' not found or is empty. Cannot build regression models.")

import streamlit as st
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# Add a section title for descriptive statistics
st.header("Descriptive Statistics")

# Check if df_cleaned is not empty and contains numeric columns
if not df_cleaned.empty:
    # Select only numeric columns from the cleaned DataFrame
    df_numeric = df_cleaned.select_dtypes(include=np.number)

    if not df_numeric.empty:
        # Calculate descriptive statistics for the numeric columns
        descriptive_stats = df_numeric.describe()

        # Display the descriptive statistics using st.dataframe()
        st.dataframe(descriptive_stats)

        # Add a section title for variable distribution visualization
        st.header("Distribution of Variables")

        # Iterate through the numeric columns and create visualizations
        for col in df_numeric.columns:
            # Add a title for the current variable's visualization
            st.subheader(f"Distribution of {col}")

            # Create a figure with two subplots (histogram and box plot)
            fig, axes = plt.subplots(1, 2, figsize=(15, 5))

            # Plot Histogram
            sns.histplot(data=df_numeric, x=col, kde=True, ax=axes[0])
            axes[0].set_title(f'Distribution of {col}')
            axes[0].set_xlabel(col)
            axes[0].set_ylabel('Frequency')

            # Plot Box Plot
            sns.boxplot(data=df_numeric, x=col, ax=axes[1])
            axes[1].set_title(f'Box Plot of {col}')
            axes[1].set_xlabel(col)
            axes[1].set_ylabel('Value')

            plt.tight_layout()

            # Display the generated plot using st.pyplot()
            st.pyplot(fig)

            # Close the figure to free up memory
            plt.close(fig)
    else:
        st.warning("No numeric columns found in the cleaned data to calculate descriptive statistics or visualize distributions.")
else:
    st.warning("Cleaned data is empty. Cannot perform descriptive statistics or visualize distributions.")

import streamlit as st
import pandas as pd
import numpy as np

@st.cache_data
def load_and_preprocess_data():
    """
    Loads the dataset from the local directory (same folder as the Streamlit app)
    and preprocesses it for analysis.

    Returns:
        pd.DataFrame: The preprocessed DataFrame.
    """
    try:
        # Load dataset directly from the same directory as your Streamlit app
        df = pd.read_csv("ACDT final data set22.xlsx - 데이터 (1).csv", encoding="utf-8")

        # Clean all columns except the first one ('국가별') and exclude the first two rows
        for col in df.columns[1:]:
            # Select data from the third row onwards and convert to string type
            # Use .loc for clearer indexing and to avoid SettingWithCopyWarning
            df.loc[2:, col] = df.loc[2:, col].astype(str).str.replace('[^0-9.-]', '', regex=True)
            df.loc[2:, col] = pd.to_numeric(df.loc[2:, col], errors='coerce')

        # Identify the columns for the specified variables
        variable_cols = {}

        # Define a dictionary of keywords to look for, mapping them to the desired variable names
        keywords = {
            'Resident Patent Applications': 'Resident Patent Applications',
            'Non-Resident Patent Applications': 'Non-Resident Patent Applications',
            'Number of R&D Researcher': 'Number of R&D Researcher (per million people)',
            'High-Tech Export Share': 'High-Tech Export Share (% of Manufacturing exports)',
            'Business R&D Personnel (FTE)': 'Business R&D Personnel (FTE)',
            'Real GDP': 'Real GDP',
            'Total Population': 'Total Population',
            'Labor Force': 'Labor Force Size',
            'Government-Financed BERD (%)': 'Share of Government-Financed BERD (%)',
            'Business-Financed BERD (%)': 'Share of Business-Financed BERD (%)',
            'Business R&D Personnel (FTE) per 1,000 Employed': 'Business R&D Personnel (FTE) per 1,000 Employed'
        }

        # Iterate through columns to find matches based on keywords in the first row content
        for col in df.columns:
            first_row_value = df.iloc[0][col]
            if isinstance(first_row_value, str):
                # Check for each keyword in the first row value
                for keyword, var_name in keywords.items():
                    if keyword in first_row_value:
                        # For 'Real GDP', prioritize later years
                        if var_name == 'Real GDP':
                            year = str(col).split('.')[0] if '.' in str(col) else str(col)
                            try:
                                year_int = int(year)
                                # Keep the latest identified GDP year if multiple are found
                                if var_name not in variable_cols or (isinstance(variable_cols[var_name], str) and int(variable_cols[var_name].split('.')[0] if '.' in variable_cols[var_name] else variable_cols[var_name]) < year_int):
                                    variable_cols[var_name] = col
                            except ValueError:
                                # Handle cases where the column name before the dot is not a year
                                pass
                        # For other variables, assign the first column found containing the keyword
                        elif var_name not in variable_cols:
                            variable_cols[var_name] = col


        # Create a new DataFrame with the '국가별' column and the identified variable columns
        # Ensure all identified columns are actually present in the original dataframe before selection
        selected_cols = ['국가별'] + [col for col in variable_cols.values() if col in df.columns]
        df_cleaned = df.loc[:, selected_cols].copy()

        # Remove the first two rows which contain header information
        df_cleaned = df_cleaned.iloc[2:].copy()

        # Rename columns to be more descriptive using the keys from variable_cols
        # Create a mapping from the original column names to the desired variable names
        col_rename_map = {v: k for k, v in variable_cols.items() if v in df_cleaned.columns}
        df_cleaned.rename(columns=col_rename_map, inplace=True)

        # Iterate through the variable columns (excluding '국가별') and clean the data
        for col in df_cleaned.columns:
            if col != '국가별':
                # Convert the data to string type to handle potential mixed data types
                df_cleaned[col] = df_cleaned[col].astype(str)

                # Remove non-numeric characters (keep digits, periods, and hyphens)
                df_cleaned[col] = df_cleaned[col].str.replace('[^0-9.-]', '', regex=True)

                # Convert to numeric, coercing errors to NaN
                df_cleaned[col] = pd.to_numeric(df_cleaned[col], errors='coerce')

        # Handle missing values by dropping rows with NaNs in the variable columns
        variable_column_names = [col for col in df_cleaned.columns if col != '국가별']
        df_cleaned.dropna(subset=variable_column_names, inplace=True)

        return df_cleaned

    except FileNotFoundError:
        st.error(f"Error: Data file not found")
        return pd.DataFrame() # Return an empty DataFrame on error
    except Exception as e:
        st.error(f"An error occurred during data loading and preprocessing: {e}")
        return pd.DataFrame() # Return an empty DataFrame on error



# Display the cleaned data and its info in the Streamlit app
if not df_cleaned.empty:
    st.header("Cleaned Data Preview")
    st.dataframe(df_cleaned.head())

    st.header("Data Information")
    # Redirect df.info() output to a string to display in Streamlit
    import io
    buffer = io.StringIO()
    df_cleaned.info(buf=buffer)
    s = buffer.getvalue()
    st.text(s)
else:
    st.warning("Data could not be loaded or is empty after cleaning.")

"""# 1. Simple Linear Regression and Scatter Plot"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
df = pd.read_csv("ACDT final data set22.xlsx - 데이터 (1).csv", encoding="utf-8")
df.head()

import pandas as pd
import numpy as np
import kagglehub
import os
from scipy import stats
import matplotlib.pyplot as plt
import seaborn as sns
from IPython.display import display, Markdown

print("Libraries imported successfully")

# Clean all columns except the first one ('국가별') and exclude the first two rows
for col in df.columns[1:]:
    # Select data from the third row onwards and convert to string type
    # Use .loc for clearer indexing and to avoid SettingWithCopyWarning
    df.loc[2:, col] = df.loc[2:, col].astype(str).str.replace('[^0-9.-]', '', regex=True)
    df.loc[2:, col] = pd.to_numeric(df.loc[2:, col], errors='coerce')


# Identify the columns for Real GDP and Gross Domestic Expenditure on R&D (GERD) for each year
gdp_cols = {}
gerd_cols = {}

for col in df.columns:
    # Ensure the first row value is treated as a string before checking for substrings
    if isinstance(df.iloc[0][col], str):
        if 'Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)' in df.iloc[0][col]:
            # Ensure the column name is a string before splitting
            year = str(col).split('.')[0] if '.' in str(col) else str(col)
            gdp_cols[year] = col
        if 'Gross Domestic Expenditure on R&D (GERD) (current PPP USD)' in df.iloc[0][col]:
            # Ensure the column name is a string before splitting
            year = str(col).split('.')[0] if '.' in str(str(col)) else str(col)
            gerd_cols[year] = col
    # If the first row value is not a string, skip this column for identification
    else:
        continue

# Define the desired year pairings (GERD year, GDP year)
year_pairings = [
    ('2020', '2022'),
    ('2020', '2023'),
    ('2020', '2024'),
]

# Create scatter plots and perform linear regression for the specified year pairings
for gerd_year, gdp_year in year_pairings:
    gerd_col = gerd_cols.get(gerd_year)
    gdp_col = gdp_cols.get(gdp_year)

    if gerd_col and gdp_col:
        # Select the relevant columns and data from the third row onwards
        df_year = df.loc[2:, ['국가별', gdp_col, gerd_col]].copy()
        df_year.columns = ['Country', 'Real_GDP', 'GERD']

        # Drop rows with NaN values in the selected columns
        df_year_cleaned = df_year.dropna(subset=['Real_GDP', 'GERD']).copy()

        # Explicitly convert to numeric after dropping NaNs
        df_year_cleaned['Real_GDP'] = pd.to_numeric(df_year_cleaned['Real_GDP'], errors='coerce')
        df_year_cleaned['GERD'] = pd.to_numeric(df_year_cleaned['GERD'], errors='coerce')

        # Drop rows that might have become NaN after the explicit conversion
        df_year_cleaned.dropna(subset=['Real_GDP', 'GERD'], inplace=True)


        if not df_year_cleaned.empty:
            # Calculate the log of Real GDP and GERD, adding a small constant to avoid log(0)
            df_year_cleaned['Log_Real_GDP'] = np.log(df_year_cleaned['Real_GDP'] + 1e-9)
            df_year_cleaned['Log_GERD'] = np.log(df_year_cleaned['GERD'] + 1e-9)

            # Perform linear regression
            x = df_year_cleaned['Log_GERD']
            y = df_year_cleaned['Log_Real_GDP']
            slope, intercept, r_value, p_value, std_err = stats.linregress(x, y)

            # Print the results of the linear regression for the current year pairing
            print(f"Linear Regression Results for GERD year {gerd_year} and GDP year {gdp_year}:")
            print(f"Slope: {slope:.4f}")
            print(f"Intercept: {intercept:.4f}")
            print(f"R-value (Correlation Coefficient): {r_value:.4f}")
            print(f"P-value: {p_value:.4f}") # Added p-value here
            print(f"Standard Error: {std_err:.4f}")
            print("-" * 30) # Separator for different year pairings


            # Create the scatter plot for the current year pairing with regression line
            plt.figure(figsize=(10, 6))
            sns.scatterplot(data=df_year_cleaned, x='Log_GERD', y='Log_Real_GDP', alpha=0.7, label='Actual Data')

            # Plot the regression line
            plt.plot(x, slope * x + intercept, color='red', linewidth=2, label='Regression Line')

            plt.title(f'Log of Gross Domestic Expenditure on R&D (GERD) ({gerd_year}) vs Log of Real GDP ({gdp_year}) with Regression Line')
            plt.xlabel(f'Log of Gross Domestic Expenditure on R&D (GERD) (current PPP USD) ({gerd_year})')
            plt.ylabel(f'Log of Real GDP (billion USD) ({gdp_year})')
            plt.legend()
            plt.grid(True)
            plt.show()
        else:
            print(f"No valid data to plot or perform regression for GERD year {gerd_year} and GDP year {gdp_year}")
    else:
        print(f"Could not find both Real GDP column for year {gdp_year} and GERD column for year {gerd_year}")

# Identify the columns for Real GDP and Gross Domestic Expenditure on R&D (GERD) for each year
gdp_cols = {}
gerd_cols = {}

# Assuming 'df' is the dataframe loaded and cleaned in a previous cell
for col in df.columns:
    # Ensure the first row value is treated as a string before checking for substrings
    if isinstance(df.iloc[0][col], str):
        if 'Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)' in df.iloc[0][col]:
            # Ensure the column name is a string before splitting
            year = str(col).split('.')[0] if '.' in str(col) else str(col)
            gdp_cols[year] = col
        if 'Gross Domestic Expenditure on R&D (GERD) (current PPP USD)' in df.iloc[0][col]:
            # Ensure the column name is a string before splitting
            year = str(col).split('.')[0] if '.' in str(str(col)) else str(col)
            gerd_cols[year] = col
    # If the first row value is not a string, skip this column for identification
    else:
        continue

# Define the desired year pairings (GERD year, GDP year)
year_pairings = [
    ('2020', '2022'),
    ('2020', '2023'),
    ('2020', '2024'),
]

# Create scatter plots for the specified year pairings without regression lines
for gerd_year, gdp_year in year_pairings:
    gerd_col = gerd_cols.get(gerd_year)
    gdp_col = gdp_cols.get(gdp_year)

    if gerd_col and gdp_col:
        # Select the relevant columns and data from the third row onwards
        df_year = df.loc[2:, ['국가별', gdp_col, gerd_col]].copy()
        df_year.columns = ['Country', 'Real_GDP', 'GERD']

        # Drop rows with NaN values in the selected columns
        df_year_cleaned = df_year.dropna(subset=['Real_GDP', 'GERD']).copy()

        # Explicitly convert to numeric after dropping NaNs
        df_year_cleaned['Real_GDP'] = pd.to_numeric(df_year_cleaned['Real_GDP'], errors='coerce')
        df_year_cleaned['GERD'] = pd.to_numeric(df_year_cleaned['GERD'], errors='coerce')

        # Drop rows that might have become NaN after the explicit conversion
        df_year_cleaned.dropna(subset=['Real_GDP', 'GERD'], inplace=True)


        if not df_year_cleaned.empty:
            # Calculate the log of Real GDP and GERD, adding a small constant to avoid log(0)
            df_year_cleaned['Log_Real_GDP'] = np.log(df_year_cleaned['Real_GDP'] + 1e-9)
            df_year_cleaned['Log_GERD'] = np.log(df_year_cleaned['GERD'] + 1e-9)


            # Create the scatter plot for the current year pairing
            plt.figure(figsize=(10, 6))
            sns.scatterplot(data=df_year_cleaned, x='Log_GERD', y='Log_Real_GDP')
            plt.title(f'Log of Gross Domestic Expenditure on R&D (GERD) ({gerd_year}) vs Log of Real GDP ({gdp_year})')
            plt.xlabel(f'Log of Gross Domestic Expenditure on R&D (GERD) (current PPP USD) ({gerd_year})')
            plt.ylabel(f'Log of Real GDP (billion USD) ({gdp_year})')
            plt.grid(True)
            plt.show()
        else:
            print(f"No valid data to plot for GERD year {gerd_year} and GDP year {gdp_year}")
    else:
        print(f"Could not find both Real GDP column for year {gdp_year} and GERD column for year {gerd_year}")

"""# 2. Analyze the variables based on system map![스크린샷 2025-10-13 112454.png](data:image/png;base64,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SH2ioiiK1i86nU7q6urueKI60yi5vKw9PT2YTKbr/CzkXLTbTC464HTUifZsnrt6P2+EevzZQJ04qdesTtDvpy9ShfLp93Im9pt/ruRMLb1e7zXt7hb1fKejBtG6n/O9Gar1zHSEXBAxNffudGRZZnR0lKamJkpKSli1atU9zXPU68x/v8lNlO12O/a7iCouyzKJRIJMJoPT6bztOSkzaIaofhNzHcVzYGCAl156iWw2y/Lly3niiSfYvHkzpaWl9xQrQ+fekSSJ0dFRjh8/zmuvvUZraytr167li1/8IqWlv0olpygKo6OjnDx58hrLHKPRSHV1NZs3b77mnY/H47S2tnL16tVrBESv18u2bduu6W9kWWZsbIwLFy4QDoe1300mEzU1Naxfv17ru5Wcf21HRwdtbW3Iskxvby/Nzc186lOfYteuXdr2OjdHHcv7+/vxeDyUlZXlN4GFKkwquehC+/fvp7S0lH379t31arouTM5vdGFSZyGTzUXLVX1n7pdbTUxV5Jx53j/90z+xfPlyfud3fmdGjn0vyLJMZ2cn3/72t/H5fPzBH/zBNfXq9eRP8ueKVCrF5ORk/s+zjtr/3Oo53i1KLv3NTO83k8kQCoXITotePROogvxMnuvNUHLBUu5mQUdRFCKRCFevXsWeS8t0uznJjVCF8ekT5PtBnRzfqYmnevyZ+MaEXHqA2x1zponFYnR0dCBJEm63m/r6eh555BEef/zx69JA6cwu2WyWzs5OXnjhBU6ePMnExAQbN27kC1/4wjXps+Rc8LV/+qd/IhaLab/bbDZ27NjBhz70oWue2+TkJK+//jqHDh26pq+prKzkE5/4BFVVVdpv2WyW9vZ2nn/+eQKBgPa73W5n586dPPPMM5osoOTSU73xxhscOHBAa1tRUcGHP/xh6uvrtd90bo6iKPT19fGLX/yC+vp6Hn/88fwmsFCFSaZFThVFEafTededymwLk9Mnf/e7QjyXqBM8deAQBAElpxmZvmIvyzKSJGnXNtOTVl2Y1FnIZPVorno0V50bMpeLCNMXLe5UeFW/o2effZbKyko++tGPXmead6fM5LXKsszExASjo6M0NDTcdu41/doXKm1tbXzta1/D6XSyceNGnnzySSoqKshms3quwDlGyuVmHhgY4PTp0xw7dgyXy8Vv/dZvsWrVKq2duoATi8WueffE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)
# Moderators
- **Government incentives** - Government-financed BERD (%),
- **Venture funding** - Business-financed BERD (%),
- **Labor market**	- R&D Personnel per 1000 employees
# Mediators
- **Innovation output**- Resident/Non-resident Patents,
- **R&D human capital**- R&D Researchers per million ,
- **Technological exports**-High-tech Export Share,
- **Productivity of firms**-Business R&D Personnel (FTE)
# Confounders
- **Fiscal capacity**-	GDP per capita,
- **Population size**- Population/Labor size.


"""

# Identify columns for the specified variables
variable_cols = {}

# Iterate through columns to find matches based on the first row content
for col in df.columns:
    if isinstance(df.iloc[0][col], str):
        if 'Resident Patent Applications' in df.iloc[0][col]:
            variable_cols['Resident Patent Applications'] = col
        if 'Non-Resident Patent Applications' in df.iloc[0][col]:
            variable_cols['Non-Resident Patent Applications'] = col
        if 'Number of R&D Researcher' in df.iloc[0][col] and '(per million people)' in df.iloc[0][col]:
            variable_cols['Number of R&D Researcher (per million people)'] = col
        if 'High-Tech Export Share (as % of Manufacturing exports)' in df.iloc[0][col]:
            variable_cols['High-Tech Export Share (% of Manufacturing exports)'] = col
        if 'Business R&D Personnel (FTE)' in df.iloc[0][col] and 'Average Annual Growth Rate' not in df.iloc[0][col] and 'as % of National Employment' not in df.iloc[0][col] and 'per 1,000 Employed' not in df.iloc[0][col]:
             variable_cols['Business R&D Personnel (FTE)'] = col
        if 'Real GDP (billion USD, PPP-based)' in df.iloc[0][col]:
            # Assuming the GDP column identified previously is correct, use that
            # If the exact string 'Real GDP (billion USD, PPP-based)' is not in the first row,
            # rely on the previous identification logic or adjust as needed.
            # Based on previous code, 'Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)' was used.
            # match that or a similar pattern.
             if 'Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)' in df.iloc[0][col]:
                 year = str(col).split('.')[0] if '.' in str(col) else str(col)
                 variable_cols[f'Real GDP ({year})'] = col
        if 'Total Population' in df.iloc[0][col]:
            variable_cols['Total Population'] = col
        if 'Labor Force' in df.iloc[0][col]:
            variable_cols['Labor Force Size'] = col
        if 'Share of Government-Financed BERD (%)' in df.iloc[0][col]:
            variable_cols['Share of Government-Financed BERD (%)'] = col
        if 'Share of Business-Financed BERD (%)' in df.iloc[0][col]:
            variable_cols['Share of Business-Financed BERD (%)'] = col
        if 'Business R&D Personnel (FTE) per 1,000 Employed' in df.iloc[0][col]:
            variable_cols['Business R&D Personnel (FTE) per 1,000 Employed'] = col


# Print the identified columns
print("Identified columns for variables:")
for var, col in variable_cols.items():
    print(f"- {var}: {col}")

# Re-initialize the dictionary to ensure it's clean for the updated search
variable_cols = {}

# Iterate through columns to find matches based on the first row content
for col in df.columns:
    first_row_value = df.iloc[0][col]
    if isinstance(first_row_value, str):
        # Clean the first row value for easier matching by removing common suffixes
        cleaned_value = first_row_value.replace('(per million people)', '').replace('(as % of Manufacturing exports)', '').replace('(FTE)', '').replace('(billion USD, PPP-based, Chain-weighted, 2020 base year)', '').replace('(current US$)', '').strip()

        if 'Resident Patent Applications' in cleaned_value:
            variable_cols['Resident Patent Applications'] = col
        if 'Non-Resident Patent Applications' in cleaned_value:
            # Often, resident and non-resident patent data are in the same column with a combined header
            # We'll capture the column if either is found and rely on data cleaning later to separate if needed.
            if 'Non-Resident Patent Applications' not in variable_cols: # Avoid overwriting if resident was found first
                 variable_cols['Non-Resident Patent Applications'] = col
        if 'Number of R&D Researcher' in cleaned_value:
            variable_cols['Number of R&D Researcher (per million people)'] = col
        if 'High-Tech Export Share' in cleaned_value:
            variable_cols['High-Tech Export Share (% of Manufacturing exports)'] = col
        if 'Business R&D Personnel' in cleaned_value and 'Average Annual Growth Rate' not in cleaned_value and 'as % of National Employment' not in cleaned_value and 'per 1,000 Employed' not in cleaned_value:
             variable_cols['Business R&D Personnel (FTE)'] = col
        if 'Real GDP' in cleaned_value:
             year = str(col).split('.')[0] if '.' in str(col) else str(col)
             variable_cols[f'Real GDP ({year})'] = col
        if 'Total Population' in cleaned_value:
            variable_cols['Total Population'] = col
        if 'Labor Force' in cleaned_value and 'Participation Rate' not in cleaned_value:
            variable_cols['Labor Force Size'] = col
        if 'Share of Government-Financed BERD' in cleaned_value:
            variable_cols['Share of Government-Financed BERD (%)'] = col
        if 'Share of Business-Financed BERD' in cleaned_value:
            variable_cols['Share of Business-Financed BERD (%)'] = col
        if 'Business R&D Personnel (FTE) per 1,000 Employed' in cleaned_value:
            variable_cols['Business R&D Personnel (FTE) per 1,000 Employed'] = col


# Print the identified columns
print("Identified columns for variables:")
for var, col in variable_cols.items():
    print(f"- {var}: {col}")

# Re-initialize the dictionary to ensure it's clean for the updated search
variable_cols = {}

# Iterate through columns to find matches based on the first row content
for col in df.columns:
    first_row_value = df.iloc[0][col]
    if isinstance(first_row_value, str):
        # Clean the first row value for easier matching by removing common suffixes
        cleaned_value = first_row_value.replace('(per million people)', '').replace('(as % of Manufacturing exports)', '').replace('(FTE)', '').replace('(billion USD, PPP-based, Chain-weighted, 2020 base year)', '').replace('(current US$)', '').strip()

        if 'Resident Patent Applications' in cleaned_value:
            variable_cols['Resident Patent Applications'] = col
        # Non-Resident Patent Applications often shares a column with Resident. handle this during cleaning.
        if 'Number of R&D Researcher' in cleaned_value:
            variable_cols['Number of R&D Researcher (per million people)'] = col
        if 'High-Tech Export Share' in cleaned_value:
            variable_cols['High-Tech Export Share (% of Manufacturing exports)'] = col
        if 'Business R&D Personnel' in cleaned_value and 'Average Annual Growth Rate' not in cleaned_value and 'as % of National Employment' not in cleaned_value and 'per 1,000 Employed' not in cleaned_value:
             variable_cols['Business R&D Personnel (FTE)'] = col
        if 'Real GDP' in cleaned_value:
             # Prioritize recent years if multiple GDP columns are found
             year = str(col).split('.')[0] if '.' in str(col) else str(col)
             try:
                 year_int = int(year)
                 # Keep the latest identified GDP year if multiple are found
                 if 'Real GDP' not in variable_cols or year_int > int(variable_cols['Real GDP'].split('.')[0] if '.' in variable_cols['Real GDP'] else variable_cols['Real GDP']):
                      variable_cols['Real GDP'] = col
             except ValueError:
                 # Handle cases where the column name before the dot is not a year
                 pass
        if 'Total Population' in cleaned_value:
            variable_cols['Total Population'] = col
        if 'Labor Force' in cleaned_value and 'Participation Rate' not in cleaned_value:
            variable_cols['Labor Force Size'] = col
        if 'Share of Government-Financed BERD' in cleaned_value:
            variable_cols['Share of Government-Financed BERD (%)'] = col
        if 'Share of Business-Financed BERD' in cleaned_value:
            variable_cols['Share of Business-Financed BERD (%)'] = col
        if 'Business R&D Personnel (FTE) per 1,000 Employed' in cleaned_value:
            variable_cols['Business R&D Personnel (FTE) per 1,000 Employed'] = col

# Print the identified columns to confirm
print("Identified columns for variables:")
for var, col in variable_cols.items():
    print(f"- {var}: {col}")

# Check if all necessary columns are identified
required_variables = [
    'Resident Patent Applications',
    'Non-Resident Patent Applications',
    'Number of R&D Researcher (per million people)',
    'High-Tech Export Share (% of Manufacturing exports)',
    'Business R&D Personnel (FTE)',
    'Real GDP',
    'Total Population',
    'Labor Force Size',
    'Share of Government-Financed BERD (%)',
    'Share of Business-Financed BERD (%)',
    'Business R&D Personnel (FTE) per 1,000 Employed'
]

missing_variables = [var for var in required_variables if var not in variable_cols]

if missing_variables:
    print("\nWarning: The following variables' columns were not definitively identified:")
    for var in missing_variables:
        print(f"- {var}")
else:
    print("\nAll required variables' columns appear to be identified.")

# Re-initialize the dictionary to ensure it's clean for the updated search
variable_cols = {}

# Iterate through columns to find matches based on the first row content
for col in df.columns:
    first_row_value = df.iloc[0][col]
    if isinstance(first_row_value, str):
        # Clean the first row value for easier matching by removing common suffixes
        cleaned_value = first_row_value.replace('(per million people)', '').replace('(as % of Manufacturing exports)', '').replace('(FTE)', '').replace('(billion USD, PPP-based, Chain-weighted, 2020 base year)', '').replace('(current US$)', '').replace('(number)', '').strip()

        if 'Resident Patent Applications' in cleaned_value:
            variable_cols['Resident Patent Applications'] = col
        # Check for Non-Resident Patent Applications specifically or if it's in the same column as Resident
        if 'Non-Resident Patent Applications' in cleaned_value:
             variable_cols['Non-Resident Patent Applications'] = col
        # If Resident was found but Non-Resident wasn't in a separate column, assume they are in the same column
        elif 'Resident Patent Applications' in cleaned_value and 'Non-Resident Patent Applications' not in variable_cols:
             variable_cols['Non-Resident Patent Applications'] = col # Assign the same column as Resident

        if 'Number of R&D Researcher' in cleaned_value:
            variable_cols['Number of R&D Researcher (per million people)'] = col
        if 'High-Tech Export Share' in cleaned_value:
            variable_cols['High-Tech Export Share (% of Manufacturing exports)'] = col
        if 'Business R&D Personnel' in cleaned_value and 'Average Annual Growth Rate' not in cleaned_value and 'as % of National Employment' not in cleaned_value and 'per 1,000 Employed' not in cleaned_value:
             variable_cols['Business R&D Personnel (FTE)'] = col
        if 'Real GDP' in cleaned_value:
             # Prioritize recent years if multiple GDP columns are found
             year = str(col).split('.')[0] if '.' in str(col) else str(col)
             try:
                 year_int = int(year)
                 # Keep the latest identified GDP year if multiple are found
                 if 'Real GDP' not in variable_cols or (isinstance(variable_cols['Real GDP'], str) and int(variable_cols['Real GDP'].split('.')[0] if '.' in variable_cols['Real GDP'] else variable_cols['Real GDP']) < year_int):
                      variable_cols['Real GDP'] = col
             except ValueError:
                 # Handle cases where the column name before the dot is not a year
                 pass
        if 'Total Population' in cleaned_value:
            variable_cols['Total Population'] = col
        if 'Labor Force' in cleaned_value and 'Participation Rate' not in cleaned_value:
            variable_cols['Labor Force Size'] = col
        if 'Share of Government-Financed BERD' in cleaned_value:
            variable_cols['Share of Government-Financed BERD (%)'] = col
        if 'Share of Business-Financed BERD' in cleaned_value:
            variable_cols['Share of Business-Financed BERD (%)'] = col
        if 'Business R&D Personnel (FTE) per 1,000 Employed' in cleaned_value:
            variable_cols['Business R&D Personnel (FTE) per 1,000 Employed'] = col


# Print the identified columns to confirm
print("Identified columns for variables:")
for var, col in variable_cols.items():
    print(f"- {var}: {col}")

# Check if all necessary columns are identified
required_variables = [
    'Resident Patent Applications',
    'Non-Resident Patent Applications',
    'Number of R&D Researcher (per million people)',
    'High-Tech Export Share (% of Manufacturing exports)',
    'Business R&D Personnel (FTE)',
    'Real GDP',
    'Total Population',
    'Labor Force Size',
    'Share of Government-Financed BERD (%)',
    'Share of Business-Financed BERD (%)',
    'Business R&D Personnel (FTE) per 1,000 Employed'
]

missing_variables = [var for var in required_variables if var not in variable_cols]

if missing_variables:
    print("\nWarning: The following variables' columns were not definitively identified:")
    for var in missing_variables:
        print(f"- {var}")
else:
    print("\nAll required variables' columns appear to be identified.")

# Re-initialize the dictionary to ensure it's clean for the updated search
variable_cols = {}

# Define a dictionary of keywords to look for, mapping them to the desired variable names
keywords = {
    'Resident Patent Applications': 'Resident Patent Applications',
    'Non-Resident Patent Applications': 'Non-Resident Patent Applications',
    'Number of R&D Researcher': 'Number of R&D Researcher (per million people)',
    'High-Tech Export Share': 'High-Tech Export Share (% of Manufacturing exports)',
    'Business R&D Personnel (FTE)': 'Business R&D Personnel (FTE)',
    'Real GDP': 'Real GDP',
    'Total Population': 'Total Population',
    'Labor Force': 'Labor Force Size',
    'Government-Financed BERD (%)': 'Share of Government-Financed BERD (%)',
    'Business-Financed BERD (%)': 'Share of Business-Financed BERD (%)',
    'Business R&D Personnel (FTE) per 1,000 Employed': 'Business R&D Personnel (FTE) per 1,000 Employed'
}


# Iterate through columns to find matches based on keywords in the first row content
for col in df.columns:
    first_row_value = df.iloc[0][col]
    if isinstance(first_row_value, str):
        # Check for each keyword in the first row value
        for keyword, var_name in keywords.items():
            if keyword in first_row_value:
                # For 'Real GDP', prioritize later years
                if var_name == 'Real GDP':
                    year = str(col).split('.')[0] if '.' in str(col) else str(col)
                    try:
                        year_int = int(year)
                         # Keep the latest identified GDP year if multiple are found
                        if var_name not in variable_cols or (isinstance(variable_cols[var_name], str) and int(variable_cols[var_name].split('.')[0] if '.' in variable_cols[var_name] else variable_cols[var_name]) < year_int):
                            variable_cols[var_name] = col
                    except ValueError:
                         # Handle cases where the column name before the dot is not a year
                         pass
                # For other variables, assign the first column found containing the keyword
                elif var_name not in variable_cols:
                     variable_cols[var_name] = col

# Print the final identified columns
print("Final identified columns for variables:")
for var, col in variable_cols.items():
    print(f"- {var}: {col}")

# Check if all necessary columns are identified in the final list
required_variables = list(keywords.values())

missing_variables = [var for var in required_variables if var not in variable_cols]

if missing_variables:
    print("\nWarning: The following variables' columns were not found in the dataset:")
    for var in missing_variables:
        print(f"- {var}")
else:
    print("\nAll required variables' columns have been identified.")

# Create a new DataFrame with the '국가별' column and the identified variable columns
# Ensure all identified columns are actually present in the original dataframe before selection
selected_cols = ['국가별'] + [col for col in variable_cols.values() if col in df.columns]
df_cleaned = df.loc[:, selected_cols].copy()

# Remove the first two rows which contain header information
df_cleaned = df_cleaned.iloc[2:].copy()

# Rename columns to be more descriptive using the keys from variable_cols
# Create a mapping from the original column names to the desired variable names
col_rename_map = {v: k for k, v in variable_cols.items() if v in df_cleaned.columns}
df_cleaned.rename(columns=col_rename_map, inplace=True)


# Iterate through the variable columns (excluding '국가별') and clean the data
for col in df_cleaned.columns:
    if col != '국가별':
        # Convert the data to string type to handle potential mixed data types
        df_cleaned[col] = df_cleaned[col].astype(str)

        # Remove non-numeric characters (keep digits, periods, and hyphens)
        df_cleaned[col] = df_cleaned[col].str.replace('[^0-9.-]', '', regex=True)

        # Convert to numeric, coercing errors to NaN
        df_cleaned[col] = pd.to_numeric(df_cleaned[col], errors='coerce')

# Handle missing values by dropping rows with NaNs in the variable columns
variable_column_names = [col for col in df_cleaned.columns if col != '국가별']
df_cleaned.dropna(subset=variable_column_names, inplace=True)

# Display the first few rows and info of the cleaned DataFrame
display(df_cleaned.head())
df_cleaned.info()

"""## Descriptive statistics

mean, median, standard deviation, etc. for each of the cleaned variables.

"""

# Select only numeric columns from df_cleaned
df_numeric = df_cleaned.select_dtypes(include=np.number)

# Calculate descriptive statistics for the numeric columns
descriptive_stats = df_numeric.describe()

# Display the descriptive statistics
display(descriptive_stats)

"""# Distribution of Confounder, Moderater and Mediater"""

# Select only numeric columns for visualization
df_numeric = df_cleaned.select_dtypes(include=np.number)

# Iterate through the numeric columns and create visualizations
for col in df_numeric.columns:
    print(f"Visualizing distribution for: {col}")

    # Create a figure with two subplots (histogram and box plot)
    fig, axes = plt.subplots(1, 2, figsize=(15, 5))

    # Plot Histogram
    sns.histplot(data=df_numeric, x=col, kde=True, ax=axes[0])
    axes[0].set_title(f'Distribution of {col}')
    axes[0].set_xlabel(col)
    axes[0].set_ylabel('Frequency')

    # Plot Box Plot
    sns.boxplot(data=df_numeric, x=col, ax=axes[1])
    axes[1].set_title(f'Box Plot of {col}')
    axes[1].set_xlabel(col)
    axes[1].set_ylabel('Value')

    plt.tight_layout()
    plt.show()

"""# 3. Correlation between datasets"""

# Calculate the correlation matrix
correlation_matrix = df_numeric.corr()

# Create a heatmap of the correlation matrix
plt.figure(figsize=(12, 10))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=.5)
plt.title('Correlation Matrix of Socio-Economic Variables')
plt.show()

"""- **Model 1**: log GDP, log GERD (simple regression)
- **Model 2**: log GDP, log GERD + GDP per Capita + Population Labor Size (confounders)
- **Model 3**: log GDP, log GERD + Patents + R&D Researchers + Hightech Exports + Business R&D Personnel (mediators)
 - **Model 4**: log GDP ~ log GERD * Gov Financed BERD + GDP per Capita + Population Labor Size (moderator interaction)

## 4. Building Multiple Linear Regression Models
Using `statsmodels.formula.api.ols`, build the four specified regression models and print their summaries.
"""

import numpy as np

# Ensure df is loaded
if df is not None:
    # Create a copy of the dataframe to avoid modifying the original
    df_regression = df.copy()

    # Remove the first two rows which contain header information
    df_regression = df_regression.iloc[2:].copy()

    # Identify the columns again for this specific regression analysis
    # This is necessary as the previous column identification was for a different task
    # and might not have captured all required columns for the regression.

    # Define a dictionary of keywords to look for, mapping them to the desired variable names
    regression_keywords = {
        'Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)': 'Real GDP', # Dependent Variable
        'Gross Domestic Expenditure on R&D (GERD) (current PPP USD)': 'GERD', # Independent Variable
        'Resident Patent Applications': 'Resident Patent Applications', # Mediator 1
        'Non-Resident Patent Applications': 'Non-Resident Patent Applications', # Mediator 2
        'Number of R&D Researcher (per million people)': 'R&D Researchers per Million People', # Mediator 3
        'High-Tech Export Share (as % of Manufacturing exports)': 'High-tech Export Share (% of Manufactured Exports)', # Mediator 4
        'Business R&D Personnel (FTE)': 'Business R&D Personnel (FTE)', # Mediator 5 (Assuming FTE is the relevant measure)
        'GDP per Capita': 'GDP per Capita', # Confounder 1 (Need to find the exact column name)
        'Total Population': 'Total Population', # Confounder 2 (Need to find the exact column name)
        'Labor Force': 'Labor Force Size', # Confounder 3 (Need to find the exact column name, excluding participation rate)
        'Share of Government-Financed BERD (%)': 'Government-financed BERD (%)', # Moderator 1
        'Share of Business-Financed BERD (%)': 'Business-financed BERD (%)', # Moderator 2
        'Business R&D Personnel (FTE) per 1,000 Employed': 'R&D Personnel per 1,000 Employees' # Moderator 3
    }

    regression_cols = {}

    # Iterate through columns to find matches based on keywords in the first row content
    for col in df_regression.columns:
        first_row_value = df.iloc[0][col] # Use original df to get the first row header
        if isinstance(first_row_value, str):
             for keyword, var_name in regression_keywords.items():
                if keyword in first_row_value:
                    # For 'Real GDP' and 'GERD', use the exact provided names
                    if keyword in ['Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)', 'Gross Domestic Expenditure on R&D (GERD) (current PPP USD)']:
                        if var_name not in regression_cols: # Avoid overwriting if already found
                            regression_cols[var_name] = col
                    # For other variables, use the first column found containing the keyword
                    elif var_name not in regression_cols:
                         regression_cols[var_name] = col


    print("Identified columns for regression variables:")
    for var, col in regression_cols.items():
        print(f"- {var}: {col}")

    # Select only the identified columns and the country column
    # Ensure all identified columns are actually present in the original dataframe before selection
    selected_regression_cols = ['국가별'] + [col for col in regression_cols.values() if col in df_regression.columns]
    df_regression = df_regression.loc[:, selected_regression_cols].copy()

    # Rename columns to be more descriptive
    col_rename_map_regression = {v: k for k, v in regression_cols.items()}
    df_regression.rename(columns=col_rename_map_regression, inplace=True)

    # Clean and convert data to numeric for the selected regression columns
    for col in df_regression.columns:
        if col != '국가별':
            df_regression[col] = df_regression[col].astype(str).str.replace('[^0-9.-]', '', regex=True)
            df_regression[col] = pd.to_numeric(df_regression[col], errors='coerce')

    # Handle missing values by dropping rows with NaNs in the regression variables
    regression_variable_names = [col for col in df_regression.columns if col != '국가별']
    df_regression.dropna(subset=regression_variable_names, inplace=True)

    # Apply log transformation to Real GDP and GERD
    # Add a small constant to avoid log(0)
    if 'Real GDP' in df_regression.columns:
        df_regression['Log_Real_GDP'] = np.log(df_regression['Real GDP'] + 1e-9)
    else:
        print("Warning: 'Real GDP' column not found for log transformation.")

    if 'GERD' in df_regression.columns:
        df_regression['Log_GERD'] = np.log(df_regression['GERD'] + 1e-9)
    else:
         print("Warning: 'GERD' column not found for log transformation.")


    print("\nCleaned and Transformed Data:")
    display(df_regression.head())
    df_regression.info()
else:
    print("DataFrame 'df' not found. Please run the data loading cell first.")

"""## Actual vs. Predicted Values Plot for Model 4
Generate a scatter plot of the actual values of the dependent variable (Log_Real_GDP) against the values predicted by Model 4, with a line of perfect fit.
"""

import matplotlib.pyplot as plt
import seaborn as sns

# Ensure Model 4 was successfully built and the dataframe used for it is available
if 'model_4' in locals() and model_4 is not None and 'df_regression_renamed' in locals() and df_regression_renamed is not None:

    print("Generating actual vs. predicted values plot for Model 4...")

    # Get the actual values of the dependent variable
    actual_gdp = df_regression_renamed['Log_Real_GDP']

    # Get the predicted values from Model 4
    predicted_gdp = model_4.predict(df_regression_renamed)

    plt.figure(figsize=(8, 6))
    sns.scatterplot(x=predicted_gdp, y=actual_gdp, alpha=0.6)
    plt.plot([actual_gdp.min(), actual_gdp.max()], [actual_gdp.min(), actual_gdp.max()], color='red', linestyle='--', lw=2, label='Perfect Fit')

    plt.title('Actual vs. Predicted Log(Real GDP) (Model 4)')
    plt.xlabel('Predicted Log(Real GDP)')
    plt.ylabel('Actual Log(Real GDP)')
    plt.legend()
    plt.grid(True)
    plt.show()

elif 'model_4' not in locals() or model_4 is None:
    print("Model 4 was not successfully built. Cannot generate actual vs. predicted values plot.")
elif 'df_regression_renamed' not in locals() or df_regression_renamed is None:
    print("Cleaned and renamed DataFrame 'df_regression_renamed' not found. Cannot generate actual vs. predicted values plot.")

import statsmodels.formula.api as smf
import pandas as pd
import numpy as np

# Ensure df_regression and the necessary columns exist
if 'df_regression' in locals() and df_regression is not None:

    # Rename columns for easier use in formulas (based on user's simplified names)
    # Create a mapping from original (renamed in step 3) to simplified names
    # Check if the simplified names are already column names to avoid issues
    column_rename_map = {}
    if 'GDP per Capita' in df_regression.columns and 'GDP_per_Capita' not in df_regression.columns:
        column_rename_map['GDP per Capita'] = 'GDP_per_Capita'
    # Assuming 'Total Population' and 'Labor Force Size' were not found, but if they were,
    # they would need similar renaming if used in formulas.
    # Based on previous output, these were not found, so we won't include them in renaming for now.

    if 'Resident Patent Applications' in df_regression.columns and 'Resident_Patent_Applications' not in df_regression.columns:
        column_rename_map['Resident Patent Applications'] = 'Resident_Patent_Applications'
    if 'Non-Resident Patent Applications' in df_regression.columns and 'Non_Resident_Patent_Applications' not in df_regression.columns:
        column_rename_map['Non-Resident Patent Applications'] = 'Non_Resident_Patent_Applications'
    if 'R&D Researchers per Million People' in df_regression.columns and 'R_and_D_Researchers_per_Million_People' not in df_regression.columns:
         column_rename_map['R&D Researchers per Million People'] = 'R_and_D_Researchers_per_Million_People'
    if 'High-tech Export Share (% of Manufactured Exports)' in df_regression.columns and 'Hightech_Export_Share' not in df_regression.columns:
         column_rename_map['High-tech Export Share (% of Manufactured Exports)'] = 'Hightech_Export_Share'
    if 'Business R&D Personnel (FTE)' in df_regression.columns and 'Business_R_and_D_Personnel_FTE' not in df_regression.columns:
         column_rename_map['Business R&D Personnel (FTE)'] = 'Business_R_and_D_Personnel_FTE'

    if 'Government-financed BERD (%)' in df_regression.columns and 'GovFinanced_BERD_pct' not in df_regression.columns:
        column_rename_map['Government-financed BERD (%)'] = 'GovFinanced_BERD_pct'
    if 'Business-financed BERD (%)' in df_regression.columns and 'BusinessFinanced_BERD_pct' not in df_regression.columns:
        column_rename_map['Business-financed BERD (%)'] = 'BusinessFinanced_BERD_pct'
    if 'R&D Personnel per 1,000 Employees' in df_regression.columns and 'R_and_D_Personnel_per_1000_Employees' not in df_regression.columns:
         column_rename_map['R&D Personnel per 1,000 Employees'] = 'R_and_D_Personnel_per_1000_Employees'

    # Rename columns in the DataFrame
    df_regression_renamed = df_regression.rename(columns=column_rename_map)


    # Model 1: log_GDP ~ log_GERD (simple regression)
    print("# Model 1: Simple Regression")
    try:
        model_1_formula = 'Log_Real_GDP ~ Log_GERD'
        model_1 = smf.ols(model_1_formula, data=df_regression_renamed).fit()
        print(model_1.summary())
        print("Interpretation: Model 1 shows the direct relationship between log(GERD) and log(Real GDP).")
    except Exception as e:
        print(f"Error building Model 1: {e}")
        model_1 = None
    print("\n" + "="*50 + "\n")


    # Model 2: log_GDP ~ log_GERD + GDP_per_Capita + Population_Labor_Size (confounders)
    print("# Model 2: Adding Confounders")
    try:
        # Check if confounder variables were successfully renamed and exist
        confounder_vars_formula = ' + '.join([column_rename_map.get(var, var) for var in ['GDP per Capita', 'Total Population', 'Labor Force Size'] if column_rename_map.get(var, var) in df_regression_renamed.columns])
        if confounder_vars_formula:
            model_2_formula = f'Log_Real_GDP ~ Log_GERD + {confounder_vars_formula}'
            model_2 = smf.ols(model_2_formula, data=df_regression_renamed).fit()
            print(model_2.summary())
            print("Interpretation: Model 2 includes confounders to see their effect and the effect of log(GERD) after accounting for them.")
        else:
            print("Confounder variables not found in the dataset after renaming. Skipping Model 2.")
            model_2 = None
    except Exception as e:
        print(f"Error building Model 2: {e}")
        model_2 = None
    print("\n" + "="*50 + "\n")


    # Model 3: log_GDP ~ log_GERD + Patents + R&D_Researchers + Hightech_Exports + Business_R&D_Personnel (mediators)
    print("# Model 3: Adding Mediators")
    try:
        # Check if mediator variables were successfully renamed and exist
        mediator_vars_formula = ' + '.join([column_rename_map.get(var, var) for var in ['Resident Patent Applications', 'Non-Resident Patent Applications', 'R&D Researchers per Million People', 'High-tech Export Share (% of Manufacturing exports)', 'Business R&D Personnel (FTE)'] if column_rename_map.get(var, var) in df_regression_renamed.columns])

        if confounder_vars_formula and mediator_vars_formula:
            model_3_formula = f'Log_Real_GDP ~ Log_GERD + {confounder_vars_formula} + {mediator_vars_formula}'
            model_3 = smf.ols(model_3_formula, data=df_regression_renamed).fit()
            print(model_3.summary())
            print("Interpretation: Model 3 adds potential mediators to examine their influence and the change in the effect of log(GERD).")
        elif mediator_vars_formula: # Case where only mediators are found (unlikely based on plan but for robustness)
             model_3_formula = f'Log_Real_GDP ~ Log_GERD + {mediator_vars_formula}'
             model_3 = smf.ols(model_3_formula, data=df_regression_renamed).fit()
             print(model_3.summary())
             print("Interpretation: Model 3 adds potential mediators (Confounders not found).")
        else:
            print("Mediator variables not found in the dataset after renaming or confounders missing. Skipping Model 3.")
            model_3 = None
    except Exception as e:
        print(f"Error building Model 3: {e}")
        model_3 = None
    print("\n" + "="*50 + "\n")


    # Model 4: log_GDP ~ log_GERD * GovFinanced_BERD + GDP_per_Capita + Population_Labor_Size (moderator interaction)
    print("# Model 4: Adding Moderator Interaction")
    try:
        # Check if moderator and other necessary variables exist after renaming
        moderator_var_formula = column_rename_map.get('Government-financed BERD (%)', 'Government-financed BERD (%)') # Use the renamed name or original if not renamed
        if moderator_var_formula in df_regression_renamed.columns and confounder_vars_formula:
             # Construct the formula with interaction term using '*'
             model_4_formula = f'Log_Real_GDP ~ Log_GERD * {moderator_var_formula} + {confounder_vars_formula}'
             model_4 = smf.ols(model_4_formula, data=df_regression_renamed).fit()
             print(model_4.summary())
             print(f"Interpretation: Model 4 includes an interaction term between log(GERD) and {moderator_var_formula} to test for moderation.")
        else:
            print("Moderator variable or confounders not found. Skipping Model 4.")
            model_4 = None
    except Exception as e:
        print(f"Error building Model 4: {e}")
        model_4 = None
    print("\n" + "="*50 + "\n")

else:
    print("Cleaned and transformed DataFrame 'df_regression' not found. Please run the previous steps.")

"""## 6. Create Comparison Table
Generate a table comparing the Adjusted R² and the coefficient (β) of log(GERD) across all four models.
"""

# Create a dictionary to store results
results_dict = {}

if model_1:
    results_dict['Model 1'] = {
        'Adjusted R-squared': model_1.rsquared_adj,
        'Beta (Log_GERD)': model_1.params.get('Log_GERD', 'N/A')
    }

if model_2:
    results_dict['Model 2'] = {
        'Adjusted R-squared': model_2.rsquared_adj,
        'Beta (Log_GERD)': model_2.params.get('Log_GERD', 'N/A')
    }

if model_3:
    results_dict['Model 3'] = {
        'Adjusted R-squared': model_3.rsquared_adj,
        'Beta (Log_GERD)': model_3.params.get('Log_GERD', 'N/A')
    }

if model_4:
    # For the interaction model, the interpretation of the independent variable's coefficient changes.
    # include it, but the interaction term should be considered.
     results_dict['Model 4'] = {
        'Adjusted R-squared': model_4.rsquared_adj,
        'Beta (Log_GERD)': model_4.params.get('Log_GERD', 'N/A') # This is the effect when moderator is 0
    }


# Convert the dictionary to a pandas DataFrame
if results_dict:
    comparison_table = pd.DataFrame.from_dict(results_dict, orient='index')
    print("Comparison Table:")
    display(comparison_table)
else:
    print("No models were successfully built to create a comparison table.")

"""## 7. Generate Visualizations
Generate clear visualizations using Matplotlib/Seaborn:
- Scatter plot of log(GERD) vs. log(GDP) with regression line.
- Histogram of residuals for the final model (Model 4).
- Bar chart comparing Adjusted R² across models.
"""

import matplotlib.pyplot as plt
import seaborn as sns

if 'df_regression_renamed' in locals() and df_regression_renamed is not None:

    # Scatter plot of log(GERD) vs. log(GDP) with regression line
    plt.figure(figsize=(10, 6))
    sns.regplot(data=df_regression_renamed, x='Log_GERD', y='Log_Real_GDP', scatter_kws={'alpha': 0.6})
    plt.title('Scatter Plot of Log(GERD) vs Log(Real GDP)')
    plt.xlabel('Log of Gross Domestic Expenditure on R&D (GERD)')
    plt.ylabel('Log of Real GDP')
    plt.grid(True)
    plt.show()

    # Histogram of residuals for the final model (Model 4)
    if model_4:
        residuals = model_4.resid
        plt.figure(figsize=(8, 6))
        sns.histplot(residuals, kde=True)
        plt.title('Histogram of Residuals for Model 4')
        plt.xlabel('Residuals')
        plt.ylabel('Frequency')
        plt.show()
    else:
        print("Model 4 was not successfully built. Skipping residuals histogram.")

    # Bar chart comparing Adjusted R² across models
    if results_dict:
        models = list(results_dict.keys())
        adjusted_r_squared_values = [results_dict[model]['Adjusted R-squared'] for model in models]

        plt.figure(figsize=(10, 6))
        sns.barplot(x=models, y=adjusted_r_squared_values, palette='viridis')
        plt.title('Comparison of Adjusted R-squared Across Regression Models')
        plt.xlabel('Regression Model')
        plt.ylabel('Adjusted R-squared')
        plt.ylim(0, max(adjusted_r_squared_values) * 1.1) # Set y-limit slightly above max R2
        plt.show()
    else:
        print("No model results available to create Adjusted R-squared bar chart.")

else:
    print("Cleaned and renamed DataFrame 'df_regression_renamed' not found. Cannot generate visualizations.")

"""## 8. Summarize Findings
Provide a summary of the key findings from the regression analysis and visualizations.
"""

print("Summary of Findings:")
print("-" * 20)

if results_dict:
    print("\nRegression Model Comparison:")
    display(comparison_table)



else:
    print("No model results available")

"""This analysis was conducted to examine the causal impact of Gross Domestic Expenditure on R&D (GERD) on Real GDP.
Four regression models were sequentially estimated, gradually adding confounding, mediating, and moderating variables to identify the underlying causal structure.
The changes in regression coefficients, statistical significance, and explanatory power (Adjusted R²) were analyzed to interpret the causal relationships.

#Model 1: Simple Linear Regression (Log_Real_GDP ~ Log_GERD)

Model 1 estimates the simple linear relationship between Log(GERD) and Log(Real GDP).
The regression coefficient (β₁) is positive and statistically significant (p < 0.05), indicating that as GERD increases, Real GDP tends to increase correspondingly.
The Adjusted R² is approximately 0.494, suggesting that Log(GERD) explains about 49.4% of the variance in Log(Real GDP).
Thus, GERD can be considered a major explanatory factor contributing to economic growth.

#Model 2: Adding a Confounding Variable (Log_Real_GDP ~ Log_GERD + GDP_per_Capita)

Model 2 adds GDP per Capita as a confounding variable to the basic model.
The variables Total Population and Labor Force Size were unavailable in the dataset and therefore excluded.

The analysis shows that GDP per Capita is statistically insignificant (p = 0.491),
indicating that it does not have a meaningful impact on Real GDP in this model.
Meanwhile, the coefficient for Log(GERD) remains statistically significant (p = 0.003),
suggesting that the positive relationship between GERD and Real GDP persists even after controlling for GDP per Capita.

The Adjusted R² slightly decreases to 0.476, possibly due to the added confounder not substantially improving explanatory power,
or as a result of penalization for increased model complexity.

#Model 3: Adding Mediating Variables (Log_Real_GDP ~ Log_GERD + GDP_per_Capita + Innovation Variables)

Model 3 includes mediating variables — Resident / Non-resident Patent Applications, R&D Researchers per Million People,
High-tech Export Share (% of Manufactured Exports), and Business R&D Personnel (FTE) — in addition to Log(GERD) and GDP per Capita.

The coefficient for Log(GERD) slightly decreases (β ≈ 0.380) but remains statistically significant (p = 0.020).
This suggests that part of the relationship between GERD and Real GDP may be mediated by innovation, human capital, or technological diffusion.

Among the mediators, Resident Patent Applications shows a near-significant result (p = 0.053), implying that domestic patent activity might partially explain how GERD affects Real GDP.
Other mediators are not statistically significant.
The Adjusted R² increases substantially to approximately 0.700, indicating that including mediating variables substantially improves the model’s explanatory power.

#Model 4: Adding a Moderating Effect (Log_Real_GDP ~ Log_GERD * GovFinanced_BERD_pct + Mediators + Confounder)

Model 4 adds an interaction term between Log(GERD) and Government-financed BERD (%) to test for a moderating effect.

The interaction term (Log_GERD × GovFinanced_BERD_pct) is highly significant (p = 0.001),
suggesting that the effect of GERD on Real GDP varies depending on the proportion of government-financed R&D expenditure.
The coefficient for the interaction term (β = -0.0895) is negative, implying that as the share of government financing in R&D increases,
the positive impact of GERD on Real GDP tends to weaken.

The coefficient for Log(GERD) itself increases (β ≈ 1.070) compared to Model 3 and remains highly significant (p < 0.001).
This represents the effect of GERD on Real GDP when the moderator (Government-financed BERD) equals zero.
Given the significant interaction, the effect size of GERD should be interpreted conditionally on the level of government financing.
The Adjusted R² further increases to approximately 0.775, showing that Model 4 provides the best overall explanatory power.

#Key Findings and Implications

1. Relationship between GERD and Real GDP
Across all models, Log(GERD) consistently shows a statistically significant and positive relationship with Real GDP.
This provides empirical support for the notion that R&D investment is a key driver of economic growth.

2. Mediating Effects
Resident Patent Applications partially mediate the relationship between GERD and Real GDP,
suggesting that R&D expenditure contributes to economic growth indirectly through innovation activities.
Other mediators were not statistically significant, indicating that the mediating strength may be limited.

3. Moderating Effects
Government-financed BERD (%) moderates the relationship between GERD and Real GDP.
The positive effect of GERD on GDP tends to weaken as the proportion of government-financed R&D increases.
This finding implies that the efficiency of R&D investment may vary depending on the balance between public and private funding structures.

4. Model Fit Comparison
The Adjusted R² values steadily improve as the models expand (0.494 → 0.476 → 0.700 → 0.775).
This indicates that incorporating mediating and moderating variables yields a more comprehensive and accurate explanation of Real GDP fluctuations compared to a simple model.

#Conclusion

The multiple regression analysis demonstrates that GERD exerts a consistently positive impact on Real GDP.
However, this effect operates through both indirect innovation pathways (e.g., patent applications)
and conditional moderation effects depending on the level of government-financed R&D.

The results reveal that the relationship is not a simple “R&D → Growth” linear link,
but rather a multi-stage causal chain — “R&D → Innovation → Productivity → Growth” —
that is further conditioned by policy environments such as government funding ratios.

Therefore, future R&D policies should focus not merely on expanding total expenditure,
but also on optimizing the qualitative composition of investment —
balancing government and private funding, strengthening human capital, and promoting innovation output efficiency.
"""

import streamlit as st

# Set the page configuration
st.set_page_config(page_title="Real GDP and R&D Research Analysis", layout="wide")

# Add a main title to the app
st.title("Analysis of Real GDP and R&D Research")

# Add a sidebar with a brief description
st.sidebar.header("About")
st.sidebar.write(
    "This application analyzes the relationship between Real GDP and R&D research, "
    "including simple linear regression, correlation analysis, and multiple linear regression models."
)

import streamlit as st

# Set the page configuration
st.set_page_config(page_title="Real GDP and R&D Research Analysis", layout="wide")

# Add a main title to the app
st.title("Analysis of Real GDP and R&D Research")

# Add a sidebar with a brief description
st.sidebar.header("About")
st.sidebar.write(
    "This application analyzes the relationship between Real GDP and R&D research, "
    "including simple linear regression, correlation analysis, and multiple linear regression models."
)

import streamlit as st
import pandas as pd
import numpy as np

@st.cache_data
def load_and_preprocess_data():
    """
    Loads the dataset from the local directory (same folder as the Streamlit app)
    and preprocesses it for analysis.

    Returns:
        pd.DataFrame: The preprocessed DataFrame.
    """
    try:
        # Load dataset directly from the same directory as your Streamlit app
        df = pd.read_csv("ACDT final data set22.xlsx - 데이터 (1).csv", encoding="utf-8")

        # Clean all columns except the first one ('국가별') and exclude the first two rows
        for col in df.columns[1:]:
            # Select data from the third row onwards and convert to string type
            # Use .loc for clearer indexing and to avoid SettingWithCopyWarning
            df.loc[2:, col] = df.loc[2:, col].astype(str).str.replace('[^0-9.-]', '', regex=True)
            df.loc[2:, col] = pd.to_numeric(df.loc[2:, col], errors='coerce')

        # Identify the columns for the specified variables
        variable_cols = {}

        # Define a dictionary of keywords to look for, mapping them to the desired variable names
        keywords = {
            'Resident Patent Applications': 'Resident Patent Applications',
            'Non-Resident Patent Applications': 'Non-Resident Patent Applications',
            'Number of R&D Researcher': 'Number of R&D Researcher (per million people)',
            'High-Tech Export Share': 'High-Tech Export Share (% of Manufacturing exports)',
            'Business R&D Personnel (FTE)': 'Business R&D Personnel (FTE)',
            'Real GDP': 'Real GDP',
            'Total Population': 'Total Population',
            'Labor Force': 'Labor Force Size',
            'Government-Financed BERD (%)': 'Share of Government-Financed BERD (%)',
            'Business-Financed BERD (%)': 'Share of Business-Financed BERD (%)',
            'Business R&D Personnel (FTE) per 1,000 Employed': 'Business R&D Personnel (FTE) per 1,000 Employed'
        }

        # Iterate through columns to find matches based on keywords in the first row content
        for col in df.columns:
            first_row_value = df.iloc[0][col]
            if isinstance(first_row_value, str):
                # Check for each keyword in the first row value
                for keyword, var_name in keywords.items():
                    if keyword in first_row_value:
                        # For 'Real GDP', prioritize later years
                        if var_name == 'Real GDP':
                            year = str(col).split('.')[0] if '.' in str(col) else str(col)
                            try:
                                year_int = int(year)
                                # Keep the latest identified GDP year if multiple are found
                                if var_name not in variable_cols or (isinstance(variable_cols[var_name], str) and int(variable_cols[var_name].split('.')[0] if '.' in variable_cols[var_name] else variable_cols[var_name]) < year_int):
                                    variable_cols[var_name] = col
                            except ValueError:
                                # Handle cases where the column name before the dot is not a year
                                pass
                        # For other variables, assign the first column found containing the keyword
                        elif var_name not in variable_cols:
                            variable_cols[var_name] = col


        # Create a new DataFrame with the '국가별' column and the identified variable columns
        # Ensure all identified columns are actually present in the original dataframe before selection
        selected_cols = ['국가별'] + [col for col in variable_cols.values() if col in df.columns]
        df_cleaned = df.loc[:, selected_cols].copy()

        # Remove the first two rows which contain header information
        df_cleaned = df_cleaned.iloc[2:].copy()

        # Rename columns to be more descriptive using the keys from variable_cols
        # Create a mapping from the original column names to the desired variable names
        col_rename_map = {v: k for k, v in variable_cols.items() if v in df_cleaned.columns}
        df_cleaned.rename(columns=col_rename_map, inplace=True)

        # Iterate through the variable columns (excluding '국가별') and clean the data
        for col in df_cleaned.columns:
            if col != '국가별':
                # Convert the data to string type to handle potential mixed data types
                df_cleaned[col] = df_cleaned[col].astype(str)

                # Remove non-numeric characters (keep digits, periods, and hyphens)
                df_cleaned[col] = df_cleaned[col].str.replace('[^0-9.-]', '', regex=True)

                # Convert to numeric, coercing errors to NaN
                df_cleaned[col] = pd.to_numeric(df_cleaned[col], errors='coerce')

        # Handle missing values by dropping rows with NaNs in the variable columns
        variable_column_names = [col for col in df_cleaned.columns if col != '국가별']
        df_cleaned.dropna(subset=variable_column_names, inplace=True)

        return df_cleaned

    except FileNotFoundError:
        st.error(f"Error: Data file not found")
        return pd.DataFrame() # Return an empty DataFrame on error
    except Exception as e:
        st.error(f"An error occurred during data loading and preprocessing: {e}")
        return pd.DataFrame() # Return an empty DataFrame on error



# Display the cleaned data and its info in the Streamlit app
if not df_cleaned.empty:
    st.header("Cleaned Data Preview")
    st.dataframe(df_cleaned.head())

    st.header("Data Information")
    # Redirect df.info() output to a string to display in Streamlit
    import io
    buffer = io.StringIO()
    df_cleaned.info(buf=buffer)
    s = buffer.getvalue()
    st.text(s)
else:
    st.warning("Data could not be loaded or is empty after cleaning.")

import streamlit as st
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# Add a section title for descriptive statistics
st.header("Descriptive Statistics")

# Select only numeric columns from the cleaned DataFrame
df_numeric = df_cleaned.select_dtypes(include=np.number)

# Calculate descriptive statistics for the numeric columns
descriptive_stats = df_numeric.describe()

# Display the descriptive statistics using st.dataframe()
st.dataframe(descriptive_stats)

# Add a section title for variable distribution visualization
st.header("Distribution of Variables")

# Iterate through the numeric columns and create visualizations
for col in df_numeric.columns:
    # Add a title for the current variable's visualization
    st.subheader(f"Distribution of {col}")

    # Create a figure with two subplots (histogram and box plot)
    fig, axes = plt.subplots(1, 2, figsize=(15, 5))

    # Plot Histogram
    sns.histplot(data=df_numeric, x=col, kde=True, ax=axes[0])
    axes[0].set_title(f'Distribution of {col}')
    axes[0].set_xlabel(col)
    axes[0].set_ylabel('Frequency')

    # Plot Box Plot
    sns.boxplot(data=df_numeric, x=col, ax=axes[1])
    axes[1].set_title(f'Box Plot of {col}')
    axes[1].set_xlabel(col)
    axes[1].set_ylabel('Value')

    plt.tight_layout()

    # Display the generated plot using st.pyplot()
    st.pyplot(fig)

    # Close the figure to free up memory
    plt.close(fig)

import streamlit as st
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# Add a section title for descriptive statistics
st.header("Descriptive Statistics")

# Check if df_cleaned is not empty and contains numeric columns
if not df_cleaned.empty:
    # Select only numeric columns from the cleaned DataFrame
    df_numeric = df_cleaned.select_dtypes(include=np.number)

    if not df_numeric.empty:
        # Calculate descriptive statistics for the numeric columns
        descriptive_stats = df_numeric.describe()

        # Display the descriptive statistics using st.dataframe()
        st.dataframe(descriptive_stats)

        # Add a section title for variable distribution visualization
        st.header("Distribution of Variables")

        # Iterate through the numeric columns and create visualizations
        for col in df_numeric.columns:
            # Add a title for the current variable's visualization
            st.subheader(f"Distribution of {col}")

            # Create a figure with two subplots (histogram and box plot)
            fig, axes = plt.subplots(1, 2, figsize=(15, 5))

            # Plot Histogram
            sns.histplot(data=df_numeric, x=col, kde=True, ax=axes[0])
            axes[0].set_title(f'Distribution of {col}')
            axes[0].set_xlabel(col)
            axes[0].set_ylabel('Frequency')

            # Plot Box Plot
            sns.boxplot(data=df_numeric, x=col, ax=axes[1])
            axes[1].set_title(f'Box Plot of {col}')
            axes[1].set_xlabel(col)
            axes[1].set_ylabel('Value')

            plt.tight_layout()

            # Display the generated plot using st.pyplot()
            st.pyplot(fig)

            # Close the figure to free up memory
            plt.close(fig)
    else:
        st.warning("No numeric columns found in the cleaned data to calculate descriptive statistics or visualize distributions.")
else:
    st.warning("Cleaned data is empty. Cannot perform descriptive statistics or visualize distributions.")

import streamlit as st
import statsmodels.formula.api as smf
import pandas as pd
import numpy as np

# Add a section title for regression analysis
st.header("Multiple Linear Regression Models")

# Ensure df_regression_renamed DataFrame exists and is not empty
# Assuming df_regression_renamed was created and populated in a previous step
if 'df_regression_renamed' in locals() and df_regression_renamed is not None and not df_regression_renamed.empty:

    # Model 1: log_GDP ~ log_GERD (simple regression)
    st.subheader("Model 1: Simple Regression")
    try:
        model_1_formula = 'Log_Real_GDP ~ Log_GERD'
        model_1 = smf.ols(model_1_formula, data=df_regression_renamed).fit()
        st.text(model_1.summary().as_text())
        st.markdown("Interpretation: Model 1 shows the direct relationship between log(GERD) and log(Real GDP).")
    except Exception as e:
        st.error(f"Error building Model 1: {e}")
        model_1 = None
    st.markdown("---") # Add a separator

    # Model 2: log_GDP ~ log_GERD + GDP_per_Capita + Population_Labor_Size (confounders)
    st.subheader("Model 2: Adding Confounders")
    try:
        # Check if confounder variables were successfully renamed and exist
        # Based on previous output, 'GDP_per_Capita' was found, 'Total Population' and 'Labor Force Size' were not.
        confounder_vars = ['GDP_per_Capita'] # Use the renamed column name
        confounder_vars_formula = ' + '.join([var for var in confounder_vars if var in df_regression_renamed.columns])

        if confounder_vars_formula:
            model_2_formula = f'Log_Real_GDP ~ Log_GERD + {confounder_vars_formula}'
            model_2 = smf.ols(model_2_formula, data=df_regression_renamed).fit()
            st.text(model_2.summary().as_text())
            st.markdown("Interpretation: Model 2 includes confounders to see their effect and the effect of log(GERD) after accounting for them.")
        else:
            st.warning("Confounder variables not found in the dataset. Skipping Model 2.")
            model_2 = None
    except Exception as e:
        st.error(f"Error building Model 2: {e}")
        model_2 = None
    st.markdown("---") # Add a separator

    # Model 3: log_GDP ~ log_GERD + Patents + R&D_Researchers + Hightech_Exports + Business_R&D_Personnel (mediators)
    st.subheader("Model 3: Adding Mediators")
    try:
        # Check if mediator variables were successfully renamed and exist
        # Based on previous output, these columns were renamed:
        # 'Resident Patent Applications' -> 'Resident_Patent_Applications'
        # 'Non-Resident Patent Applications' -> 'Non_Resident_Patent_Applications'
        # 'R&D Researchers per Million People' -> 'R_and_D_Researchers_per_Million_People' (was not found in previous step, exclude)
        # 'High-tech Export Share (% of Manufacturing exports)' -> 'Hightech_Export_Share' (was not found in previous step, exclude)
        # 'Business R&D Personnel (FTE)' -> 'Business_R_and_D_Personnel_FTE'

        mediator_vars = [
            'Resident_Patent_Applications',
            'Non_Resident_Patent_Applications',
            'Business_R_and_D_Personnel_FTE' # Use the renamed column name
            # Exclude 'R_and_D_Researchers_per_Million_People' and 'Hightech_Export_Share' as they were not definitively found
        ]
        mediator_vars_formula = ' + '.join([var for var in mediator_vars if var in df_regression_renamed.columns])

        # Also include confounders if they were found for Model 2
        all_vars_formula_model3 = 'Log_GERD'
        if confounder_vars_formula:
             all_vars_formula_model3 += ' + ' + confounder_vars_formula
        if mediator_vars_formula:
             all_vars_formula_model3 += ' + ' + mediator_vars_formula


        if 'Log_GERD' in df_regression_renamed.columns and (confounder_vars_formula or mediator_vars_formula):
            model_3_formula = f'Log_Real_GDP ~ {all_vars_formula_model3}'
            model_3 = smf.ols(model_3_formula, data=df_regression_renamed).fit()
            st.text(model_3.summary().as_text())
            st.markdown("Interpretation: Model 3 adds potential mediators to examine their influence and the change in the effect of log(GERD).")
        else:
             st.warning("Mediator variables not found in the dataset or necessary confounders missing. Skipping Model 3.")
             model_3 = None
    except Exception as e:
        st.error(f"Error building Model 3: {e}")
        model_3 = None
    st.markdown("---") # Add a separator


    # Model 4: log_GDP ~ log_GERD * GovFinanced_BERD + GDP_per_Capita + Population_Labor_Size (moderator interaction)
    st.subheader("Model 4: Adding Moderator Interaction")
    try:
        # Check if moderator and other necessary variables exist after renaming
        # Based on previous output:
        # 'Government-financed BERD (%)' -> 'GovFinanced_BERD_pct'
        moderator_var = 'GovFinanced_BERD_pct' # Use the renamed column name

        if moderator_var in df_regression_renamed.columns and confounder_vars_formula:
             # Construct the formula with interaction term using '*'
             model_4_formula = f'Log_Real_GDP ~ Log_GERD * {moderator_var} + {confounder_vars_formula}'
             model_4 = smf.ols(model_4_formula, data=df_regression_renamed).fit()
             st.text(model_4.summary().as_text())
             st.markdown(f"Interpretation: Model 4 includes an interaction term between log(GERD) and {moderator_var} to test for moderation.")
        else:
            st.warning("Moderator variable or confounders not found. Skipping Model 4.")
            model_4 = None
    except Exception as e:
        st.error(f"Error building Model 4: {e}")
        model_4 = None
    st.markdown("---") # Add a separator

else:
    st.warning("Cleaned and renamed DataFrame 'df_regression_renamed' not found or is empty. Cannot build regression models.")

import streamlit as st
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import statsmodels.formula.api as smf
import pandas as pd
import io

# Set the page configuration
st.set_page_config(page_title="Real GDP and R&D Research Analysis", layout="wide")

# Add a main title to the app
st.title("Analysis of Real GDP and R&D Research")

# Add a sidebar with a brief description
st.sidebar.header("About")
st.sidebar.write(
    "This application analyzes the relationship between Real GDP and R&D research, "
    "including simple linear regression, correlation analysis, and multiple linear regression models."
)

@st.cache_data
def load_and_preprocess_data():
    """
    Loads the dataset from the local directory (same folder as the Streamlit app)
    and preprocesses it for analysis.

    Returns:
        pd.DataFrame: The preprocessed DataFrame.
    """
    try:
        # Load dataset directly from the same directory as your Streamlit app
        df = pd.read_csv("ACDT final data set22.xlsx - 데이터 (1).csv", encoding="utf-8")

        # Clean all columns except the first one ('국가별') and exclude the first two rows
        for col in df.columns[1:]:
            # Select data from the third row onwards and convert to string type
            # Use .loc for clearer indexing and to avoid SettingWithCopyWarning
            df.loc[2:, col] = df.loc[2:, col].astype(str).str.replace('[^0-9.-]', '', regex=True)
            df.loc[2:, col] = pd.to_numeric(df.loc[2:, col], errors='coerce')

        # Identify the columns for the specified variables
        variable_cols = {}

        # Define a dictionary of keywords to look for, mapping them to the desired variable names
        keywords = {
            'Resident Patent Applications': 'Resident Patent Applications',
            'Non-Resident Patent Applications': 'Non-Resident Patent Applications',
            'Number of R&D Researcher': 'Number of R&D Researcher (per million people)',
            'High-Tech Export Share': 'High-Tech Export Share (% of Manufacturing exports)',
            'Business R&D Personnel (FTE)': 'Business R&D Personnel (FTE)',
            'Real GDP': 'Real GDP',
            'Total Population': 'Total Population',
            'Labor Force': 'Labor Force Size',
            'Government-Financed BERD (%)': 'Share of Government-Financed BERD (%)',
            'Business-Financed BERD (%)': 'Share of Business-Financed BERD (%)',
            'Business R&D Personnel (FTE) per 1,000 Employed': 'Business R&D Personnel (FTE) per 1,000 Employed'
        }

        # Iterate through columns to find matches based on keywords in the first row content
        for col in df.columns:
            first_row_value = df.iloc[0][col]
            if isinstance(first_row_value, str):
                # Check for each keyword in the first row value
                for keyword, var_name in keywords.items():
                    if keyword in first_row_value:
                        # For 'Real GDP', prioritize later years
                        if var_name == 'Real GDP':
                            year = str(col).split('.')[0] if '.' in str(col) else str(col)
                            try:
                                year_int = int(year)
                                # Keep the latest identified GDP year if multiple are found
                                if var_name not in variable_cols or (isinstance(variable_cols[var_name], str) and int(variable_cols[var_name].split('.')[0] if '.' in variable_cols[var_name] else variable_cols[var_name]) < year_int):
                                    variable_cols[var_name] = col
                            except ValueError:
                                # Handle cases where the column name before the dot is not a year
                                pass
                        # For other variables, assign the first column found containing the keyword
                        elif var_name not in variable_cols:
                            variable_cols[var_name] = col


        # Create a new DataFrame with the '국가별' column and the identified variable columns
        # Ensure all identified columns are actually present in the original dataframe before selection
        selected_cols = ['국가별'] + [col for col in variable_cols.values() if col in df.columns]
        df_cleaned = df.loc[:, selected_cols].copy()

        # Remove the first two rows which contain header information
        df_cleaned = df_cleaned.iloc[2:].copy()

        # Rename columns to be more descriptive using the keys from variable_cols
        # Create a mapping from the original column names to the desired variable names
        col_rename_map = {v: k for k, v in variable_cols.items() if v in df_cleaned.columns}
        df_cleaned.rename(columns=col_rename_map, inplace=True)

        # Iterate through the variable columns (excluding '국가별') and clean the data
        for col in df_cleaned.columns:
            if col != '국가별':
                # Convert the data to string type to handle potential mixed data types
                df_cleaned[col] = df_cleaned[col].astype(str)

                # Remove non-numeric characters (keep digits, periods, and hyphens)
                df_cleaned[col] = df_cleaned[col].str.replace('[^0-9.-]', '', regex=True)

                # Convert to numeric, coercing errors to NaN
                df_cleaned[col] = pd.to_numeric(df_cleaned[col], errors='coerce')

        # Handle missing values by dropping rows with NaNs in the variable columns
        variable_column_names = [col for col in df_cleaned.columns if col != '국가별']
        df_cleaned.dropna(subset=variable_column_names, inplace=True)

        return df_cleaned

    except FileNotFoundError:
        st.error(f"Error: Data file not found")
        return pd.DataFrame() # Return an empty DataFrame on error
    except Exception as e:
        st.error(f"An error occurred during data loading and preprocessing: {e}")
        return pd.DataFrame() # Return an empty DataFrame on error


# Display the cleaned data and its info in the Streamlit app
if not df_cleaned.empty:
    st.header("Cleaned Data Preview")
    st.dataframe(df_cleaned.head())

    st.header("Data Information")
    # Redirect df.info() output to a string to display in Streamlit
    buffer = io.StringIO()
    df_cleaned.info(buf=buffer)
    s = buffer.getvalue()
    st.text(s)

    # Add section for Descriptive Statistics and Visualizations
    st.header("Descriptive Statistics and Variable Distributions")

    # Add markdown text for Descriptive Statistics
    st.markdown("""
    ## Descriptive statistics

    mean, median, standard deviation, etc. for each of the cleaned variables.
    """)

    # Select only numeric columns from the cleaned DataFrame
    df_numeric = df_cleaned.select_dtypes(include=np.number)

    if not df_numeric.empty:
        # Calculate descriptive statistics for the numeric columns
        descriptive_stats = df_numeric.describe()

        # Display the descriptive statistics using st.dataframe()
        st.dataframe(descriptive_stats)

        # Add markdown text for Distribution of Confounder, Moderater and Mediater
        st.markdown("""
        # Distribution of Confounder, Moderater and Mediater
        """)

        # Iterate through the numeric columns and create visualizations
        for col in df_numeric.columns:
            # Add a title for the current variable's visualization
            st.subheader(f"Distribution of {col}")

            # Create a figure with two subplots (histogram and box plot)
            fig, axes = plt.subplots(1, 2, figsize=(15, 5))

            # Plot Histogram
            sns.histplot(data=df_numeric, x=col, kde=True, ax=axes[0])
            axes[0].set_title(f'Distribution of {col}')
            axes[0].set_xlabel(col)
            axes[0].set_ylabel('Frequency')

            # Plot Box Plot
            sns.boxplot(data=df_numeric, x=col, ax=axes[1])
            axes[1].set_title(f'Box Plot of {col}')
            axes[1].set_xlabel(col)
            axes[1].set_ylabel('Value')

            plt.tight_layout()

            # Display the generated plot using st.pyplot()
            st.pyplot(fig)

            # Close the figure to free up memory
            plt.close(fig)
    else:
        st.warning("No numeric columns found in the cleaned data to calculate descriptive statistics or visualize distributions.")

    # Add section for Correlation Analysis
    st.header("Correlation Analysis")

    # Add markdown text for Correlation between datasets
    st.markdown("""
    # Correlation between datasets
    """)

    if not df_numeric.empty:
        # Calculate the correlation matrix
        correlation_matrix = df_numeric.corr()

        # Create a heatmap of the correlation matrix
        fig, ax = plt.subplots(figsize=(12, 10))
        sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=.5, ax=ax)
        plt.title('Correlation Matrix of Socio-Economic Variables')

        # Display the generated plot using st.pyplot()
        st.pyplot(fig)
        plt.close(fig)
    else:
        st.warning("No numeric data available to compute correlation matrix.")

    # Add section for Regression Models
    st.header("Multiple Linear Regression Models")

    # Add markdown text for Building Multiple Linear Regression Models
    st.markdown("""
    ## 4. Building Multiple Linear Regression Models
    Using `statsmodels.formula.api.ols`, build the four specified regression models and print their summaries.
    """)

    # Ensure df_regression_renamed DataFrame exists and is not empty
    # This part assumes df_regression_renamed is prepared with log transformations and renamed columns
    # Re-create df_regression_renamed with log transformations for this section
    df_regression = df.copy()
    df_regression = df_regression.iloc[2:].copy()

    regression_keywords = {
        'Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)': 'Real GDP',
        'Gross Domestic Expenditure on R&D (GERD) (current PPP USD)': 'GERD',
        'Resident Patent Applications': 'Resident Patent Applications',
        'Non-Resident Patent Applications': 'Non-Resident Patent Applications',
        'Number of R&D Researcher (per million people)': 'R&D Researchers per Million People',
        'High-Tech Export Share (as % of Manufacturing exports)': 'High-tech Export Share (% of Manufactured Exports)',
        'Business R&D Personnel (FTE)': 'Business R&D Personnel (FTE)',
        'GDP per Capita': 'GDP per Capita',
        'Total Population': 'Total Population',
        'Labor Force': 'Labor Force Size',
        'Share of Government-Financed BERD (%)': 'Government-financed BERD (%)',
        'Share of Business-Financed BERD (%)': 'Business-financed BERD (%)',
        'Business R&D Personnel (FTE) per 1,000 Employed': 'R&D Personnel per 1,000 Employees'
    }

    regression_cols = {}
    for col in df_regression.columns:
        first_row_value = df.iloc[0][col]
        if isinstance(first_row_value, str):
             for keyword, var_name in regression_keywords.items():
                if keyword in first_row_value:
                    if keyword in ['Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)', 'Gross Domestic Expenditure on R&D (GERD) (current PPP USD)']:
                        if var_name not in regression_cols:
                            regression_cols[var_name] = col
                    elif var_name not in regression_cols:
                         regression_cols[var_name] = col

    selected_regression_cols = ['국가별'] + [col for col in regression_cols.values() if col in df_regression.columns]
    df_regression = df_regression.loc[:, selected_regression_cols].copy()

    col_rename_map_regression = {v: k for k, v in regression_cols.items()}
    df_regression_renamed = df_regression.rename(columns=col_rename_map_regression)

    for col in df_regression_renamed.columns:
        if col != '국가별':
            df_regression_renamed[col] = df_regression_renamed[col].astype(str).str.replace('[^0-9.-]', '', regex=True)
            df_regression_renamed[col] = pd.to_numeric(df_regression_renamed[col], errors='coerce')

    df_regression_renamed.dropna(subset=[col for col in df_regression_renamed.columns if col != '국가별'], inplace=True)

    if 'Real GDP' in df_regression_renamed.columns:
        df_regression_renamed['Log_Real_GDP'] = np.log(df_regression_renamed['Real GDP'] + 1e-9)
    else:
        st.warning("Warning: 'Real GDP' column not found for log transformation.")

    if 'GERD' in df_regression_renamed.columns:
        df_regression_renamed['Log_GERD'] = np.log(df_regression_renamed['GERD'] + 1e-9)
    else:
         st.warning("Warning: 'GERD' column not found for log transformation.")


    if not df_regression_renamed.empty and 'Log_Real_GDP' in df_regression_renamed.columns and 'Log_GERD' in df_regression_renamed.columns:

        # Model 1: log_GDP ~ log_GERD (simple regression)
        st.subheader("Model 1: Simple Regression")
        try:
            model_1_formula = 'Log_Real_GDP ~ Log_GERD'
            model_1 = smf.ols(model_1_formula, data=df_regression_renamed).fit()
            st.text(model_1.summary().as_text())
            st.markdown("Interpretation: Model 1 estimates the simple linear relationship between Log(GERD) and Log(Real GDP). The regression coefficient (β₁) is positive and statistically significant (p < 0.05), indicating that as GERD increases, Real GDP tends to increase correspondingly. The Adjusted R² is approximately 0.494, suggesting that Log(GERD) explains about 49.4% of the variance in Log(Real GDP). Thus, GERD can be considered a major explanatory factor contributing to economic growth.")
        except Exception as e:
            st.error(f"Error building Model 1: {e}")
            model_1 = None
        st.markdown("---")

        # Model 2: log_GDP ~ log_GERD + GDP_per_Capita + Population_Labor_Size (confounders)
        st.subheader("Model 2: Adding Confounders")
        try:
            confounder_vars = ['GDP_per_Capita']
            confounder_vars_formula = ' + '.join([var for var in confounder_vars if var in df_regression_renamed.columns])

            if confounder_vars_formula:
                model_2_formula = f'Log_Real_GDP ~ Log_GERD + {confounder_vars_formula}'
                model_2 = smf.ols(model_2_formula, data=df_regression_renamed).fit()
                st.text(model_2.summary().as_text())
                st.markdown("Interpretation: Model 2 adds GDP per Capita as a confounding variable to the basic model. The variables Total Population and Labor Force Size were unavailable in the dataset and therefore excluded. The analysis shows that GDP per Capita is statistically insignificant (p = 0.491), indicating that it does not have a meaningful impact on Real GDP in this model. Meanwhile, the coefficient for Log(GERD) remains statistically significant (p = 0.003), suggesting that the positive relationship between GERD and Real GDP persists even after controlling for GDP per Capita. The Adjusted R² slightly decreases to 0.476, possibly due to the added confounder not substantially improving explanatory power, or as a result of penalization for increased model complexity.")
            else:
                st.warning("Confounder variables not found in the dataset. Skipping Model 2.")
                model_2 = None
        except Exception as e:
            st.error(f"Error building Model 2: {e}")
            model_2 = None
        st.markdown("---")

        # Model 3: log_GDP ~ log_GERD + Patents + R&D_Researchers + Hightech_Exports + Business_R&D_Personnel (mediators)
        st.subheader("Model 3: Adding Mediators")
        try:
            mediator_vars = [
                'Resident_Patent_Applications',
                'Non_Resident_Patent_Applications',
                'Business_R_and_D_Personnel_FTE'
            ]
            mediator_vars_formula = ' + '.join([var for var in mediator_vars if var in df_regression_renamed.columns])

            all_vars_formula_model3 = 'Log_GERD'
            if confounder_vars_formula:
                 all_vars_formula_model3 += ' + ' + confounder_vars_formula
            if mediator_vars_formula:
                 all_vars_formula_model3 += ' + ' + mediator_vars_formula


            if 'Log_GERD' in df_regression_renamed.columns and (confounder_vars_formula or mediator_vars_formula):
                model_3_formula = f'Log_Real_GDP ~ {all_vars_formula_model3}'
                model_3 = smf.ols(model_3_formula, data=df_regression_renamed).fit()
                st.text(model_3.summary().as_text())
                st.markdown("Interpretation: Model 3 includes mediating variables — Resident / Non-resident Patent Applications, R&D Researchers per Million People, High-tech Export Share (% of Manufactured Exports), and Business R&D Personnel (FTE) — in addition to Log(GERD) and GDP per Capita. The coefficient for Log(GERD) slightly decreases (β ≈ 0.380) but remains statistically significant (p = 0.020). This suggests that part of the relationship between GERD and Real GDP may be mediated by innovation, human capital, or technological diffusion. Among the mediators, Resident Patent Applications shows a near-significant result (p = 0.053), implying that domestic patent activity might partially explain how GERD affects Real GDP. Other mediators are not statistically significant. The Adjusted R² increases substantially to approximately 0.700, indicating that including mediating variables substantially improves the model’s explanatory power.")
            else:
                 st.warning("Mediator variables not found in the dataset or necessary confounders missing. Skipping Model 3.")
                 model_3 = None
        except Exception as e:
            st.error(f"Error building Model 3: {e}")
            model_3 = None
        st.markdown("---")


        # Model 4: log_GDP ~ log_GERD * GovFinanced_BERD + GDP_per_Capita + Population_Labor_Size (moderator interaction)
        st.subheader("Model 4: Adding Moderator Interaction")
        try:
            moderator_var = 'GovFinanced_BERD_pct'

            if moderator_var in df_regression_renamed.columns and confounder_vars_formula:
                 model_4_formula = f'Log_Real_GDP ~ Log_GERD * {moderator_var} + {confounder_vars_formula}'
                 model_4 = smf.ols(model_4_formula, data=df_regression_renamed).fit()
                 st.text(model_4.summary().as_text())
                 st.markdown("Interpretation: Model 4 adds an interaction term between Log(GERD) and Government-financed BERD (%) to test for a moderating effect. The interaction term (Log_GERD × GovFinanced_BERD_pct) is highly significant (p = 0.001), suggesting that the effect of GERD on Real GDP varies depending on the proportion of government-financed R&D expenditure. The coefficient for the interaction term (β = -0.0895) is negative, implying that as the share of government financing in R&D increases, the positive impact of GERD on Real GDP tends to weaken. The coefficient for Log(GERD) itself increases (β ≈ 1.070) compared to Model 3 and remains highly significant (p < 0.001). This represents the effect of GERD on Real GDP when the moderator (Government-financed BERD) equals zero. Given the significant interaction, the effect size of GERD should be interpreted conditionally on the level of government financing. The Adjusted R² further increases to approximately 0.775, showing that Model 4 provides the best overall explanatory power.")
            else:
                st.warning("Moderator variable or confounders not found. Skipping Model 4.")
                model_4 = None
        except Exception as e:
            st.error(f"Error building Model 4: {e}")
            model_4 = None
        st.markdown("---")

        # Generate Actual vs. Predicted Plot for Model 4
        st.header("Actual vs. Predicted Values Plot for Model 4")
        st.markdown("Generate a scatter plot of the actual values of the dependent variable (Log_Real_GDP) against the values predicted by Model 4, with a line of perfect fit.")

        if 'model_4' in locals() and model_4 is not None:
             try:
                actual_gdp = df_regression_renamed['Log_Real_GDP']
                predicted_gdp = model_4.predict(df_regression_renamed)

                fig, ax = plt.subplots(figsize=(8, 6))
                sns.scatterplot(x=predicted_gdp, y=actual_gdp, alpha=0.6, ax=ax)
                ax.plot([actual_gdp.min(), actual_gdp.max()], [actual_gdp.min(), actual_gdp.max()], color='red', linestyle='--', lw=2, label='Perfect Fit')
                ax.set_title('Actual vs. Predicted Log(Real GDP) (Model 4)')
                ax.set_xlabel('Predicted Log(Real GDP)')
                ax.set_ylabel('Actual Log(Real GDP)')
                ax.legend()
                ax.grid(True)
                st.pyplot(fig)
                plt.close(fig)
             except Exception as e:
                 st.error(f"Error generating Actual vs. Predicted plot for Model 4: {e}")
        else:
             st.warning("Model 4 was not successfully built. Cannot generate actual vs. predicted values plot.")

        # Create Comparison Table
        st.header("Regression Model Comparison")
        st.markdown("Generate a table comparing the Adjusted R² and the coefficient (β) of log(GERD) across all four models.")

        results_dict = {}
        if 'model_1' in locals() and model_1:
            results_dict['Model 1'] = {
                'Adjusted R-squared': model_1.rsquared_adj,
                'Beta (Log_GERD)': model_1.params.get('Log_GERD', 'N/A')
            }
        if 'model_2' in locals() and model_2:
            results_dict['Model 2'] = {
                'Adjusted R-squared': model_2.rsquared_adj,
                'Beta (Log_GERD)': model_2.params.get('Log_GERD', 'N/A')
            }
        if 'model_3' in locals() and model_3:
            results_dict['Model 3'] = {
                'Adjusted R-squared': model_3.rsquared_adj,
                'Beta (Log_GERD)': model_3.params.get('Log_GERD', 'N/A')
            }
        if 'model_4' in locals() and model_4:
             results_dict['Model 4'] = {
                'Adjusted R-squared': model_4.rsquared_adj,
                'Beta (Log_GERD)': model_4.params.get('Log_GERD', 'N/A')
            }

        if results_dict:
            comparison_table = pd.DataFrame.from_dict(results_dict, orient='index')
            st.dataframe(comparison_table)
        else:
            st.warning("No models were successfully built to create a comparison table.")

        # Generate Visualizations
        st.header("Regression Analysis Visualizations")
        st.markdown("""
        Generate clear visualizations using Matplotlib/Seaborn:
        - Scatter plot of log(GERD) vs. log(GDP) with regression line.
        - Histogram of residuals for the final model (Model 4).
        - Bar chart comparing Adjusted R² across models.
        """)

        # Scatter plot of log(GERD) vs. log(GDP) with regression line (already generated above, but can be repeated here for clarity)
        st.subheader("Scatter Plot of Log(GERD) vs Log(Real GDP)")
        fig, ax = plt.subplots(figsize=(10, 6))
        sns.regplot(data=df_regression_renamed, x='Log_GERD', y='Log_Real_GDP', scatter_kws={'alpha': 0.6}, ax=ax)
        ax.set_title('Scatter Plot of Log(GERD) vs Log(Real GDP)')
        ax.set_xlabel('Log of Gross Domestic Expenditure on R&D (GERD)')
        ax.set_ylabel('Log of Real GDP')
        ax.grid(True)
        st.pyplot(fig)
        plt.close(fig)

        # Histogram of residuals for the final model (Model 4)
        st.subheader("Histogram of Residuals for Model 4")
        if 'model_4' in locals() and model_4:
            try:
                residuals = model_4.resid
                fig, ax = plt.subplots(figsize=(8, 6))
                sns.histplot(residuals, kde=True, ax=ax)
                ax.set_title('Histogram of Residuals for Model 4')
                ax.set_xlabel('Residuals')
                ax.set_ylabel('Frequency')
                st.pyplot(fig)
                plt.close(fig)
            except Exception as e:
                st.error(f"Error generating residuals histogram for Model 4: {e}")
        else:
            st.warning("Model 4 was not successfully built. Skipping residuals histogram.")

        # Bar chart comparing Adjusted R² across models
        st.subheader("Comparison of Adjusted R-squared Across Regression Models")
        if results_dict:
            models = list(results_dict.keys())
            adjusted_r_squared_values = [results_dict[model]['Adjusted R-squared'] for model in models]

            fig, ax = plt.subplots(figsize=(10, 6))
            sns.barplot(x=models, y=adjusted_r_squared_values, palette='viridis', ax=ax)
            ax.set_title('Comparison of Adjusted R-squared Across Regression Models')
            ax.set_xlabel('Regression Model')
            ax.set_ylabel('Adjusted R-squared')
            ax.set_ylim(0, max(adjusted_r_squared_values) * 1.1)
            st.pyplot(fig)
            plt.close(fig)
        else:
            st.warning("No model results available to create Adjusted R-squared bar chart.")

        # Summarize Findings
        st.header("Summary of Findings")
        st.markdown("""
        This analysis was conducted to examine the causal impact of Gross Domestic Expenditure on R&D (GERD) on Real GDP.
        Four regression models were sequentially estimated, gradually adding confounding, mediating, and moderating variables to identify the underlying causal structure.
        The changes in regression coefficients, statistical significance, and explanatory power (Adjusted R²) were analyzed to interpret the causal relationships.

        # Model 1: Simple Linear Regression (Log_Real_GDP ~ Log_GERD)

        Model 1 estimates the simple linear relationship between Log(GERD) and Log(Real GDP).
        The regression coefficient (β₁) is positive and statistically significant (p < 0.05), indicating that as GERD increases, Real GDP tends to increase correspondingly.
        The Adjusted R² is approximately 0.494, suggesting that Log(GERD) explains about 49.4% of the variance in Log(Real GDP).
        Thus, GERD can be considered a major explanatory factor contributing to economic growth.

        # Model 2: Adding a Confounding Variable (Log_Real_GDP ~ Log_GERD + GDP_per_Capita)

        Model 2 adds GDP per Capita as a confounding variable to the basic model.
        The variables Total Population and Labor Force Size were unavailable in the dataset and therefore excluded.

        The analysis shows that GDP per Capita is statistically insignificant (p = 0.491),
        indicating that it does not have a meaningful impact on Real GDP in this model.
        Meanwhile, the coefficient for Log(GERD) remains statistically significant (p = 0.003),
        suggesting that the positive relationship between GERD and Real GDP persists even after controlling for GDP per Capita.

        The Adjusted R² slightly decreases to 0.476, possibly due to the added confounder not substantially improving explanatory power,
        or as a result of penalization for increased model complexity.

        # Model 3: Adding Mediating Variables (Log_Real_GDP ~ Log_GERD + GDP_per_Capita + Innovation Variables)

        Model 3 includes mediating variables — Resident / Non-resident Patent Applications, R&D Researchers per Million People,
        High-tech Export Share (% of Manufactured Exports), and Business R&D Personnel (FTE) — in addition to Log(GERD) and GDP per Capita.

        The coefficient for Log(GERD) slightly decreases (β ≈ 0.380) but remains statistically significant (p = 0.020).
        This suggests that part of the relationship between GERD and Real GDP may be mediated by innovation, human capital, or technological diffusion.

        Among the mediators, Resident Patent Applications shows a near-significant result (p = 0.053), implying that domestic patent activity might partially explain how GERD affects Real GDP.
        Other mediators are not statistically significant.
        The Adjusted R² increases substantially to approximately 0.700, indicating that including mediating variables substantially improves the model’s explanatory power.

        # Model 4: Adding a Moderating Effect (Log_Real_GDP ~ Log_GERD * GovFinanced_BERD_pct + Mediators + Confounder)

        Model 4 adds an interaction term between Log(GERD) and Government-financed BERD (%) to test for a moderating effect.

        The interaction term (Log_GERD × GovFinanced_BERD_pct) is highly significant (p = 0.001),
        suggesting that the effect of GERD on Real GDP varies depending on the proportion of government-financed R&D expenditure.
        The coefficient for the interaction term (β = -0.0895) is negative, implying that as the share of government financing in R&D increases,
        the positive impact of GERD on Real GDP tends to weaken.

        The coefficient for Log(GERD) itself increases (β ≈ 1.070) compared to Model 3 and remains highly significant (p < 0.001).
        This represents the effect of GERD on Real GDP when the moderator (Government-financed BERD) equals zero.
        Given the significant interaction, the effect size of GERD should be interpreted conditionally on the level of government financing.
        The Adjusted R² further increases to approximately 0.775, showing that Model 4 provides the best overall explanatory power.

        # Key Findings and Implications

        1. Relationship between GERD and Real GDP
        Across all models, Log(GERD) consistently shows a statistically significant and positive relationship with Real GDP.
        This provides empirical support for the notion that R&D investment is a key driver of economic growth.
        2. Mediating Effects
        Resident Patent Applications partially mediate the relationship between GERD and Real GDP,
        suggesting that R&D expenditure contributes to economic growth indirectly through innovation activities.
        Other mediators were not statistically significant, indicating that the mediating strength may be limited.
        3. Moderating Effects
        Government-financed BERD (%) moderates the relationship between GERD and Real GDP.
        The positive effect of GERD on GDP tends to weaken as the proportion of government-financed R&D increases.
        This finding implies that the efficiency of R&D investment may vary depending on the balance between public and private funding structures.
        4. Model Fit Comparison
        The Adjusted R² values steadily improve as the models expand (0.494 → 0.476 → 0.700 → 0.775).
        This indicates that incorporating mediating and moderating variables yields a more comprehensive and accurate explanation of Real GDP fluctuations compared to a simple model.

        # Conclusion

        The multiple regression analysis demonstrates that GERD exerts a consistently positive impact on Real GDP.
        However, this effect operates through both indirect innovation pathways (e.g., patent applications)
        and conditional moderation effects depending on the level of government-financed R&D.

        The results reveal that the relationship is not a simple “R&D → Growth” linear link,
        but rather a multi-stage causal chain — “R&D → Innovation → Productivity → Growth” —
        that is further conditioned by policy environments such as government funding ratios.

        Therefore, future R&D policies should focus not merely on expanding total expenditure,
        but also on optimizing the qualitative composition of investment —
        balancing government and private funding, strengthening human capital, and promoting innovation output efficiency.
        """)

else:
    st.warning("Data could not be loaded or is empty after cleaning.")

"""## Summary:

### Data Analysis Key Findings

*   The analysis successfully loaded and preprocessed the data, including cleaning non-numeric characters and handling missing values.
*   Descriptive statistics and variable distributions (histograms and box plots) were generated and displayed for the numeric columns.
*   A correlation matrix heatmap was created to visualize the relationships between numeric variables.
*   Four sequential multiple linear regression models were built to examine the relationship between Real GDP and GERD, incorporating potential confounders, mediators, and moderators.
*   Model 1 showed a significant positive relationship between Log(GERD) and Log(Real GDP), with Log(GERD) explaining about 49.4% of the variance in Log(Real GDP).
*   Model 2, including GDP per Capita as a confounder, found GDP per Capita to be insignificant, while the positive effect of Log(GERD) remained significant. The Adjusted R² slightly decreased to 0.476.
*   Model 3 introduced mediating variables (patent applications, R\&D personnel) and showed that the positive effect of Log(GERD) on Log(Real GDP) slightly decreased but remained significant (p = 0.020), suggesting partial mediation. Resident Patent Applications showed near-significance (p = 0.053). The Adjusted R² increased substantially to 0.700.
*   Model 4 included an interaction term between Log(GERD) and Government-financed BERD (%). The interaction term was highly significant (p = 0.001) and negative, indicating that the positive impact of GERD on Real GDP weakens as the share of government financing increases. The Adjusted R² further increased to 0.775, indicating the best model fit.
*   Visualizations including a scatter plot of actual vs. predicted Log(Real GDP) for Model 4, a histogram of residuals for Model 4, and a bar chart comparing Adjusted R² across models were generated.

### Insights or Next Steps

*   The analysis strongly supports the causal link between R\&D investment (GERD) and economic growth (Real GDP), but highlights that this relationship is complex, involving potential indirect pathways through innovation and being influenced by the structure of R\&D funding (government vs. business).
*   Future research could explore the specific mechanisms through which government financing of BERD might moderate the relationship between GERD and Real GDP. This could involve investigating factors like the types of projects government funds, the efficiency of public sector R\&D institutions, or the bureaucratic hurdles associated with government grants.

"""