# -*- coding: utf-8 -*-
"""acdt_g31

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F5fm0D95_3CLMpKv3LVVCJCWz4Vwmcv_
"""

import warnings
warnings.filterwarnings("ignore")

import streamlit as st
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import statsmodels.formula.api as smf
from difflib import get_close_matches

st.set_page_config(page_title="ACDT G31 – GERD(2020) → GDP(2023)", layout="wide")

DATA_FILE = "ACDT_final_dataset.csv"

GDP_NAME  = "Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)"
GERD_NAME = "Gross Domestic Expenditure on R&D (GERD) (current PPP USD)"
MEDIATOR_NAMES = [
    "Resident Patent Applications",
    "Non-Resident Patent Applications",
    "Business R&D Personnel (FTE)",
]
CONFOUNDER_NAMES = [
    "GDP per Capita",
    "Labor Force Size",
]
MODERATOR_NAMES  = [
    "Share of Government-Financed BERD (%)",
    "Share of Business-Financed BERD (%)",
]

X_YEAR = 2020
Y_YEAR = 2023

@st.cache_data
def read_and_clean(path: str, debug=False):
    raw, last_err = None, None
    for enc in ('utf-8-sig', 'cp949'):
        try:
            raw = pd.read_csv(path, encoding=enc, header=None, engine='python')
            break
        except Exception as e:
            last_err = e
    if raw is None:
        raise RuntimeError(f"CSV 읽기 실패: {last_err}")

    if debug:
        st.subheader("RAW CSV 확인")
        st.write(f"shape: {raw.shape}")
        st.write("row0 (year):", raw.iloc[0, :].astype(str).tolist()[:30])
        st.write("row1 (indicator):", raw.iloc[1, :].astype(str).tolist()[:30])
        st.dataframe(raw.head(6))
        st.stop()

    if raw.shape[1] == 1:
        sample = "\n".join(raw.iloc[:5, 0].astype(str).tolist())
        sep = next((s for s in [',', '\t', ';', '|'] if s in sample), None)
        if sep is not None:
            col0 = raw.iloc[:, 0].astype(str)
            raw = col0.str.split(sep, expand=True)

    # 반드시 1차원 Series로 값을 추출해야 .str 쓸 수 있다
    years = raw.iloc[0, :].astype(str).str.strip()
    indicators = raw.iloc[1, :].astype(str).str.strip()

    df = raw.iloc[2:, :].copy()
    df.columns = pd.MultiIndex.from_arrays([indicators, years], names=['Indicator', 'Year'])

    def clean_col(col):
        col = col.astype(str).str.replace(',', '').str.replace(r'[^0-9.eE+\-]', '', regex=True)
        return pd.to_numeric(col, errors='coerce')

    for col in df.columns:
        df[col] = clean_col(df[col])

    # 연도 int 변환 시도
    new_cols = []
    for ind, yr in df.columns:
        try:
            yr_int = int(float(yr))
        except Exception:
            yr_int = yr
        new_cols.append((ind, yr_int))
    df.columns = pd.MultiIndex.from_tuples(new_cols)

    # 중복 컬럼 평균 처리
    if df.columns.duplicated(keep=False).any():
        df = df.T.groupby(level=[0,1]).mean(numeric_only=True).T
        df.index = pd.RangeIndex(len(df))

    return df

def get_series(df, indicator, year):
    lvl0 = df.columns.get_level_values(0)
    if indicator in set(lvl0):
        sub = df.loc[:, indicator]
        cols = list(sub.columns) if hasattr(sub, 'columns') else []
        if year in cols:
            return df.loc[:, (indicator, year)]
    return pd.Series([np.nan]*len(df), index=df.index)

def build_regression_data(df):
    out = pd.DataFrame(index=df.index)
    out['GERD'] = get_series(df, GERD_NAME, X_YEAR)
    out['GDP'] = get_series(df, GDP_NAME, Y_YEAR)
    for v in CONFOUNDER_NAMES + MEDIATOR_NAMES + MODERATOR_NAMES:
        out[v] = get_series(df, v, Y_YEAR)
    out['ln_GERD'] = np.log(out['GERD'].replace(0, np.nan))
    out['ln_GDP'] = np.log(out['GDP'].replace(0, np.nan))
    out = out.dropna(subset=['ln_GERD', 'ln_GDP']).reset_index(drop=True)
    return out

def run_models(df):
    confs = [c for c in CONFOUNDER_NAMES if c in df.columns]
    meds = [m for m in MEDIATOR_NAMES if m in df.columns]
    mods = [m for m in MODERATOR_NAMES if m in df.columns]

    m1 = smf.ols("ln_GDP ~ ln_GERD", data=df).fit()
    rhs2 = "ln_GERD" + ((" + " + " + ".join(f'Q("{c}")' for c in confs)) if confs else "")
    m2 = smf.ols(f"ln_GDP ~ {rhs2}", data=df).fit()
    rhs3 = rhs2 + ((" + " + " + ".join(f'Q("{m}")' for m in meds)) if meds else "")
    m3 = smf.ols(f"ln_GDP ~ {rhs3}", data=df).fit()
    inter = " + ".join(f'ln_GERD * Q("{mo}")' for mo in mods) if mods else ""
    rhs4 = rhs3 if not inter else f"{rhs3} + {inter}"
    m4 = smf.ols(f"ln_GDP ~ {rhs4}", data=df).fit()

    def pick_stats(mod, key="ln_GERD"):
        return mod.params.get(key, np.nan), mod.pvalues.get(key, np.nan), mod.rsquared_adj

    rows = []
    for label, mod in [("M1", m1), ("M2", m2), ("M3", m3), ("M4", m4)]:
        beta, pval, adjr2 = pick_stats(mod)
        rows.append([label, beta, pval, adjr2])
    summary_df = pd.DataFrame(rows, columns=["Model", "Beta", "p-value", "Adj R2"]).round(4)
    return {"M1": m1, "M2": m2, "M3": m3, "M4": m4}, summary_df

# Streamlit UI
st.title("ACDT G31 – GERD(2020) → GDP(2023)")

debug_mode = st.sidebar.checkbox("CSV 원시 헤더 출력 후 중단", False)

try:
    df_multi = read_and_clean(DATA_FILE, debug=debug_mode)
except Exception as e:
    st.error(f"데이터 로딩 실패: {e}")
    st.stop()

if debug_mode:
    st.info("디버그 모드 중지 후 앱 재실행하세요.")
    st.stop()

available_indicators = sorted(set(df_multi.columns.get_level_values(0)))
required = [GDP_NAME, GERD_NAME] + MEDIATOR_NAMES + CONFOUNDER_NAMES + MODERATOR_NAMES
missing = [v for v in required if v not in available_indicators]
if missing:
    st.warning("데이터셋에 없는 지표명:")
    for v in missing:
        close = get_close_matches(v, available_indicators, n=3, cutoff=0.6)
        st.write(f"- {v} → 후보: {close}")

st.header("기초 통계 및 상관관계")
flat_df = df_multi.copy()
flat_df.columns = [f"{a} [{b}]" for a,b in flat_df.columns]
nums = flat_df.select_dtypes(include=np.number)
if not nums.empty:
    st.write(nums.describe().T)
    try:
        fig, ax = plt.subplots(figsize=(12,7))
        sns.heatmap(nums.corr(), cmap="coolwarm", center=0, ax=ax)
        ax.set_title("상관관계")
        st.pyplot(fig)
    except Exception:
        st.info("상관관계 시각화 생략")
else:
    st.info("수치형 데이터 없음")

reg_df = build_regression_data(df_multi)
if reg_df.empty:
    st.error("회귀데이터 부족")
    st.stop()

st.subheader("회귀 데이터 선별")
st.dataframe(reg_df.head())

st.subheader("산점도(ln GERD vs ln GDP)")
fig, ax = plt.subplots(figsize=(7,5))
sns.regplot(x="ln_GERD", y="ln_GDP", data=reg_df, scatter_kws={"alpha":0.6}, ax=ax)
ax.set_xlabel(f"ln {GERD_NAME} ({X_YEAR})")
ax.set_ylabel(f"ln {GDP_NAME} ({Y_YEAR})")
st.pyplot(fig)

models, summ = run_models(reg_df)
st.subheader("회귀 모델 통계")
st.dataframe(summ)

fig2, ax2 = plt.subplots(figsize=(6,4))
sns.barplot(x="Model", y="Adj R2", data=summ, ax=ax2)
ymax = float(summ["Adj R2"].max()) if not summ.empty else 1.0
ax2.set_ylim(0, max(0.1, ymax)*1.1)
ax2.set_title("모델별 결정계수 비교")
st.pyplot(fig2)

with st.expander("회귀 결과 상세보기"):
    for k,m in models.items():
        st.markdown(f"**{k}**")
        st.text(m.summary())