# -*- coding: utf-8 -*-
"""acdt_g31

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F5fm0D95_3CLMpKv3LVVCJCWz4Vwmcv_
"""

# ============================================
# ACDT G31 â€“ GERD(2020) â†’ GDP(2022/2023) Full Regressions
# ============================================
import streamlit as st
import pandas as pd
import numpy as np
import re
import seaborn as sns
import matplotlib.pyplot as plt
import statsmodels.formula.api as smf

st.set_page_config(page_title="ACDT G31 â€“ GERDâ†’GDP (Year-paired)", layout="wide")

DATA_FILE = "ACDT_final_dataset.csv"  # repo íŒŒì¼ëª…

# ----- ì›ë¬¸ ì§€í‘œëª… (CSV í—¤ë”ì™€ ì •í™•íˆ ì¼ì¹˜í•´ì•¼ í•¨) -----
GDP_NAME  = "Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)"
GERD_NAME = "Gross Domestic Expenditure on R&D (GERD) (current PPP USD)"

MEDIATOR_NAMES = [
    "Resident Patent Applications",
    "Non-Resident Patent Applications",
    "R&D Researchers per Million People",
    "High-tech Export Share (% of Manufactured Exports)",
    "Business R&D Personnel (FTE)",
]
CONFOUNDER_NAMES = ["GDP per Capita", "Labor Force Size"]
MODERATOR_NAMES  = ["Government-financed BERD (%)", "Business-financed BERD (%)"]

X_YEAR = 2020
Y_YEARS = [2022, 2023]

# -----------------------------
# ìœ í‹¸: CSV ë¡œë“œ (0í–‰=ì—°ë„, 1í–‰=ì§€í‘œëª…)
# -----------------------------
def read_as_multiindex(path: str) -> pd.DataFrame:
    # ì¸ì½”ë”© ìœ ì—° ì²˜ë¦¬
    last_err = None
    raw = None
    for enc in ("utf-8-sig", "cp949"):
        try:
            raw = pd.read_csv(path, header=None, encoding=enc, engine="python")
            break
        except Exception as e:
            last_err = e
    if raw is None:
        raise RuntimeError(f"CSV read failed: {last_err}")

    # â€œí•œ ì…€ì— ì „ë¶€ ë“¤ì–´ê°„ CSVâ€ ë°©ì§€: ìë™ split
    if raw.shape[1] == 1 and isinstance(raw.iloc[0,0], str):
        cell = raw.iloc[0,0]
        for sep in (",", "\t", ";"):
            if sep in cell:
                raw = raw[0].str.split(sep, expand=True)
                break

    years = raw.iloc[0].astype(str).values
    names = raw.iloc[1].astype(str).values
    df = raw.iloc[2:].copy()

    # MultiIndex ì»¬ëŸ¼ êµ¬ì„±
    df.columns = pd.MultiIndex.from_arrays([names, years], names=["Indicator", "Year"])

    # ---- ìˆ«ì ì •ì œ: ëª¨ë“  ì—´ì„ "Series"ë¡œ ìˆœíšŒí•´ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬ ----
    def clean_to_numeric(series: pd.Series) -> pd.Series:
        # ë¬¸ìì—´í™” í›„, ìˆ«ì/ë¶€í˜¸/ì§€ìˆ˜í‘œí˜„ë§Œ ë‚¨ê¸°ê³  ë‚˜ë¨¸ì§€ ì œê±°
        s = series.astype(str)
        s = s.str.replace(",", "", regex=False)
        s = s.str.replace(r"[^0-9eE+\-\.]", "", regex=True)
        return pd.to_numeric(s, errors="coerce")

    # ëª¨ë“  (Indicator, Year) íŠœí”Œì— ëŒ€í•´ Seriesë¡œ ê°œë³„ ì²˜ë¦¬
    for col in df.columns:
        df[col] = clean_to_numeric(df[col])

    # ì—°ë„ ì •ìˆ˜ ìºìŠ¤íŒ… (ê°€ëŠ¥ì‹œ)
    try:
        new_cols = []
        for (ind, yr) in df.columns:
            y = int(float(yr)) if str(yr).replace(".", "", 1).isdigit() else yr
            new_cols.append((ind, y))
        df.columns = pd.MultiIndex.from_tuples(new_cols, names=["Indicator", "Year"])
    except Exception:
        pass

    df.index = pd.RangeIndex(len(df))  # êµ­ê°€ëª…ì´ ë”°ë¡œ ì—†ìœ¼ë©´ ë‹¨ìˆœ ì¸ë±ìŠ¤
    return df

def s_at(df_mi: pd.DataFrame, name: str, year) -> pd.Series:
    if (name in df_mi.columns.get_level_values(0)) and (year in df_mi.loc[:, name].columns):
        return df_mi.loc[:, (name, year)]
    return pd.Series([np.nan]*len(df_mi), index=df_mi.index)

def build_pair_dataset(df_mi: pd.DataFrame, x_year: int, y_year: int) -> pd.DataFrame:
    out = pd.DataFrame(index=df_mi.index)
    out["GERD"] = s_at(df_mi, GERD_NAME, x_year)
    out["GDP"]  = s_at(df_mi, GDP_NAME,  y_year)
    # Y-year ê¸°ì¤€ìœ¼ë¡œ ë³´ì¡°ë³€ìˆ˜ë“¤ ê²°í•©
    for v in CONFOUNDER_NAMES + MEDIATOR_NAMES + MODERATOR_NAMES:
        out[v] = s_at(df_mi, v, y_year)
    # ë¡œê·¸
    out["ln_X"] = np.log(out["GERD"].replace({0: np.nan}))
    out["ln_Y"] = np.log(out["GDP"].replace({0: np.nan}))
    return out.dropna(subset=["ln_X","ln_Y"]).reset_index(drop=True)

def run_models(df_reg: pd.DataFrame):
    confs = [c for c in CONFOUNDER_NAMES if c in df_reg.columns]
    meds  = [m for m in MEDIATOR_NAMES if m in df_reg.columns]
    mods  = [m for m in MODERATOR_NAMES  if m in df_reg.columns]

    # M1
    m1 = smf.ols("ln_Y ~ ln_X", data=df_reg).fit()
    # M2
    rhs2 = "ln_X" + ((" + " + " + ".join([f'Q(\"{c}\")' for c in confs])) if confs else "")
    m2 = smf.ols(f"ln_Y ~ {rhs2}", data=df_reg).fit()
    # M3
    rhs3 = rhs2 + ((" + " + " + ".join([f'Q(\"{m}\")' for m in meds])) if meds else "")
    m3 = smf.ols(f"ln_Y ~ {rhs3}", data=df_reg).fit()
    # M4
    inter = " + ".join([f'ln_X * Q(\"{mo}\")' for mo in mods]) if mods else ""
    rhs4 = rhs3 if not inter else f"{rhs3} + {inter}"
    m4 = smf.ols(f"ln_Y ~ {rhs4}", data=df_reg).fit()

    def pick(model, key="ln_X"):
        return model.params.get(key, np.nan), model.pvalues.get(key, np.nan), model.rsquared_adj

    rows = []
    for label, model in [("M1: lnY~lnX", m1), ("M2:+conf", m2), ("M3:+med", m3), ("M4:+mods", m4)]:
        beta, pval, adjr2 = pick(model, "ln_X")
        rows.append([label, beta, pval, adjr2])
    summary = pd.DataFrame(rows, columns=["Model","Î²(ln_X)","p(ln_X)","Adj.RÂ²"]).round(4)
    return {"M1":m1,"M2":m2,"M3":m3,"M4":m4}, summary

# ------------------ ì•± ë³¸ë¬¸ ------------------
st.title("ğŸ“ˆ GERD(2020) â†’ GDP(2022/2023) â€“ Full Regressions (Model 1â€“4)")

try:
    df_mi = read_as_multiindex(DATA_FILE)
except Exception as e:
    st.error(f"Error loading data: {e}")
    st.stop()

st.success("âœ… Dataset loaded (Row0=Year, Row1=Indicator â†’ MultiIndex)")

# (1) ì „ì²´ ìˆ«ìì—´ ë¶„í¬ & ìƒê´€ íˆíŠ¸ë§µ (Colab ìŠ¤íƒ€ì¼)
st.header("ğŸ“Š Distributions & Correlations (All Numeric Columns)")
num_df = df_mi.copy()
num_df.columns = [f"{a} [{b}]" for a,b in num_df.columns]  # ë³´ê¸° ì¢‹ê²Œ
try:
    st.write(num_df.describe().T)
    fig_corr, ax_corr = plt.subplots(figsize=(12,7))
    sns.heatmap(num_df.corr(), cmap="coolwarm", center=0, ax=ax_corr)
    ax_corr.set_title("Correlation Heatmap")
    st.pyplot(fig_corr)
except Exception:
    st.info("Numerical summary skipped (insufficient numeric columns).")

# (2) ë‘ ê°œì˜ ê³ ì • ì—°ë„ìŒ íšŒê·€
for yyr in Y_YEARS:
    st.markdown("---")
    st.header(f"ğŸ§® Pair: GERD({X_YEAR}) â†’ GDP({yyr})")

    df_reg = build_pair_dataset(df_mi, X_YEAR, yyr)
    if df_reg.empty:
        st.warning("No valid observations after cleaning for this pair.")
        continue

    st.subheader("ğŸ“‹ Regression dataset (preview)")
    st.dataframe(df_reg.head())

    # ì‚°ì ë„ (ë¡œê·¸-ë¡œê·¸)
    st.subheader("ğŸ“‰ ln(GERD) vs ln(GDP)")
    fig_sc, ax_sc = plt.subplots(figsize=(7,5))
    sns.regplot(x="ln_X", y="ln_Y", data=df_reg, scatter_kws={"alpha":0.6}, ax=ax_sc)
    ax_sc.set_xlabel(f"ln GERD ({X_YEAR})")
    ax_sc.set_ylabel(f"ln GDP ({yyr})")
    st.pyplot(fig_sc)

    # ëª¨ë¸ 1~4
    models, table = run_models(df_reg)
    st.subheader("ğŸ“˜ Model Comparison")
    st.dataframe(table)

    # RÂ² ë§‰ëŒ€
    fig_r2, ax_r2 = plt.subplots(figsize=(6,4))
    sns.barplot(x="Model", y="Adj.RÂ²", data=table, ax=ax_r2)
    ax_r2.set_ylim(0, max(table["Adj.RÂ²"]) * 1.1 if len(table) else 1)
    ax_r2.set_title("Adjusted RÂ² across models")
    st.pyplot(fig_r2)

    # ì „ì²´ ìš”ì•½
    with st.expander("Full regression summaries"):
        for k, m in models.items():
            st.markdown(f"**{k}**")
            st.text(m.summary())

# (3) í•´ì„ ìš”ì•½ (Colab ì„¤ëª… í†¤)
st.markdown("""
### ğŸ§© Interpretation (Colab spec)
- **Model 1**ì€ GERDì™€ GDP ê°„ì˜ ê¸°ë³¸ íƒ„ë ¥ì„±ì„ ë³´ì—¬ì¤€ë‹¤.
- **Model 2**ëŠ” êµë€ë³€ìˆ˜(ì˜ˆ: 1ì¸ë‹¹ GDP, ë…¸ë™ë ¥ ê·œëª¨)ë¥¼ í†µì œí•˜ë©°, lnGERD ê³„ìˆ˜ ë³€í™”ë¡œ **í˜¼ë€íš¨ê³¼ ì¡´ì¬ ì—¬ë¶€**ë¥¼ í™•ì¸í•  ìˆ˜ ìˆë‹¤.
- **Model 3**ëŠ” íŠ¹í—ˆÂ·ì—°êµ¬ì¸ë ¥Â·í•˜ì´í…Œí¬ìˆ˜ì¶œÂ·ê¸°ì—…R&Dì¸ë ¥ ë“± **ë§¤ê°œ** ê²½ë¡œë¥¼ í¬í•¨í•˜ì—¬, lnGERD ê³„ìˆ˜ ê°ì†Œ(ë˜ëŠ” ìœ ì˜ì„± ë³€í™”)ê°€ ìˆìœ¼ë©´ **ê°„ì ‘íš¨ê³¼**ê°€ ìˆìŒì„ ì‹œì‚¬í•œë‹¤.
- **Model 4**ëŠ” ì •ë¶€/ë¯¼ê°„ **BERD ë¹„ì¤‘ê³¼ì˜ ìƒí˜¸ì‘ìš©**ìœ¼ë¡œ **ì¡°ì ˆíš¨ê³¼**ë¥¼ ê²€ì •í•œë‹¤(ìƒí˜¸ì‘ìš© í•­ì˜ p < 0.05ë©´ ì¡°ì ˆ ìœ ì˜).

> ëª¨ë“  ì „ì²˜ë¦¬Â·ë¡œê·¸ë³€í™˜Â·ì—°ë„ìŒ(2020â†’2022, 2020â†’2023) íšŒê·€ëŠ” Colab ìŠ¤í™ì„ ê·¸ëŒ€ë¡œ ë”°ë¦„.
""")