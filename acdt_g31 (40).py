# -*- coding: utf-8 -*-
"""acdt_g31

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F5fm0D95_3CLMpKv3LVVCJCWz4Vwmcv_
"""

@st.cache_data
def read_as_multiindex_v2(path: str, debug: bool = False) -> pd.DataFrame:
    import pandas as pd
    import numpy as np

    # 1) CSV ì½ê¸° (ì¸ì½”ë”© 2ì¢… ì‹œë„)
    raw, last_err = None, None
    for enc in ("utf-8-sig", "cp949"):
        try:
            raw = pd.read_csv(path, header=None, encoding=enc, engine="python")
            break
        except Exception as e:
            last_err = e
    if raw is None:
        raise RuntimeError(f"CSV read failed: {last_err}")

    # â”€â”€ ğŸ” ë””ë²„ê·¸: ì›ì‹œ í—¤ë” ìƒíƒœ í™•ì¸ â”€â”€
    if debug:
        st.subheader("ğŸ” DEBUG: Raw CSV (before parsing)")
        st.write("raw.shape:", raw.shape)

        r0 = raw.iloc[0]
        r1 = raw.iloc[1]
        if isinstance(r0, pd.DataFrame): r0 = r0.squeeze(axis=0)
        if isinstance(r1, pd.DataFrame): r1 = r1.squeeze(axis=0)

        st.write("row0 (years) â€” first 30:", r0.astype(str).tolist()[:30])
        st.write("row1 (indicator names) â€” first 30:", r1.astype(str).tolist()[:30])

        # í‘œë¡œ ë¯¸ë¦¬ë³´ê¸°
        st.dataframe(raw.iloc[:6, :20])
        st.info("â¬†ï¸ ìœ„ ë‚´ìš©ì„ ìº¡ì³í•´ì„œ ë³´ë‚´ì¤˜. (ì•„ë˜ íŒŒì‹±ì€ ì¤‘ë‹¨)")
        st.stop()  # ì—¬ê¸°ì„œ ì•± ë©ˆì¶¤ â†’ í™”ë©´ ìº¡ì³/ë³µì‚¬í•˜ê¸° ì¢‹ìŒ

    # 2) ë‹¨ì¼ ì»¬ëŸ¼ì´ë©´ êµ¬ë¶„ì ê°ì§€ í›„ split
    if int(raw.shape[1]) == 1:
        try:
            sample = raw.iloc[:min(5, len(raw)), 0].astype(str).tolist()
            sample_text = "\n".join(sample)
            found_sep = None
            for s in (",", "\t", ";"):
                if sample_text.find(s) != -1:
                    found_sep = s
                    break
            if found_sep is not None:
                col0 = raw.iloc[:, 0].astype(str)
                raw = col0.str.split(found_sep, expand=True)
        except Exception:
            pass

    # 3) ë©€í‹°ì¸ë±ìŠ¤ êµ¬ì„±
    row0 = raw.iloc[0]
    row1 = raw.iloc[1]
    if isinstance(row0, pd.DataFrame): row0 = row0.squeeze(axis=0)
    if isinstance(row1, pd.DataFrame): row1 = row1.squeeze(axis=0)

    years = row0.astype(str).str.strip().values
    names = row1.astype(str).str.strip().values

    df = raw.iloc[2:].copy()
    df.columns = pd.MultiIndex.from_arrays([names, years], names=["Indicator", "Year"])

    # 4) ìˆ«ì í´ë¦¬ë‹
    def clean_series(s: pd.Series) -> pd.Series:
        s = s.astype(str)
        s = s.str.replace(",", "", regex=False)
        s = s.str.replace(r"[^0-9eE+\-\.]", "", regex=True)
        return pd.to_numeric(s, errors="coerce")
    for j in range(df.shape[1]):
        df.iloc[:, j] = clean_series(df.iloc[:, j])

    # 5) ì—°ë„ int ìºìŠ¤íŒ… (ê°€ëŠ¥í•˜ë©´)
    try:
        new_cols = []
        for ind, yr in df.columns:
            ystr = str(yr)
            if ystr.replace(".", "", 1).isdigit():
                yv = int(float(ystr))
            else:
                yv = yr
            new_cols.append((ind, yv))
        df.columns = pd.MultiIndex.from_tuples(new_cols, names=["Indicator", "Year"])
    except Exception:
        pass

    # 6) ì¤‘ë³µ ì»¬ëŸ¼ â†’ í‰ê·  í†µí•©
    if bool(df.columns.duplicated(keep=False).any()):
        df = df.T.groupby(level=["Indicator", "Year"]).mean(numeric_only=True).T
        df.index = pd.RangeIndex(len(df))

    return df