# -*- coding: utf-8 -*-
"""acdt_g31

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F5fm0D95_3CLMpKv3LVVCJCWz4Vwmcv_
"""

import warnings
warnings.filterwarnings("ignore")

import streamlit as st
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import statsmodels.formula.api as smf
from difflib import get_close_matches

st.set_page_config(page_title="ACDT G31 – GERD(2020) → GDP(2023)", layout="wide")

DATA_FILE = "ACDT_final_dataset.csv"

# 변수명 정의 (꼭 실제 데이터셋 지표명과 일치해야 함)
GDP_NAME  = "Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)"
GERD_NAME = "Gross Domestic Expenditure on R&D (GERD) (current PPP USD)"
MEDIATOR_NAMES = [
    "Resident Patent Applications",
    "Non-Resident Patent Applications",
    "Business R&D Personnel (FTE)",
]
CONFOUNDER_NAMES = [
    "GDP per Capita",
    "Labor Force Size",
]
MODERATOR_NAMES  = [
    "Share of Government-Financed BERD (%)",
    "Share of Business-Financed BERD (%)",
]

X_YEAR = 2020
Y_YEAR = 2023

@st.cache_data(ttl=600)
def read_and_clean(path: str, debug=False):
    # CSV 로딩 및 초기 검증
    raw, last_err = None, None
    for enc in ('utf-8-sig', 'cp949'):
        try:
            raw = pd.read_csv(path, encoding=enc, header=None)
            break
        except Exception as e:
            last_err = e
    if raw is None:
        raise RuntimeError(f"Given CSV read failed: {last_err}")

    if debug:
        st.subheader("CSV 원시 데이터 및 헤더 미리보기")
        st.write(f"shape: {raw.shape}")
        st.write("row0 (year):", raw.iloc[0].astype(str).tolist()[:30])
        st.write("row1 (indicator):", raw.iloc[1].astype(str).tolist()[:30])
        st.dataframe(raw.head(6))
        st.info("디버그 모드에서 중단")
        st.stop()

    # 단일 컬럼 문자열 자동분리
    if raw.shape[1] == 1:
        sample = "\n".join(raw.iloc[:5,0].astype(str).tolist())
        sep = next((s for s in [",","\t",";","|"] if s in sample), None)
        if sep:
            raw = raw.iloc[:,0].astype(str).str.split(sep, expand=True)

    years = raw.iloc[0].astype(str).str.strip()
    indictators = raw.iloc[1].astype(str).str.strip()

    df = raw.iloc[2:].copy()
    df.columns = pd.MultiIndex.from_arrays([indictators, years])

    def numeric_cleaner(s):
        s = s.astype(str).str.replace(",", "").str.replace(r"[^0-9.eE+\-]", "", regex=True)
        return pd.to_numeric(s, errors='coerce')

    for col in df.columns:
        df[col] = numeric_cleaner(df[col])

    # 연도를 정수로 변환 가능한 것만 변환
    new_cols = []
    for ind, yr in df.columns:
        try:
            yr_int = int(float(yr))
        except:
            yr_int = yr
        new_cols.append((ind, yr_int))
    df.columns = pd.MultiIndex.from_tuples(new_cols)

    # 컬럼 중복있으면 평균 처리
    if df.columns.duplicated().any():
        df = df.T.groupby(level=[0,1]).mean().T
        df.index = pd.RangeIndex(len(df))

    return df

def get_series(df, indicator, year):
    lvl0 = df.columns.get_level_values(0)
    if indicator in set(lvl0):
        sub = df.loc[:, indicator]
        cols = list(sub.columns) if hasattr(sub, 'columns') else []
        if year in cols:
            return df.loc[:, (indicator, year)]
    return pd.Series([np.nan]*len(df), index=df.index)

def build_regression_data(df):
    out = pd.DataFrame(index=df.index)
    out['GERD'] = get_series(df, GERD_NAME, X_YEAR)
    out['GDP'] = get_series(df, GDP_NAME, Y_YEAR)
    for v in CONFOUNDER_NAMES + MEDIATOR_NAMES + MODERATOR_NAMES:
        out[v] = get_series(df, v, Y_YEAR)
    out['ln_GERD'] = np.log(out['GERD'].replace(0, np.nan))
    out['ln_GDP'] = np.log(out['GDP'].replace(0, np.nan))
    return out.dropna(subset=['ln_GERD', 'ln_GDP']).reset_index(drop=True)

def run_models(df):
    confs = [c for c in CONFOUNDER_NAMES if c in df.columns]
    meds = [m for m in MEDIATOR_NAMES if m in df.columns]
    mods = [m for m in MODERATOR_NAMES if m in df.columns]

    m1 = smf.ols("ln_GDP ~ ln_GERD", data=df).fit()
    rhs2 = "ln_GERD" + ((" + " + " + ".join([f'Q(\"{c}\")' for c in confs])) if confs else "")
    m2 = smf.ols(f"ln_GDP ~ {rhs2}", data=df).fit()
    rhs3 = rhs2 + ((" + " + " + ".join([f'Q(\"{m}\")' for m in meds])) if meds else "")
    m3 = smf.ols(f"ln_GDP ~ {rhs3}", data=df).fit()
    inter = " + ".join([f'ln_GERD * Q(\"{mo}\")' for mo in mods]) if mods else ""
    rhs4 = rhs3 if not inter else f"{rhs3} + {inter}"
    m4 = smf.ols(f"ln_GDP ~ {rhs4}", data=df).fit()

    def select_stats(mod, key="ln_GERD"):
        return mod.params.get(key, np.nan), mod.pvalues.get(key, np.nan), mod.rsquared_adj

    results = []
    for name, mod in [("M1", m1), ("M2", m2), ("M3", m3), ("M4", m4)]:
        beta, pval, adj = select_stats(mod)
        results.append([name, beta, pval, adj])
    return {"M1": m1, "M2": m2, "M3": m3, "M4": m4}, pd.DataFrame(results, columns=["Model", "Beta", "p-value", "Adj R2"]).round(4)


st.title("ACDT G31 – GERD(2020) → GDP(2023) 회귀 분석 및 시각화")

debug_mode = st.sidebar.checkbox("원시 CSV 헤더 출력 후 중단", False)

try:
    df = read_and_clean(DATA_FILE, debug=debug_mode)
except Exception as e:
    st.error(f"데이터 로딩 실패: {e}")
    st.stop()

available_vars = sorted(set(df.columns.get_level_values(0)))
needed_vars = [GDP_NAME, GERD_NAME] + MEDIATOR_NAMES + CONFOUNDER_NAMES + MODERATOR_NAMES
missing_vars = [v for v in needed_vars if v not in available_vars]

if missing_vars:
    st.warning("다음 지표명이 데이터셋에 없습니다:")
    for v in missing_vars:
        candidates = get_close_matches(v, available_vars, n=3, cutoff=0.6)
        st.write(f"- {v} → 후보: {candidates}")

st.header("변수별 기본 통계 및 상관관계")
flat = df.copy()
flat.columns = [f"{a} [{b}]" for a,b in flat.columns]
nums = flat.select_dtypes(include=np.number)
if not nums.empty:
    st.dataframe(nums.describe().T)
    try:
        fig, ax = plt.subplots(figsize=(12,7))
        sns.heatmap(nums.corr(), cmap="coolwarm", center=0, ax=ax)
        ax.set_title("상관관계 행렬")
        st.pyplot(fig)
    except Exception:
        st.info("상관관계 히트맵 생략")
else:
    st.info("수치형 데이터가 없습니다")

reg_df = build_regression_data(df)
if reg_df.empty:
    st.error("회귀 분석에 사용할 유효한 데이터가 없습니다. 지표명을 확인하세요.")
    st.stop()

st.subheader("회귀 분석용 데이터 미리보기")
st.dataframe(reg_df.head())

st.subheader("ln(GERD) 와 ln(GDP) 산점도")
fig, ax = plt.subplots(figsize=(7,5))
sns.regplot(x="ln_GERD", y="ln_GDP", data=reg_df, scatter_kws={"alpha":0.6}, ax=ax)
ax.set_xlabel(f"ln {GERD_NAME} ({X_YEAR})")
ax.set_ylabel(f"ln {GDP_NAME} ({Y_YEAR})")
st.pyplot(fig)

models, summ = run_models(reg_df)
st.subheader("회귀 모델 비교")
st.dataframe(summ)

fig2, ax2 = plt.subplots(figsize=(6,4))
sns.barplot(x="Model", y="Adj R2", data=summ, ax=ax2)
ymax = float(summ["Adj R2"].max()) if not summ.empty else 1.0
ax2.set_ylim(0, max(0.1, ymax) * 1.1)
ax2.set_title("모델별 조정 결정계수 비교")
st.pyplot(fig2)

with st.expander("회귀 상세 결과"):
    for k,m in models.items():
        st.markdown(f"**{k}**")
        st.text(m.summary())