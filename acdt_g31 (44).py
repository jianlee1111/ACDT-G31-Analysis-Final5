# -*- coding: utf-8 -*-
"""acdt_g31

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F5fm0D95_3CLMpKv3LVVCJCWz4Vwmcv_
"""

import re
import numpy as np
import pandas as pd
import streamlit as st
import statsmodels.formula.api as smf
import matplotlib.pyplot as plt
import seaborn as sns

st.set_page_config(page_title="GERD(2020) → GDP(2023) – Full Regressions (w/ Debug)", layout="wide")

CSV_NAME = "ACDT_final_dataset.csv"

# -------------------- 유틸 --------------------
def coerce_numeric_series_like(df_like: pd.DataFrame) -> pd.DataFrame:
    """
    멀티인덱스 전체(수치영역)에 대해 벡터화로 숫자만 남기고 float 변환.
    * 괄호(...) 내부 텍스트 제거
    * 숫자/./- 이외 제거
    * 빈 문자열 -> NaN
    """
    # 문자열화
    tmp = df_like.astype(str)

    # 괄호 안 텍스트 제거
    tmp = tmp.replace(r"\([^)]*\)", "", regex=True)
    # 숫자/.- 이외 전부 제거
    tmp = tmp.replace(r"[^0-9.\-]", "", regex=True)
    # 빈문자 -> NaN
    tmp = tmp.replace(r"^\s*$", np.nan, regex=True)

    # to_numeric (벡터화)
    # DataFrame 전체에 apply(pd.to_numeric)는 느려서, stack->to_numeric->unstack이 더 안정적임
    stacked = tmp.stack(dropna=False)
    stacked = pd.to_numeric(stacked, errors="coerce")
    restored = stacked.unstack()
    return restored

def anycol(wide: pd.DataFrame, patterns):
    """정규식 리스트 중 첫 매칭 열 반환(None 가능)."""
    for p in patterns:
        r = re.compile(p, re.I)
        hit = [c for c in wide.columns if r.search(str(c))]
        if hit:
            return hit[0]
    return None

# -------------------- 1) 로드 & 정리 --------------------
@st.cache_data(show_spinner=True)
def load_and_tidy(csv_name=CSV_NAME):
    raw = pd.read_csv(csv_name, header=None)
    st.write("🔎 DEBUG: raw shape", raw.shape)

    # 첫 두 행을 헤더로 사용
    raw.iloc[0, 0] = "Country"
    raw.iloc[1, 0] = "Indicator"

    years_row = raw.iloc[0].fillna("").astype(str).tolist()
    inds_row  = raw.iloc[1].fillna("").astype(str).tolist()

    # MultiIndex 컬럼 생성
    cols = []
    for j in range(raw.shape[1]):
        if j == 0:
            cols.append(("Country", ""))
        else:
            cols.append((inds_row[j].strip(), years_row[j].strip()))
    mi_cols = pd.MultiIndex.from_tuples(cols, names=["Indicator", "Year"])
    raw.columns = mi_cols

    # 데이터 부분만
    df = raw.iloc[2:].copy()
    df = df.rename(columns={("Country", ""): "Country"})
    df["Country"] = df["Country"].astype(str).str.strip()

    # 전체 열 프린트(앞부분)
    st.write("🔎 DEBUG: columns (head 25)", list(df.columns)[:25])

    # 수치 영역: Country 제외 멀티인덱스 전체
    mask = [c for c in df.columns if not (isinstance(c, str) and c == "Country")]
    numeric_block = df.loc[:, mask]

    # (중요) 멀티인덱스 전체 슬라이스에 벡터화 전처리 → lexsort warning 제거
    numeric_clean = coerce_numeric_series_like(numeric_block)

    # 결합
    df_clean = pd.concat([df[["Country"]], numeric_clean], axis=1)

    # Long 형태
    long = (
        df_clean
        .set_index("Country")
        .stack(level=["Indicator", "Year"])
        .reset_index()
        .rename(columns={0: "value"})
    )

    # Wide: "Indicator | Year"
    long["colkey"] = long["Indicator"].str.strip() + " | " + long["Year"].str.strip()
    wide = long.pivot_table(index="Country", columns="colkey", values="value", aggfunc="first")
    wide.columns = wide.columns.astype(str)

    # 디버깅: 결측 통계
    st.write("🔎 DEBUG: long shape", long.shape, "wide shape", wide.shape)
    st.write("🔎 DEBUG: sample long", long.head(8))
    st.write("🔎 DEBUG: non-null counts (wide) – top 20",
             wide.notna().sum().sort_values(ascending=False).head(20))

    return long, wide

# -------------------- 2) 컬럼 매핑 --------------------
def extract_columns(wide, gerd_year="2020", gdp_year="2023"):
    # 후보 패턴
    gerd_candidates = [
        r"Gross Domestic Expenditure on R&D.*current.*USD",
        r"GERD.*current.*USD",
        r"R&D Expenditure Ratio.*% of GDP",
        r"R&D Expenditure Ratio"
    ]
    gdp_real_pat     = r"Real GDP \(billion USD.*Chain-weighted.*2020 base year\)"
    patents_res_pat  = r"Resident Patent Applications"
    patents_non_pat  = r"Non-Resident Patent Applications"
    rd_researchers   = r"Number of R&D Researcher"
    hightech_share   = r"High-Tech Export Share.*% of Manufacturing Exports"
    gdp_capita_pat   = r"GDP per Capita \(USD per person, PPP-based, Nominal\)"

    # 2023 고정 권장, 없으면 None → 모델에서 자동 건너뜀
    def find_yeared(regex, year):
        pat = re.compile(regex, re.I)
        hits = [c for c in wide.columns if pat.search(str(c)) and c.endswith(f"| {year}")]
        return hits[0] if hits else None

    # GERD(연도)
    gerd_col = None
    for pat in gerd_candidates:
        hit = find_yeared(pat, gerd_year)
        if hit:
            gerd_col = hit
            break

    gdp_col       = find_yeared(gdp_real_pat, gdp_year)
    res_pat_col   = find_yeared(patents_res_pat, "2023")
    non_pat_col   = find_yeared(patents_non_pat, "2023")
    rd_col        = find_yeared(rd_researchers, "2023")
    hte_col       = find_yeared(hightech_share, "2023")
    gdp_pc_col    = find_yeared(gdp_capita_pat, "2023")

    # BERD 조절자는 데이터셋에 없을 가능성 높으므로 optional
    berd_gov_col  = anycol(wide, [r"Government-financed BERD \(%\) \| 2023"])
    berd_biz_col  = anycol(wide, [r"Business-financed BERD \(%\) \| 2023"])

    found = {
        "GERD": gerd_col,
        "Real_GDP": gdp_col,
        "Resident_Patents": res_pat_col,
        "NonResident_Patents": non_pat_col,
        "R&D_Researchers_per_million": rd_col,
        "HighTech_Export_Share": hte_col,
        "GDP_per_Capita": gdp_pc_col,
        "GovFinanced_BERD_pct": berd_gov_col,
        "BizFinanced_BERD_pct": berd_biz_col,
    }
    return found

# -------------------- 3) 분석 DF 구성 --------------------
def build_model_df(wide, mapping):
    missing = [k for k, v in mapping.items() if k in ("GERD", "Real_GDP") and (v is None)]
    if missing:
        return None, f"Required columns missing: {missing}"

    # 실제 존재하는 열만 선택
    use = {k: v for k, v in mapping.items() if v is not None}
    dfm = wide[list(use.values())].copy()
    dfm.columns = list(use.keys())

    # 로그변환(양수만)
    for c in ("GERD", "Real_GDP", "GDP_per_Capita"):
        if c in dfm.columns:
            dfm[f"ln_{c}"] = np.where(dfm[c] > 0, np.log(dfm[c]), np.nan)

    # 코어 결측 제거
    core = [c for c in ("ln_GERD", "ln_Real_GDP") if c in dfm.columns]
    dfm = dfm.dropna(subset=core)

    # 디버깅
    st.write("🔎 DEBUG: model df shape", dfm.shape)
    st.write("🔎 DEBUG: NA counts", dfm.isna().sum().to_dict())

    # index=Country 로 노출되도록 reset
    return dfm.reset_index(), None

# -------------------- 4) 회귀 적합 --------------------
def fit_models(dfm):
    res = {}

    # Model 1
    m1 = smf.ols("ln_Real_GDP ~ ln_GERD", data=dfm).fit()
    res["Model 1"] = m1

    # Model 2 (confounder)
    if "GDP_per_Capita" in dfm.columns:
        m2 = smf.ols("ln_Real_GDP ~ ln_GERD + GDP_per_Capita", data=dfm).fit()
    else:
        m2 = m1
    res["Model 2"] = m2

    # Model 3 (mediators)
    meds = [c for c in ["Resident_Patents","NonResident_Patents","R&D_Researchers_per_million","HighTech_Export_Share"] if c in dfm.columns]
    if meds:
        m3 = smf.ols("ln_Real_GDP ~ ln_GERD + " + " + ".join(meds), data=dfm).fit()
    else:
        m3 = m2
    res["Model 3"] = m3

    # Model 4 (moderators)
    mods = [c for c in ["GovFinanced_BERD_pct","BizFinanced_BERD_pct"] if c in dfm.columns]
    if mods:
        inter = " + ".join([f"ln_GERD:{m}" for m in mods])
        rhs = "ln_GERD " + ("+ " + " + ".join(meds) if meds else "") + (" + " + " + ".join(mods) if mods else "") + " + " + inter
        m4 = smf.ols(f"ln_Real_GDP ~ {rhs}", data=dfm).fit()
    else:
        m4 = m3
    res["Model 4"] = m4

    return res

# -------------------- 5) 앱 --------------------
st.title("📈 GERD(2020) → GDP(2023) – Full Regressions (Model 1–4)")

with st.spinner("Loading & cleaning data..."):
    try:
        long, wide = load_and_tidy(CSV_NAME)
    except Exception as e:
        st.error(f"❌ Error loading data: {e}")
        st.stop()

st.success(f"Loaded: long={long.shape}, wide={wide.shape}")

colA, colB = st.columns(2)
with colA: gerd_year = st.selectbox("GERD year", ["2020","2021","2022","2023"], index=0)
with colB: gdp_year  = st.selectbox("Real GDP year", ["2023","2022","2021"], index=0)

mapping = extract_columns(wide, gerd_year=gerd_year, gdp_year=gdp_year)
st.subheader("🔎 Matched columns")
st.json(mapping)

dfm, err = build_model_df(wide, mapping)
if err:
    st.error(f"❌ {err}")
    st.stop()

st.subheader("📋 Analysis Data (head)")
st.dataframe(dfm.head(10), use_container_width=True)

# 분포 시각화
st.subheader("📊 Variable Distributions")
num_cols = [c for c in dfm.columns if dfm[c].dtype != "O"]
sel = st.multiselect("Select variables", num_cols, default=[c for c in ["ln_GERD","ln_Real_GDP","GDP_per_Capita"] if c in num_cols])
if sel:
    fig, axes = plt.subplots(nrows=len(sel), ncols=1, figsize=(7, 2.6*len(sel)))
    if len(sel) == 1:
        axes = [axes]
    for ax, c in zip(axes, sel):
        sns.histplot(dfm[c].dropna(), kde=True, ax=ax)
        ax.set_title(c)
    st.pyplot(fig)

# 회귀
results = fit_models(dfm)

st.subheader("📘 Model Comparison")
rows = []
for name, m in results.items():
    rows.append([name, m.params.get("ln_GERD", np.nan), m.pvalues.get("ln_GERD", np.nan), m.rsquared_adj])
comp = pd.DataFrame(rows, columns=["Model","β(ln_GERD)","p-value","Adj.R²"])
st.dataframe(comp, use_container_width=True)

fig2, ax2 = plt.subplots(figsize=(6,3))
sns.barplot(data=comp, x="Model", y="Adj.R²", ax=ax2)
ax2.set_ylim(0, 1)
st.pyplot(fig2)

with st.expander("📄 Full regression summaries"):
    for name, m in results.items():
        st.markdown(f"### {name}")
        st.text(m.summary())