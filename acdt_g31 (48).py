# -*- coding: utf-8 -*-
"""acdt_g31

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F5fm0D95_3CLMpKv3LVVCJCWz4Vwmcv_
"""

import warnings
warnings.filterwarnings("ignore")

import streamlit as st
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import statsmodels.formula.api as smf
from difflib import get_close_matches

st.set_page_config(page_title="ACDT G31 – GERD(2020) → GDP(2023)", layout="wide")

# ==== 설정 ====
DATA_FILE = "ACDT_final_dataset.csv"
GDP_NAME  = "Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)"
GERD_NAME = "Gross Domestic Expenditure on R&D (GERD) (current PPP USD)"
# 분석에 사용할 매개변수, 혼란변수, 조절변수 이름을 리스트로 입력하세요.
# 사용자가 제공한 새로운 변수 리스트를 반영합니다.
MEDIATOR_NAMES = [
    "Resident Patent Applications",
    "Non-Resident Patent Applications",
    "R&D Researchers per Million People",
    "High-tech Export Share (% of Manufactured Exports)",
    "Business R&D Personnel (FTE)",
]
CONFOUNDER_NAMES = [
    "GDP per Capita",
    "Labor Force Size",
]
MODERATOR_NAMES  = [
    "Government-financed BERD (%)",
    "Business-financed BERD (%)",
]
X_YEAR = 2020
Y_YEAR = 2023

# ==== CSV 로드 및 안전 파싱(중복처리, 클리닝) ====
@st.cache_data
def read_and_clean(path: str, debug=False) -> pd.DataFrame:
    raw = None
    for enc in ("utf-8-sig", "cp949"):
        try:
            raw = pd.read_csv(path, header=None, encoding=enc, engine="python")
            break
        except Exception:
            continue
    if raw is None:
        raise RuntimeError("CSV 로드 실패")

    if debug:
        st.subheader("DEBUG: Raw CSV preview")
        st.write(f"Shape: {raw.shape}")
        st.write("Years Row:", raw.iloc[0].tolist()[:30])
        st.write("Indicator Row:", raw.iloc[1].tolist()[:30])
        st.dataframe(raw.iloc[:6, :30])
        st.stop()

    if raw.shape[1] == 1:
        sample = "\n".join(raw.iloc[:5, 0].astype(str).tolist())
        sep = next((s for s in [",", "\t", ";"] if s in sample), None)
        if sep:
            raw = raw.iloc[:, 0].astype(str).str.split(sep, expand=True)

    years = raw.iloc[0].astype(str).str.strip()
    indicators = raw.iloc[1].astype(str).str.strip()

    df = raw.iloc[2:].copy()
    df.columns = pd.MultiIndex.from_arrays([indicators, years])

    def clean_col(col):  # 숫자형으로 정제
        col = col.astype(str).str.replace(",", "").str.replace(r"[^0-9.eE+\-]", "", regex=True)
        return pd.to_numeric(col, errors="coerce")

    for c in df.columns:
        df[c] = clean_col(df[c])

    # 연도 컬럼 숫자 가능하면 int 변환
    new_cols = []
    for ind, yr in df.columns:
        try:
            yr_int = int(float(yr))
        except:
            yr_int = yr
        new_cols.append((ind, yr_int))
    df.columns = pd.MultiIndex.from_tuples(new_cols)

    # 중복 (Indicator, Year) 컬럼 평균 통합
    if df.columns.duplicated().any():
        df = df.T.groupby(level=[0, 1]).mean(numeric_only=True).T
        df.index = pd.RangeIndex(len(df))

    return df

# ==== 지표 별 특정 연도 컬럼 추출 ====
def get_series(df: pd.DataFrame, indicator: str, year) -> pd.Series:
    lvl0 = df.columns.get_level_values(0)
    if indicator in set(lvl0):
        subdf = df.loc[:, indicator]
        # 연도 비교를 문자열 및 숫자 모두 고려하여 유연하게 처리
        col_list = [str(col) for col in subdf.columns] if hasattr(subdf, "columns") else []
        year_str = str(year)
        if year_str in col_list:
            # 실제 컬럼 이름을 찾아 사용 (문자열 또는 숫자)
            actual_year_col = next((col for col in subdf.columns if str(col) == year_str), None)
            if actual_year_col is not None:
                 return df.loc[:, (indicator, actual_year_col)]

    return pd.Series([np.nan]*len(df), index=df.index)

# ==== 회귀 데이터셋 빌드 ====
def build_regression_df(df: pd.DataFrame):
    out = pd.DataFrame(index=df.index)
    out["GERD"] = get_series(df, GERD_NAME, X_YEAR)
    out["GDP"] = get_series(df, GDP_NAME, Y_YEAR)
    # MEDIATOR_NAMES, CONFOUNDER_NAMES, MODERATOR_NAMES 리스트가 채워져야 해당 변수들이 추가됩니다.
    for v in CONFOUNDER_NAMES + MEDIATOR_NAMES + MODERATOR_NAMES:
        out[v] = get_series(df, v, Y_YEAR)

    out["ln_GERD"] = np.log(out["GERD"].replace(0, np.nan))
    out["ln_GDP"] = np.log(out["GDP"].replace(0, np.nan))
    # 로그 변환 후 무한대 값도 제거
    out = out.replace([np.inf, -np.inf], np.nan)
    out = out.dropna(subset=["ln_GERD", "ln_GDP"]).reset_index(drop=True)
    return out

# ==== 모델링 ====
def run_models(df):
    confs = [c for c in CONFOUNDER_NAMES if c in df.columns]
    meds = [m for m in MEDIATOR_NAMES if m in df.columns]
    mods = [m for m in MODERATOR_NAMES if m in df.columns]

    # 변수가 없으면 해당 모델 건너뛰기
    m1, m2, m3, m4 = None, None, None, None

    try:
        m1 = smf.ols("ln_GDP ~ ln_GERD", data=df).fit()
    except Exception as e:
        st.warning(f"M1 모델 생성 오류: {e}")

    rhs2 = "ln_GERD" + (" + " + " + ".join(f'Q("{c}")' for c in confs) if confs else "")
    if rhs2 != "ln_GERD": # 혼란변수가 있을 경우에만 시도
        try:
            m2 = smf.ols(f"ln_GDP ~ {rhs2}", data=df).fit()
        except Exception as e:
            st.warning(f"M2 모델 생성 오류: {e}")

    rhs3 = rhs2 + (" + " + " + ".join(f'Q("{m}")' for m in meds) if meds else "")
    if rhs3 != rhs2: # 매개변수가 있을 경우에만 시도
        try:
            m3 = smf.ols(f"ln_GDP ~ {rhs3}", data=df).fit()
        except Exception as e:
            st.warning(f"M3 모델 생성 오류: {e}")

    interaction = " + ".join(f'ln_GERD * Q("{mo}")' for mo in mods) if mods else ""
    rhs4 = rhs3 + (f" + {interaction}" if interaction else "")
    if rhs4 != rhs3: # 조절변수가 있을 경우에만 시도
         try:
             m4 = smf.ols(f"ln_GDP ~ {rhs4}", data=df).fit()
         except Exception as e:
             st.warning(f"M4 모델 생성 오류: {e}")


    def pick_key(model, key="ln_GERD"):
        if model is None:
            return (np.nan, np.nan, np.nan)
        return (model.params.get(key, np.nan),
                model.pvalues.get(key, np.nan),
                model.rsquared_adj)

    summary_data = []
    # 모델이 성공적으로 생성된 경우에만 결과 포함
    for label, model in [("M1", m1), ("M2", m2), ("M3", m3), ("M4", m4)]:
        if model is not None:
            beta, pval, adjr2 = pick_key(model)
            summary_data.append([label, beta, pval, adjr2])

    summary_df = pd.DataFrame(summary_data, columns=["Model", "β", "p-value", "Adj R2"]).round(4)
    return {"M1": m1, "M2": m2, "M3": m3, "M4": m4}, summary_df

# ==== 앱 UI 시작 ====
st.title("ACDT G31 – GERD(2020) → GDP(2023) 회귀분석")

debug_flag = st.sidebar.checkbox("Debug: 원본 CSV 첫 두 행 출력 후 중단", False)

try:
    df_multi = read_and_clean(DATA_FILE, debug=debug_flag)
except Exception as e:
    st.error(f"데이터 로딩 실패: {e}")
    st.stop()

if debug_flag:
    st.info("디버그 모드 활성화로 앱 중단")
    st.stop() # debug 모드일 때 여기서 앱 실행을 완전히 중단

available_inds = sorted(set(df_multi.columns.get_level_values(0)))
needed_vars = [GDP_NAME, GERD_NAME] + MEDIATOR_NAMES + CONFOUNDER_NAMES + MODERATOR_NAMES
missing_vars = [v for v in needed_vars if v and v not in available_inds] # 빈 문자열이나 None값 제외
if missing_vars:
    st.warning("데이터셋에 다음 지표명이 없습니다:")
    for m in missing_vars:
        cands = get_close_matches(m, available_inds, n=3, cutoff=0.6)
        st.write(f"- **{m}** → 후보: {cands if cands else '일치하는 후보 없음'}")
    st.info("필요한 지표명이 데이터셋에 정확히 존재해야 회귀 데이터 생성이 가능합니다.")


st.header("데이터 기초 통계 및 상관관계")
flat_df = df_multi.copy()
# MultiIndex 컬럼을 문자열로 변환 시, 연도 부분도 포함되도록 수정
flat_df.columns = [f"{a} [{b}]" for a, b in flat_df.columns]
num_df = flat_df.select_dtypes(include=np.number)
if not num_df.empty and len(num_df.columns) > 1: # 숫자 컬럼이 있고 두 개 이상일 경우에만 상관관계 계산 가능
    st.write(num_df.describe().T)
    try:
        fig, ax = plt.subplots(figsize=(12, 7))
        # 상관관계 계산 시 NaN 값 처리 (기본값 'pearson'은 NaN을 건너뜀)
        corr_matrix = num_df.corr()
        sns.heatmap(corr_matrix, cmap="coolwarm", center=0, ax=ax)
        ax.set_title("상관관계 행렬 (숫자형 변수)")
        st.pyplot(fig)
    except Exception as e:
        st.info(f"상관관계 시각화 중 오류 발생: {e} (숫자형 변수가 부족하거나 데이터에 문제가 있을 수 있습니다.)")
else:
    st.info("숫자형 변수가 부족하여 기초 통계 또는 상관관계 시각화를 생성할 수 없습니다.")


# 회귀분석 데이터셋 생성
reg_df = build_regression_df(df_multi)
# 회귀 분석에 필요한 최소 변수(ln_GERD, ln_GDP)가 있는지 확인
required_reg_cols = ["ln_GERD", "ln_GDP"]
if reg_df.empty or not all(col in reg_df.columns for col in required_reg_cols) or reg_df.dropna(subset=required_reg_cols).shape[0] < 2: # 최소 2개 이상의 데이터 포인트 필요
    st.error("회귀 분석에 사용할 적절한 데이터가 부족합니다. 데이터셋 및 지표명, 연도를 확인해주세요.")
    st.stop()

st.subheader("회귀분석용 데이터 샘플")
st.dataframe(reg_df.head())

st.subheader("ln(GERD)와 ln(GDP) 산점도")
try:
    fig_scat, ax_scat = plt.subplots(figsize=(7, 5))
    # 산점도 그릴 데이터 확인
    if not reg_df[["ln_GERD", "ln_GDP"]].dropna().empty:
        sns.regplot(x="ln_GERD", y="ln_GDP", data=reg_df, scatter_kws={"alpha":0.6}, ax=ax_scat)
        ax_scat.set_xlabel(f"ln {GERD_NAME} ({X_YEAR})")
        ax_scat.set_ylabel(f"ln {GDP_NAME} ({Y_YEAR})")
        st.pyplot(fig_scat)
    else:
        st.info("ln(GERD)와 ln(GDP) 산점도를 그릴 데이터가 부족합니다.")
except Exception as e:
    st.info(f"산점도 시각화 중 오류 발생: {e}")


models, summary = run_models(reg_df)
st.subheader("회귀 모델 비교 요약")
if not summary.empty:
    st.dataframe(summary)

    fig_bar, ax_bar = plt.subplots(figsize=(6, 4))
    sns.barplot(x="Model", y="Adj R2", data=summary, ax=ax_bar)
    # ymax 계산 시 summary가 비어있지 않은지 확인
    ymax = float(summary["Adj R2"].max()) if not summary.empty else 1.0
    ax_bar.set_ylim(0, max(0.1, ymax * 1.1))
    ax_bar.set_title("Adjusted R-Squared by Model")
    st.pyplot(fig_bar)
else:
    st.info("회귀 분석 결과 요약을 생성할 수 없습니다 (모델 생성 오류 또는 데이터 부족).")


with st.expander("모델별 회귀 상세 결과 보기"):
    # 모델이 성공적으로 생성된 경우에만 상세 결과 표시
    if models:
        for label, model in models.items():
            if model is not None:
                st.markdown(f"**{label}**")
                st.text(model.summary())
            else:
                st.markdown(f"**{label}**: 모델 생성 실패 또는 해당 변수 부족")
    else:
        st.info("표시할 모델 결과가 없습니다.")


st.markdown("""
### 요약
- 원본 Colab 대비 새 구조
  - CSV 로딩 단계서 원시 헤더 디버그 옵션 추가
  - 컬럼명 중복 완전 평균 처리 보장
  - 변수명 맞춤과 근사치 안내 추가
  - 모든 Series/DataFrame 조건문에서 명확한 bool값 판단으로 에러 방지
  - 시각화 부분 안정성 보강
- 포함 기능
  - 데이터 원시 검사 및 헤더 확인(debug)
  - 중복된 연도/지표 평균 처리로 중복 문제 완화
  - 로그 변환 후 단순 회귀 및 다중 회귀 (confounder, mediator, moderator 포함)
  - 변수명 자동 검사 및 후보 추천
  - 상관관계 히트맵 및 산점도 시각화
  - 다양한 회귀모형 비교표 및 상세 결과 제공
""")