# -*- coding: utf-8 -*-
"""acdt_g31

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F5fm0D95_3CLMpKv3LVVCJCWz4Vwmcv_
"""

# ============================================
# ACDT G31 â€“ GERD(2020) â†’ GDP(2023)
# Full Regressions (Model 1â€“4) + Viz + Summary
# - CSV: 0í–‰=Year, 1í–‰=Indicator, 2í–‰~ ë°ì´í„°
# - í•œ ì—´ CSV(í…ìŠ¤íŠ¸)ë„ ì•ˆì „ ë¶„í•  (ì ˆëŒ€ Seriesë¥¼ ì¡°ê±´ì— ì“°ì§€ ì•ŠìŒ)
# - ìˆ«ì ì •ì œëŠ” Series ì „ìš© .str ì‚¬ìš©
# - (Indicator, Year) ì¤‘ë³µì—´ì€ í‰ê· ìœ¼ë¡œ í†µí•©
# ============================================

import streamlit as st
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import statsmodels.formula.api as smf

st.set_page_config(page_title="ACDT G31 â€“ GERD(2020) â†’ GDP(2023)", layout="wide")

DATA_FILE = "ACDT_final_dataset.csv"  # ì•±ê³¼ ê°™ì€ í´ë”

# ----- ë°ì´í„°ì…‹ì˜ ì •í™•í•œ ë¼ë²¨ (CSV í—¤ë”ì™€ 100% ì¼ì¹˜í•´ì•¼ í•¨) -----
GDP_NAME  = "Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)"
GERD_NAME = "Gross Domestic Expenditure on R&D (GERD) (current PPP USD)"

MEDIATOR_NAMES = [
    "Resident Patent Applications",
    "Non-Resident Patent Applications",
    "R&D Researchers per Million People",
    "High-tech Export Share (% of Manufactured Exports)",
    "Business R&D Personnel (FTE)",
]
CONFOUNDER_NAMES = ["GDP per Capita", "Labor Force Size"]
MODERATOR_NAMES  = ["Government-financed BERD (%)", "Business-financed BERD (%)"]

X_YEAR = 2020       # GERDëŠ” 2020ë…„
Y_YEAR = 2023       # GDP ë° ë‚˜ë¨¸ì§€ ë³€ìˆ˜ëŠ” 2023ë…„ (ìš”êµ¬ì‚¬í•­ ë°˜ì˜)

# ---------- ì•ˆì „ CSV íŒŒì„œ (Series truth ë°©ì§€) ----------
def read_as_multiindex(path: str) -> pd.DataFrame:
    """CSV â†’ 0í–‰=Year, 1í–‰=Indicator, MultiIndex columns.
       - í•œ ì—´ CSVë„ ë¬¸ìì—´ë§Œìœ¼ë¡œ ë¶„ë¦¬ì ê°ì§€/ë¶„í•  (Seriesë¥¼ ifì— ì ˆëŒ€ ì‚¬ìš© ì•ˆí•¨)
       - ìˆ«ì ì •ì œëŠ” Seriesì—ì„œë§Œ .str ì‚¬ìš©
       - ì¤‘ë³µ (Indicator,Year)ì€ í‰ê· ìœ¼ë¡œ í†µí•©
    """
    raw, last_err = None, None
    for enc in ("utf-8-sig", "cp949"):
        try:
            raw = pd.read_csv(path, header=None, encoding=enc, engine="python")
            break
        except Exception as e:
            last_err = e
    if raw is None:
        raise RuntimeError(f"CSV read failed: {last_err}")

    # í•œ ì—´ CSV ì²˜ë¦¬: ìƒ˜í”Œ ë¬¸ìì—´ í•˜ë‚˜ë¡œë§Œ ë¶„ë¦¬ì íƒì§€ (Seriesë¥¼ ì¡°ê±´ì— ì“°ì§€ ì•ŠìŒ)
    if int(raw.shape[1]) == 1:
        try:
            n = int(min(5, len(raw)))
            sample_text = "\n".join(raw.iloc[:n, 0].astype(str).tolist())
            # ë¬¸ìì—´ find() ì‚¬ìš© (ë¶ˆë¦¬ì–¸ ëª¨í˜¸ì„± ì™„ì „ íšŒí”¼)
            seps = [",", "\t", ";"]
            found_sep = None
            for s in seps:
                if sample_text.find(s) != -1:
                    found_sep = s
                    break
            if found_sep is not None:
                s = raw.iloc[:, 0].astype(str)          # ë°˜ë“œì‹œ Series
                raw = s.str.split(found_sep, expand=True)
        except Exception:
            # ì‹¤íŒ¨ ì‹œ ì›ë³¸ ìœ ì§€
            pass

    # 0í–‰=ì—°ë„, 1í–‰=ì§€í‘œëª…
    years = raw.iloc[0].astype(str).str.strip().values
    names = raw.iloc[1].astype(str).str.strip().values
    df = raw.iloc[2:].copy()

    # MultiIndex columns
    df.columns = pd.MultiIndex.from_arrays([names, years], names=["Indicator", "Year"])

    # ìˆ«ì ì •ì œ(Series ì „ìš© .str)
    def clean_series(s: pd.Series) -> pd.Series:
        s = s.astype(str)
        s = s.str.replace(",", "", regex=False)
        s = s.str.replace(r"[^0-9eE+\-\.]", "", regex=True)
        return pd.to_numeric(s, errors="coerce")

    for j in range(df.shape[1]):
        df.iloc[:, j] = clean_series(df.iloc[:, j])

    # Yearë¥¼ ì •ìˆ˜ë¡œ ë°”ê¿€ ìˆ˜ ìˆìœ¼ë©´ ë³€í™˜
    try:
        new_cols = []
        for ind, yr in df.columns:
            ystr = str(yr)
            if ystr.replace(".", "", 1).isdigit():
                yv = int(float(ystr))
            else:
                yv = yr
            new_cols.append((ind, yv))
        df.columns = pd.MultiIndex.from_tuples(new_cols, names=["Indicator", "Year"])
    except Exception:
        pass

    # (Indicator, Year) ì¤‘ë³µì—´ â†’ í‰ê·  í†µí•©
    if bool(df.columns.duplicated(keep=False).any()):
        df = df.T.groupby(level=["Indicator", "Year"]).mean(numeric_only=True).T

    df.index = pd.RangeIndex(len(df))
    return df


def s_at(df_mi: pd.DataFrame, name: str, year) -> pd.Series:
    """(Indicator=name, Year=year) Series ì•ˆì „ ì¶”ì¶œ. ì—†ìœ¼ë©´ NaN Series ë°˜í™˜."""
    lvl0 = df_mi.columns.get_level_values(0)
    if name in set(lvl0):
        sub = df_mi.loc[:, name]  # (í–‰ x Year)
        if year in set(sub.columns):
            return df_mi.loc[:, (name, year)]
    return pd.Series([np.nan] * len(df_mi), index=df_mi.index)


def build_pair_dataset(df_mi: pd.DataFrame, x_year: int, y_year: int) -> pd.DataFrame:
    """GERD(x_year) â†’ GDP(y_year), ê·¸ ì™¸ ëª¨ë“  ë³€ìˆ˜(y_year)ì— ë§ì¶° êµ¬ì„± + ë¡œê·¸ ë³€í™˜."""
    out = pd.DataFrame(index=df_mi.index)
    out["GERD"] = s_at(df_mi, GERD_NAME, x_year)   # 2020
    out["GDP"]  = s_at(df_mi, GDP_NAME,  y_year)   # 2023

    # ë‚˜ë¨¸ì§€ ë³€ìˆ˜ëŠ” ëª¨ë‘ y_year(=2023)
    for v in CONFOUNDER_NAMES + MEDIATOR_NAMES + MODERATOR_NAMES:
        out[v] = s_at(df_mi, v, y_year)

    # ë¡œê·¸ ë³€í™˜: 0 â†’ NaN
    out["ln_X"] = np.log(out["GERD"].replace({0: np.nan}))
    out["ln_Y"] = np.log(out["GDP"].replace({0: np.nan}))
    return out.dropna(subset=["ln_X", "ln_Y"]).reset_index(drop=True)


def run_models(df_reg: pd.DataFrame):
    """Model1~4 ì‹¤í–‰ + ë¹„êµí‘œ."""
    confs = [c for c in CONFOUNDER_NAMES if c in df_reg.columns]
    meds  = [m for m in MEDIATOR_NAMES  if m in df_reg.columns]
    mods  = [m for m in MODERATOR_NAMES if m in df_reg.columns]

    # M1
    m1 = smf.ols("ln_Y ~ ln_X", data=df_reg).fit()

    # M2
    rhs2 = "ln_X" + ((" + " + " + ".join([f'Q(\"{c}\")' for c in confs])) if len(confs) > 0 else "")
    m2 = smf.ols(f"ln_Y ~ {rhs2}", data=df_reg).fit()

    # M3
    rhs3 = rhs2 + ((" + " + " + ".join([f'Q(\"{m}\")' for m in meds])) if len(meds) > 0 else "")
    m3 = smf.ols(f"ln_Y ~ {rhs3}", data=df_reg).fit()

    # M4 (interaction)
    inter = " + ".join([f'ln_X * Q(\"{mo}\")' for mo in mods]) if len(mods) > 0 else ""
    rhs4 = rhs3 if len(inter) == 0 else f"{rhs3} + {inter}"
    m4 = smf.ols(f"ln_Y ~ {rhs4}", data=df_reg).fit()

    def pick(mod, key="ln_X"):
        return mod.params.get(key, np.nan), mod.pvalues.get(key, np.nan), mod.rsquared_adj

    rows = []
    for label, mod in [("M1: lnY~lnX", m1), ("M2:+conf", m2), ("M3:+med", m3), ("M4:+mods", m4)]:
        beta, pval, adjr2 = pick(mod, "ln_X")
        rows.append([label, beta, pval, adjr2])

    summary = pd.DataFrame(rows, columns=["Model", "Î²(ln_X)", "p(ln_X)", "Adj.RÂ²"]).round(4)
    return {"M1": m1, "M2": m2, "M3": m3, "M4": m4}, summary


# ----------------- ì•± ë³¸ë¬¸ -----------------
st.title("ğŸ“ˆ GERD(2020) â†’ GDP(2023) â€“ Full Regressions (Model 1â€“4)")

# ë””ë²„ê·¸ìš© ê°„ë‹¨ ì •ë³´(í•„ìš” ì‹œ ì£¼ì„ í•´ì œ)
# st.caption(f"Expecting X=GERD({X_YEAR}), Y=GDP({Y_YEAR}) and all others at {Y_YEAR}")

try:
    df_mi = read_as_multiindex(DATA_FILE)
except Exception as e:
    st.error(f"Error loading data: {e}")
    st.stop()

st.success("âœ… Dataset loaded & cleaned (Row0=Year / Row1=Indicator).")

# ë¶„í¬/ìƒê´€ (Colab ìŠ¤íƒ€ì¼ ìš”ì•½)
st.header("ğŸ“Š Distributions & Correlations")
flat = df_mi.copy()
flat.columns = [f"{a} [{b}]" for a, b in flat.columns]
num_only = flat.select_dtypes(include=np.number)

if bool(num_only.empty) is False:
    st.write(num_only.describe().T)
    try:
        fig_corr, ax_corr = plt.subplots(figsize=(12, 7))
        sns.heatmap(num_only.corr(), cmap="coolwarm", center=0, ax=ax_corr)
        ax_corr.set_title("Correlation Heatmap")
        st.pyplot(fig_corr)
    except Exception:
        st.info("Correlation heatmap skipped.")

# ê³ ì • í˜ì–´: GERD(2020) â†’ GDP(2023)
st.markdown("---")
st.header(f"ğŸ§® Pair: GERD({X_YEAR}) â†’ GDP({Y_YEAR}) (All others at {Y_YEAR})")

df_reg = build_pair_dataset(df_mi, X_YEAR, Y_YEAR)
if df_reg.empty:
    st.warning("No valid observations for this pair after cleaning (ln_X/ln_Y). Check labels/years.")
    st.stop()

st.subheader("ğŸ“‹ Regression dataset (preview)")
st.dataframe(df_reg.head())

# ì‚°ì ë„ + íšŒê·€ì„  (Colab ì‹œê°í™” ìœ ì§€)
st.subheader("ğŸ“‰ ln(GERD) vs ln(GDP)")
fig_sc, ax_sc = plt.subplots(figsize=(7, 5))
sns.regplot(x="ln_X", y="ln_Y", data=df_reg, scatter_kws={"alpha": 0.6}, ax=ax_sc)
ax_sc.set_xlabel(f"ln GERD ({X_YEAR})")
ax_sc.set_ylabel(f"ln GDP ({Y_YEAR})")
st.pyplot(fig_sc)

# Model 1â€“4
models, table = run_models(df_reg)
st.subheader("ğŸ“˜ Model Comparison")
st.dataframe(table)

fig_r2, ax_r2 = plt.subplots(figsize=(6, 4))
sns.barplot(x="Model", y="Adj.RÂ²", data=table, ax=ax_r2)
ymax = float(table["Adj.RÂ²"].max()) if len(table) else 1.0
ax_r2.set_ylim(0, max(0.1, ymax) * 1.1)
ax_r2.set_title("Adjusted RÂ² across models")
st.pyplot(fig_r2)

with st.expander("Full regression summaries"):
    for k, m in models.items():
        st.markdown(f"**{k}**")
        st.text(m.summary())

# í•´ì„ (Colab ì„¤ëª… ë°˜ì˜)
st.markdown("""
### ğŸ§© Interpretation (2020â†’2023)
- **Model 1**: lnGERD(2020) â†’ lnGDP(2023) ê¸°ë³¸ íƒ„ë ¥ì„±.
- **Model 2**: GDP per Capita, Labor Force(2023) í†µì œë¡œ **í˜¼ë€íš¨ê³¼** ì ê²€(lnGERD ê³„ìˆ˜ ë³€í™” í™•ì¸).
- **Model 3**: íŠ¹í—ˆÂ·ì—°êµ¬ì¸ë ¥Â·í•˜ì´í…Œí¬ìˆ˜ì¶œÂ·ê¸°ì—…R&Dì¸ë ¥(2023) í¬í•¨ â†’ lnGERD ê³„ìˆ˜ ê°ì†Œ/ìœ ì˜ì„± ë³€í™” ì‹œ **ë§¤ê°œíš¨ê³¼** ì‹œì‚¬.
- **Model 4**: Government/Business-financed BERD(2023) ìƒí˜¸ì‘ìš© p<0.05ë©´ **ì¡°ì ˆíš¨ê³¼** ìœ ì˜.
""")