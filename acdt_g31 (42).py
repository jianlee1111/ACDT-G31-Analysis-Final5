# -*- coding: utf-8 -*-
"""acdt_g31

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F5fm0D95_3CLMpKv3LVVCJCWz4Vwmcv_
"""

import re
import numpy as np
import pandas as pd
import streamlit as st
import statsmodels.formula.api as smf
import matplotlib.pyplot as plt
import seaborn as sns

st.set_page_config(page_title="GERD(2020) â†’ GDP(2023) â€“ Full Regressions", layout="wide")

CSV_NAME = "ACDT_final_dataset.csv"   # ë ˆí¬ ë£¨íŠ¸ì— ë‘” íŒŒì¼ëª…

# ---------- ìœ í‹¸ ----------
def coerce_numeric(x: str):
    """ë¬¸ì ì„ì¸ ìˆ˜ì¹˜ -> float; ì—†ìœ¼ë©´ NaN"""
    if pd.isna(x):
        return np.nan
    s = str(x)
    # ê´„í˜¸ì™€ í…ìŠ¤íŠ¸ ì œê±°, ìˆ«ì/./-/, ë§Œ ë‚¨ê¹€
    s = re.sub(r"\([^)]*\)", "", s)
    s = re.sub(r"[^0-9\.,\-]", "", s)
    # ì²œë‹¨ìœ„ ì½¤ë§ˆ ì œê±°
    s = s.replace(",", "")
    try:
        return float(s) if s not in ("", "-", "--") else np.nan
    except:
        return np.nan

def anycol(df, patterns):
    """ì—¬ëŸ¬ íŒ¨í„´ ì¤‘ ì²« ë§¤ì¹­ ì»¬ëŸ¼ëª… ë°˜í™˜(None ê°€ëŠ¥). ëŒ€ì†Œë¬¸ì ë¬´ì‹œ."""
    cols = list(df.columns)
    for p in patterns:
        r = re.compile(p, flags=re.I)
        hit = [c for c in cols if r.search(str(c))]
        if hit:
            return hit[0]
    return None

# ---------- 1) ë¡œë“œ/ì •ë¦¬ ----------
@st.cache_data(show_spinner=True)
def load_and_tidy(csv_name=CSV_NAME):
    raw = pd.read_csv(csv_name, header=None)
    # ì²« ì—´ ì´ë¦„ì€ 'Country'ë¡œ í†µì¼
    raw.iloc[0, 0] = "Country"
    raw.iloc[1, 0] = "Indicator"

    years_row = raw.iloc[0].fillna("").astype(str).tolist()
    ind_row   = raw.iloc[1].fillna("").astype(str).tolist()

    # MultiIndex ì»¬ëŸ¼ ë§Œë“¤ê¸°: (Indicator, Year). ì²« ì—´ì€ (Country, "")
    cols = []
    for j in range(raw.shape[1]):
        if j == 0:
            cols.append(("Country", ""))
        else:
            year = years_row[j].strip()
            ind  = ind_row[j].strip()
            cols.append((ind, year))
    raw.columns = pd.MultiIndex.from_tuples(cols, names=["Indicator", "Year"])

    # ì‹¤ì œ ë°ì´í„°: í—¤ë” 2í–‰ ì œê±°
    df = raw.iloc[2:].copy()
    df = df.rename(columns={("Country",""): "Country"})
    df["Country"] = df["Country"].astype(str).str.strip()

    # ê°’ ì „ë¶€ ìˆ«ìí™”
    value_cols = [(i, y) for (i, y) in df.columns if i not in ("Country")]
    for (i, y) in value_cols:
        df[(i, y)] = df[(i, y)].apply(coerce_numeric)

    # Long í˜•íƒœë¡œ í”¼ë²—
    long = (
        df
        .set_index("Country")
        .stack(level=["Indicator", "Year"])
        .reset_index()
        .rename(columns={0: "value"})
    )
    # â€œë¹ˆ indicatorâ€ ì œê±°
    long = long[long["Indicator"].astype(str).str.len() > 0]

    # Wide í˜•íƒœ(Indicator-ì—°ë„ë¥¼ í•˜ë‚˜ì˜ ì»¬ëŸ¼ìœ¼ë¡œ)ë„ ë§Œë“¤ì–´ë‘ê¸°
    long["colkey"] = long["Indicator"].str.strip() + " | " + long["Year"].str.strip()
    wide = long.pivot_table(index="Country", columns="colkey", values="value", aggfunc="first")
    wide.columns = wide.columns.astype(str)

    return long, wide

# ---------- 2) ì»¬ëŸ¼ ë§¤í•‘ ----------
def extract_columns(wide, gerd_year="2020", gdp_year="2023"):
    """
    GERD(ì—°ë„), Real GDP(ì—°ë„) ë“± ëª¨ë¸ì— í•„ìš”í•œ ì£¼ìš” ë³€ìˆ˜ ì¶”ì¶œ.
    """
    # ê°€ëŠ¥í•œ íŒ¨í„´(ìš°ì„ ìˆœìœ„ ìˆœ)
    gerd_candidates = [
        r"Gross Domestic Expenditure on R&D.*current.*USD",  # ê¸ˆì•¡ê¸°ì¤€ GERD
        r"GERD.*current.*USD",
        r"R&D Expenditure Ratio.*% of GDP",           # ë¹„ìœ¨ GERD (ëŒ€ì²´)
        r"R&D Expenditure Ratio"
    ]
    gdp_real_pat     = r"Real GDP \(billion USD.*Chain-weighted.*2020 base year\)"
    patents_res_pat  = r"Resident Patent Applications"
    patents_non_pat  = r"Non-Resident Patent Applications"
    rd_researchers   = r"Number of R&D Researcher"
    hightech_share   = r"High-Tech Export Share.*% of Manufacturing Exports"
    gdp_capita_pat   = r"GDP per Capita \(USD per person, PPP-based, Nominal\)"
    berd_gov_pat     = r"Government-financed BERD.*"   # ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ ë¬´ì‹œ
    berd_biz_pat     = r"Business-financed BERD.*"

    # ê° ë³€ìˆ˜ì˜ ì‹¤ì œ ì»¬ëŸ¼ëª… íƒìƒ‰ í•¨ìˆ˜
    def find_col(regex, year):
        # ì˜ˆ: "Real GDP (...) | 2023" í˜•íƒœ
        candidates = [c for c in wide.columns if re.search(regex, c, flags=re.I) and c.strip().endswith(f"| {year}")]
        return candidates[0] if candidates else None

    # GERD(ì—°ë„)
    gerd_col = None
    for pat in gerd_candidates:
        hit = find_col(pat, gerd_year)
        if hit:
            gerd_col = hit; break

    # GDP_real(ì—°ë„)
    gdp_col = find_col(gdp_real_pat, gdp_year)

    # Mediators / Confounders (2023 ê³ ì • ê¶Œì¥)
    res_pat_col = find_col(patents_res_pat, "2023")
    non_pat_col = find_col(patents_non_pat, "2023")
    rd_col      = find_col(rd_researchers, "2023")
    hte_col     = find_col(hightech_share, "2023")
    gdp_pc_col  = find_col(gdp_capita_pat, "2023")
    berd_gov_col= anycol(wide, [r"Government-financed BERD \(%\) \| 2023"])
    berd_biz_col= anycol(wide, [r"Business-financed BERD \(%\) \| 2023"])

    found = {
        "GERD": gerd_col,
        "Real_GDP": gdp_col,
        "Resident_Patents": res_pat_col,
        "NonResident_Patents": non_pat_col,
        "R&D_Researchers_per_million": rd_col,
        "HighTech_Export_Share": hte_col,
        "GDP_per_Capita": gdp_pc_col,
        "GovFinanced_BERD_pct": berd_gov_col,
        "BizFinanced_BERD_pct": berd_biz_col,
    }
    return found

# ---------- 3) ëª¨ë¸ êµ¬ì„± ----------
def build_model_df(wide, mapping):
    """
    ë§¤í•‘ëœ ì»¬ëŸ¼ìœ¼ë¡œ ë¶„ì„ìš© DF êµ¬ì„± + ë¡œê·¸ë³€í™˜ ì»¬ëŸ¼ ìƒì„±.
    """
    missing = [k for k, v in mapping.items() if k in ("GERD","Real_GDP") and (v is None)]
    if len(missing) > 0:
        return None, f"Required columns missing: {missing}"

    use_cols = {k:v for k,v in mapping.items() if v is not None}
    dfm = wide[list(use_cols.values())].copy()
    dfm.columns = list(use_cols.keys())

    # ë¡œê·¸ ë³€í™˜(ì–‘ìˆ˜ë§Œ)
    for c in ("GERD", "Real_GDP", "GDP_per_Capita"):
        if c in dfm.columns:
            dfm[f"ln_{c}"] = np.where(dfm[c] > 0, np.log(dfm[c]), np.nan)

    # ê²°ì¸¡ í–‰ ì œê±°
    core = ["ln_GERD", "ln_Real_GDP"]
    core = [c for c in core if c in dfm.columns]
    dfm = dfm.dropna(subset=core)

    return dfm.reset_index(), None  # indexê°€ Country

def fit_models(dfm):
    """
    Model 1~4 ì í•©.
    Model1: ln_GDP ~ ln_GERD
    Model2: + confounder(GDP_per_Capita)
    Model3: + mediators(íŠ¹í—ˆ, ì—°êµ¬ì, í•˜ì´í…Œí¬)
    Model4: + moderator(ì •ë¶€/ë¯¼ê°„ BERD %) ìƒí˜¸ì‘ìš©
    """
    results = {}

    # Model 1
    m1 = smf.ols("ln_Real_GDP ~ ln_GERD", data=dfm).fit()
    results["Model 1"] = m1

    # Model 2 (confounder)
    if "ln_GERD" in dfm and "GDP_per_Capita" in dfm:
        m2 = smf.ols("ln_Real_GDP ~ ln_GERD + GDP_per_Capita", data=dfm).fit()
    else:
        m2 = m1
    results["Model 2"] = m2

    # Model 3 (mediators)
    meds = [c for c in ["Resident_Patents","NonResident_Patents","R&D_Researchers_per_million","HighTech_Export_Share"] if c in dfm.columns]
    if len(meds) > 0:
        f3 = "ln_Real_GDP ~ ln_GERD + " + " + ".join(meds)
        m3 = smf.ols(f3, data=dfm).fit()
    else:
        m3 = m2
    results["Model 3"] = m3

    # Model 4 (moderators: interaction)
    mods = [c for c in ["GovFinanced_BERD_pct","BizFinanced_BERD_pct"] if c in dfm.columns]
    if len(mods) > 0:
        inter = " + ".join([f"ln_GERD:{m}" for m in mods])
        rhs = "ln_GERD " + ("+ " + " + ".join(meds) if len(meds)>0 else "") + (" + " + " + ".join(mods) if len(mods)>0 else "") + " + " + inter
        m4 = smf.ols(f"ln_Real_GDP ~ {rhs}", data=dfm).fit()
    else:
        m4 = m3
    results["Model 4"] = m4

    return results

# ---------- 4) ì•± ----------
st.title("ğŸ“ˆ GERD(2020) â†’ GDP(2023) â€“ Full Regressions (Model 1â€“4)")

with st.spinner("Loading & cleaning data..."):
    try:
        long, wide = load_and_tidy(CSV_NAME)
    except Exception as e:
        st.error(f"âŒ Error loading data: {e}")
        st.stop()

st.success(f"Loaded shape: long={long.shape}, wide={wide.shape}")

# ì—°ë„ ì„ íƒ(ê¸°ë³¸: GERD 2020, GDP 2023)
colA, colB = st.columns(2)
with colA: gerd_year = st.selectbox("GERD year", ["2020","2021","2022","2023"], index=0)
with colB: gdp_year  = st.selectbox("GDP(Real) year", ["2023","2022","2021"], index=0)

mapping = extract_columns(wide, gerd_year=gerd_year, gdp_year=gdp_year)

with st.expander("ğŸ” Matched columns (debug)"):
    st.json(mapping)

dfm, err = build_model_df(wide, mapping)
if err:
    st.error(f"âŒ {err}")
    st.stop()

st.subheader("ğŸ§± Analysis Data (head)")
st.dataframe(dfm.head(10), use_container_width=True)

# ë¶„í¬ ì‹œê°í™”(ìš”ì²­)
st.subheader("ğŸ“Š Variable Distributions")
num_cols = [c for c in dfm.columns if dfm[c].dtype != "O"]
sel = st.multiselect("Select variables to plot", num_cols, default=[c for c in ["ln_GERD","ln_Real_GDP","GDP_per_Capita"] if c in num_cols])
if len(sel) > 0:
    fig, axes = plt.subplots(nrows=len(sel), ncols=1, figsize=(7, 2.8*len(sel)))
    axes = axes if isinstance(axes, np.ndarray) else [axes]
    for ax, c in zip(axes, sel):
        sns.histplot(dfm[c].dropna(), kde=True, ax=ax)
        ax.set_title(c)
    st.pyplot(fig)

# íšŒê·€ ì í•©
results = fit_models(dfm)

st.subheader("ğŸ“˜ Model Comparison")
comp = []
for k,m in results.items():
    coef = m.params.get("ln_GERD", np.nan)
    pval = m.pvalues.get("ln_GERD", np.nan)
    comp.append([k, coef, pval, m.rsquared_adj])
comp_df = pd.DataFrame(comp, columns=["Model","Î²(ln_GERD)","p-value","Adj.RÂ²"])
st.dataframe(comp_df, use_container_width=True)

fig2, ax2 = plt.subplots(figsize=(6,3))
sns.barplot(data=comp_df, x="Model", y="Adj.RÂ²", ax=ax2)
ax2.set_ylim(0, 1)
st.pyplot(fig2)

with st.expander("ğŸ“„ Full summaries"):
    for name, m in results.items():
        st.markdown(f"### {name}")
        st.text(m.summary())

st.markdown("""
**Interpretation (quick):**
- **Model 1**: ln(Real GDP) ~ ln(GERD) ì˜ íƒ„ë ¥ì„± ì¶”ì •
- **Model 2**: GDP per Capita(ì ì¬ êµë€) í†µì œ
- **Model 3**: íŠ¹í—ˆÂ·ì—°êµ¬ì¸ë ¥Â·í•˜ì´í…Œí¬ ìˆ˜ì¶œ(ë§¤ê°œ) í¬í•¨
- **Model 4**: ì •ë¶€/ë¯¼ê°„ BERD ë¹„ì¤‘ê³¼ì˜ ìƒí˜¸ì‘ìš©(ì¡°ì ˆ) í¬í•¨
""")