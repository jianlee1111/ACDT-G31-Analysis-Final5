# -*- coding: utf-8 -*-
"""acdt_g31

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F5fm0D95_3CLMpKv3LVVCJCWz4Vwmcv_
"""

# ============================================
# ACDT G31 – GERD(2020) → GDP(2023) Full App
# - CSV: row0 = Year, row1 = Indicator, row2~ = data
# - Safe parsing (no Series truth in if)
# - Models 1~4: confounder / mediator / moderator
# - Viz + Debug toggle
# ============================================

import warnings
warnings.filterwarnings("ignore")

import streamlit as st
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import statsmodels.formula.api as smf
from difflib import get_close_matches

st.set_page_config(page_title="ACDT G31 – GERD(2020) → GDP(2023)", layout="wide")

# =========================
# CONFIG
# =========================
DATA_FILE = "ACDT_final_dataset.csv"  # 앱과 같은 폴더에 두세요.

# CSV에 들어있는 “정확한” 지표명과 100% 일치해야 함(공백/괄호/기호 포함)
GDP_NAME  = "Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)"
GERD_NAME = "Gross Domestic Expenditure on R&D (GERD) (current PPP USD)"

MEDIATOR_NAMES = [
    "Resident Patent Applications",
    "Non-Resident Patent Applications",
    "R&D Researchers per Million People",
    "High-tech Export Share (% of Manufactured Exports)",
    "Business R&D Personnel (FTE)",
]
CONFOUNDER_NAMES = [
    "GDP per Capita",
    "Labor Force Size",
]
MODERATOR_NAMES  = [
    "Government-financed BERD (%)",
    "Business-financed BERD (%)",
]

X_YEAR = 2020   # GERD 연도
Y_YEAR = 2023   # GDP와 나머지 변수 연도

# =========================
# SAFE CSV PARSER (DEBUG)
# =========================
@st.cache_data
def read_as_multiindex_v2(path: str, debug: bool = False) -> pd.DataFrame:
    """CSV → MultiIndex(Indicator, Year).
       - 0행: Year / 1행: Indicator
       - 단일 컬럼 CSV 시 문자열로 분리자 감지(split)
       - 숫자 정제는 Series 전용 .str 사용
       - 중복 (Indicator,Year) 평균 통합
    """
    raw, last_err = None, None
    for enc in ("utf-8-sig", "cp949"):
        try:
            raw = pd.read_csv(path, header=None, encoding=enc, engine="python")
            break
        except Exception as e:
            last_err = e
    if raw is None:
        raise RuntimeError(f"CSV read failed: {last_err}")

    # 디버그: 원시 헤더/프리뷰 출력 후 중단
    if debug:
        st.subheader("🔎 DEBUG: Raw CSV (before parsing)")
        st.write("raw.shape:", raw.shape)
        r0 = raw.iloc[0]
        r1 = raw.iloc[1]
        if isinstance(r0, pd.DataFrame): r0 = r0.squeeze(axis=0)
        if isinstance(r1, pd.DataFrame): r1 = r1.squeeze(axis=0)
        st.write("row0 (years) — first 30:", r0.astype(str).tolist()[:30])
        st.write("row1 (indicator names) — first 30:", r1.astype(str).tolist()[:30])
        st.dataframe(raw.iloc[:6, :20])
        st.info("⬆️ 위 내용을 캡쳐해서 보내면 바로 맞춰드릴 수 있어요. (파싱은 여기서 중단)")
        st.stop()

    # 단일 컬럼 CSV → 분리자 자동 감지
    if int(raw.shape[1]) == 1:
        try:
            sample_text = "\n".join(raw.iloc[:min(5, len(raw)), 0].astype(str).tolist())
            found_sep = None
            for s in (",", "\t", ";", "|"):
                if sample_text.find(s) != -1:  # 스칼라 문자열 검사
                    found_sep = s
                    break
            if found_sep is not None:
                col0 = raw.iloc[:, 0].astype(str)
                raw = col0.str.split(found_sep, expand=True)
        except Exception:
            pass

    # 헤더 두 줄에서 연도/지표 추출
    row0 = raw.iloc[0]
    row1 = raw.iloc[1]
    if isinstance(row0, pd.DataFrame): row0 = row0.squeeze(axis=0)
    if isinstance(row1, pd.DataFrame): row1 = row1.squeeze(axis=0)

    years = row0.astype(str).str.strip().values
    names = row1.astype(str).str.strip().values

    df = raw.iloc[2:].copy()
    df.columns = pd.MultiIndex.from_arrays([names, years], names=["Indicator", "Year"])

    # 숫자 클리닝 (Series 전용 .str)
    def clean_series(s: pd.Series) -> pd.Series:
        s = s.astype(str)
        s = s.str.replace(",", "", regex=False)
        s = s.str.replace(r"[^0-9eE+\-\.]", "", regex=True)
        return pd.to_numeric(s, errors="coerce")

    for j in range(df.shape[1]):
        df.iloc[:, j] = clean_series(df.iloc[:, j])

    # Year를 가능한 int로 캐스팅
    try:
        new_cols = []
        for ind, yr in df.columns:
            ystr = str(yr)
            if ystr.replace(".", "", 1).isdigit():
                yv = int(float(ystr))
            else:
                yv = yr
            new_cols.append((ind, yv))
        df.columns = pd.MultiIndex.from_tuples(new_cols, names=["Indicator", "Year"])
    except Exception:
        pass

    # (Indicator,Year) 중복 → 평균
    if bool(df.columns.duplicated(keep=False).any()):
        df = df.T.groupby(level=["Indicator", "Year"]).mean(numeric_only=True).T
        df.index = pd.RangeIndex(len(df))

    return df


def s_at_v2(df_mi: pd.DataFrame, name: str, year) -> pd.Series:
    """(Indicator=name, Year=year) Series 안전 반환(없으면 NaN Series)."""
    lvl0 = df_mi.columns.get_level_values(0)
    if name in set(lvl0):
        sub = df_mi.loc[:, name]
        cols = list(sub.columns) if hasattr(sub, "columns") else []
        if year in cols:
            return df_mi.loc[:, (name, year)]
    return pd.Series([np.nan] * len(df_mi), index=df_mi.index)


# =========================
# BUILD REGRESSION DATA
# =========================
def build_pair_dataset(df_mi: pd.DataFrame, x_year: int, y_year: int) -> pd.DataFrame:
    """GERD(x_year) → GDP(y_year), 나머지 모두 y_year 기준으로 구성 + 로그 변환."""
    out = pd.DataFrame(index=df_mi.index)

    out["GERD"] = s_at_v2(df_mi, GERD_NAME, x_year)
    out["GDP"]  = s_at_v2(df_mi, GDP_NAME,  y_year)

    for v in CONFOUNDER_NAMES + MEDIATOR_NAMES + MODERATOR_NAMES:
        out[v] = s_at_v2(df_mi, v, y_year)

    # 로그 변환: 0 → NaN
    out["ln_X"] = np.log(out["GERD"].replace({0: np.nan}))
    out["ln_Y"] = np.log(out["GDP"].replace({0: np.nan}))
    out = out.dropna(subset=["ln_X", "ln_Y"]).reset_index(drop=True)
    return out


def run_models(df_reg: pd.DataFrame):
    """Model 1~4 실행 + 비교표(β_lnX, p_lnX, Adj.R²)."""
    confs = [c for c in CONFOUNDER_NAMES if c in df_reg.columns]
    meds  = [m for m in MEDIATOR_NAMES  if m in df_reg.columns]
    mods  = [m for m in MODERATOR_NAMES if m in df_reg.columns]

    # M1
    m1 = smf.ols("ln_Y ~ ln_X", data=df_reg).fit()
    # M2
    rhs2 = "ln_X" + ((" + " + " + ".join([f'Q(\"{c}\")' for c in confs])) if len(confs) > 0 else "")
    m2 = smf.ols(f"ln_Y ~ {rhs2}", data=df_reg).fit()
    # M3
    rhs3 = rhs2 + ((" + " + " + ".join([f'Q(\"{m}\")' for m in meds])) if len(meds) > 0 else "")
    m3 = smf.ols(f"ln_Y ~ {rhs3}", data=df_reg).fit()
    # M4 (interaction)
    inter = " + ".join([f'ln_X * Q(\"{mo}\")' for mo in mods]) if len(mods) > 0 else ""
    rhs4 = rhs3 if len(inter) == 0 else f"{rhs3} + {inter}"
    m4 = smf.ols(f"ln_Y ~ {rhs4}", data=df_reg).fit()

    def pick(mod, key="ln_X"):
        return mod.params.get(key, np.nan), mod.pvalues.get(key, np.nan), mod.rsquared_adj

    rows = []
    for label, mod in [("M1: lnY~lnX", m1), ("M2:+conf", m2), ("M3:+med", m3), ("M4:+mods", m4)]:
        beta, pval, adjr2 = pick(mod, "ln_X")
        rows.append([label, beta, pval, adjr2])

    summary = pd.DataFrame(rows, columns=["Model", "β(ln_X)", "p(ln_X)", "Adj.R²"]).round(4)
    return {"M1": m1, "M2": m2, "M3": m3, "M4": m4}, summary


# =========================
# UI
# =========================
st.title("📈 GERD(2020) → GDP(2023) – Models 1~4 with Viz & Debug")

with st.sidebar:
    st.markdown("### ⚙️ Options")
    debug_mode = st.checkbox("Show raw header debug (row0/row1) and stop", value=False)
    st.caption("디버그를 켜면 원시 헤더를 출력하고 앱을 멈춥니다.")

# 1) LOAD
try:
    df_mi = read_as_multiindex_v2(DATA_FILE, debug=debug_mode)
except Exception as e:
    st.error(f"Error loading data: {e}")
    st.stop()

st.success("✅ Dataset loaded & cleaned (Row0=Year / Row1=Indicator).")

# 지표명 오탈자 안내: 실제 CSV에 있는 지표명 후보를 보여주고 근사 일치 제안
available_names = sorted(set(df_mi.columns.get_level_values(0)))
needed = [GDP_NAME, GERD_NAME] + MEDIATOR_NAMES + CONFOUNDER_NAMES + MODERATOR_NAMES
missing = [n for n in needed if n not in available_names]
if len(missing) > 0:
    st.warning("다음 지표명이 CSV에서 발견되지 않습니다(철자/공백/기호 확인):")
    for m in missing:
        sugg = get_close_matches(m, available_names, n=3, cutoff=0.6)
        st.write(f"- `{m}`  →  후보: {sugg}")
    st.info("⚠️ 지표명이 정확히 일치하지 않으면 회귀 데이터셋이 비게 됩니다.")

# 2) 분포/상관
st.header("📊 Distributions & Correlations")
flat = df_mi.copy()
flat.columns = [f"{a} [{b}]" for a, b in flat.columns]
num_only = flat.select_dtypes(include=np.number)
if bool(num_only.empty) is False:
    st.write(num_only.describe().T)
    try:
        fig_corr, ax_corr = plt.subplots(figsize=(12, 7))
        sns.heatmap(num_only.corr(), cmap="coolwarm", center=0, ax=ax_corr)
        ax_corr.set_title("Correlation Heatmap (All numeric columns)")
        st.pyplot(fig_corr)
    except Exception:
        st.info("Correlation heatmap skipped.")
else:
    st.info("No numeric columns available after parsing.")

# 3) 고정 페어: GERD(2020) → GDP(2023) (나머지 전부 2023)
st.markdown("---")
st.header(f"🧮 Pair: GERD({X_YEAR}) → GDP({Y_YEAR})  (All other vars at {Y_YEAR})")

df_reg = build_pair_dataset(df_mi, X_YEAR, Y_YEAR)
if df_reg.empty:
    st.error("회귀에 사용할 표본이 없습니다. (ln_X/ln_Y after cleaning). "
             "CSV 지표명/연도 헤더를 확인하세요. (사이드바의 Debug로 원본 헤더 확인 가능)")
    st.stop()

st.subheader("📋 Regression dataset (preview)")
st.dataframe(df_reg.head())

# 4) 산점도(lnX-lnY)
st.subheader("📉 ln(GERD) vs ln(GDP)")
fig_sc, ax_sc = plt.subplots(figsize=(7, 5))
sns.regplot(x="ln_X", y="ln_Y", data=df_reg, scatter_kws={"alpha": 0.6}, ax=ax_sc)
ax_sc.set_xlabel(f"ln GERD ({X_YEAR})")
ax_sc.set_ylabel(f"ln GDP ({Y_YEAR})")
st.pyplot(fig_sc)

# 5) 모델 1~4
models, table = run_models(df_reg)
st.subheader("📘 Model Comparison (β_lnX, p, Adj.R²)")
st.dataframe(table)

fig_r2, ax_r2 = plt.subplots(figsize=(6, 4))
sns.barplot(x="Model", y="Adj.R²", data=table, ax=ax_r2)
ymax = float(table["Adj.R²"].max()) if len(table) else 1.0
ax_r2.set_ylim(0, max(0.1, ymax) * 1.1)
ax_r2.set_title("Adjusted R² across models")
st.pyplot(fig_r2)

with st.expander("Full regression summaries"):
    for k, m in models.items():
        st.markdown(f"**{k}**")
        st.text(m.summary())

# 6) 해석
st.markdown("""
### 🧩 Interpretation (2020→2023)
- **Model 1**: lnGERD(2020) → lnGDP(2023) 기본 탄력성.
- **Model 2**: GDP per Capita, Labor Force(2023) 통제로 **혼란효과** 점검(lnGERD 계수 변화).
- **Model 3**: 특허·연구인력·하이테크수출·기업R&D인력(2023) 추가 → lnGERD 계수 감소/유의성 변화 시 **매개효과** 시사.
- **Model 4**: Government/Business-financed BERD(2023) 상호작용이 유의(p<0.05)하면 **조절효과** 존재.
""")