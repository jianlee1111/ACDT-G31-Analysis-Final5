# -*- coding: utf-8 -*-
"""acdt_g31

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F5fm0D95_3CLMpKv3LVVCJCWz4Vwmcv_
"""

# ================================================================
# ACDT G31 â€“ Fixed Year-Paired Regressions (Colab spec)
#   X : GERD(2020)
#   Y : GDP(2022)  &  GDP(2023)
#   Models 1~4 with Confounders, Mediators, Moderators (interaction)
# ================================================================
import streamlit as st
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import statsmodels.formula.api as smf

st.set_page_config(page_title="ACDT G31 â€“ GERD(2020) â†’ GDP(2022/2023)", layout="wide")

DATA_FILE = "ACDT_final_dataset.csv"   # ë ˆí¬ì— ì˜¬ë¦° CSV ì´ë¦„

# ----------------------------
# 0) File-specific indicator names (ì›ë¬¸)
# ----------------------------
GDP_NAME  = "Real GDP (billion USD, PPP-based, Chain-weighted, 2020 base year)"
GERD_NAME = "Gross Domestic Expenditure on R&D (GERD) (current PPP USD)"

MEDIATOR_NAMES = [
    "Resident Patent Applications",
    "Non-Resident Patent Applications",
    "R&D Researchers per Million People",
    "High-tech Export Share (% of Manufactured Exports)",
    "Business R&D Personnel (FTE)",
]
CONFOUNDER_NAMES = [
    "GDP per Capita",
    "Labor Force Size",
]
MODERATOR_NAMES = [
    "Government-financed BERD (%)",
    "Business-financed BERD (%)",
]

# ----------------------------
# 1) Helpers
# ----------------------------
def to_numeric_series(s: pd.Series) -> pd.Series:
    """ë¬¸ì â†’ ìˆ«ì (Series ì „ìš©)"""
    s = s.astype(str).str.replace(",", "", regex=False)
    s = s.str.replace(r"[^0-9eE+\-\.]", "", regex=True)
    return pd.to_numeric(s, errors="coerce")

def read_as_multiindex(path: str) -> pd.DataFrame:
    """0í–‰=ì—°ë„, 1í–‰=ì§€í‘œëª… CSVë¥¼ MultiIndex ì»¬ëŸ¼ìœ¼ë¡œ ë¡œë“œ + ìˆ«ìí™”"""
    last_err = None
    raw = None
    for enc in ("utf-8-sig", "cp949"):
        try:
            raw = pd.read_csv(path, header=None, encoding=enc, engine="python")
            break
        except Exception as e:
            last_err = e
    if raw is None:
        raise RuntimeError(f"CSV read failed: {last_err}")

    # í•œ ì…€ CSV ë°©ì–´
    if raw.shape[1] == 1 and isinstance(raw.iloc[0, 0], str):
        cell = raw.iloc[0, 0]
        for sep in (",", "\t", ";"):
            if sep in cell:
                raw = raw[0].str.split(sep, expand=True)
                break

    years = raw.iloc[0].astype(str).values
    names = raw.iloc[1].astype(str).values
    df = raw.iloc[2:].copy()
    df.columns = pd.MultiIndex.from_arrays([names, years], names=["Indicator", "Year"])

    # ìˆ«ìí™”(Series ë‹¨ìœ„ë§Œ ì²˜ë¦¬)
    for ind in df.columns.levels[0]:
        block = df.loc[:, ind]
        for yr in block.columns:
            df[(ind, yr)] = to_numeric_series(block[yr])

    # ì—°ë„ ì •ìˆ˜ ìºìŠ¤íŒ… (ê°€ëŠ¥í•œ ê²½ìš°)
    try:
        new_cols = []
        for (ind, yr) in df.columns:
            y = int(float(yr)) if str(yr).replace(".", "", 1).isdigit() else yr
            new_cols.append((ind, y))
        df.columns = pd.MultiIndex.from_tuples(new_cols, names=["Indicator", "Year"])
    except Exception:
        pass

    df.index = pd.RangeIndex(len(df))  # êµ­ê°€ëª… ì—†ìœ¼ë©´ ë‹¨ìˆœ ì¸ë±ìŠ¤
    return df

def get_series(df_mi: pd.DataFrame, indicator: str, year) -> pd.Series:
    """ì§€í‘œ@ì—°ë„ Series ì¶”ì¶œ (ì—†ìœ¼ë©´ NaN Series)"""
    if (indicator in df_mi.columns.get_level_values(0)) and (year in df_mi.loc[:, indicator].columns):
        return df_mi.loc[:, (indicator, year)]
    return pd.Series([np.nan] * len(df_mi), index=df_mi.index)

def assemble_dataset(df_mi: pd.DataFrame, x_year, y_year) -> pd.DataFrame:
    """ê³ ì •ëœ ì—°ë„ìŒìœ¼ë¡œ íšŒê·€ ë°ì´í„°ì…‹ êµ¬ì„± (Colab ìŠ¤í™)"""
    out = pd.DataFrame(index=df_mi.index)
    out["GERD"] = get_series(df_mi, GERD_NAME, x_year)
    out["GDP"]  = get_series(df_mi, GDP_NAME,  y_year)

    # Confounders / Mediators / ModeratorsëŠ” Y-year ê°’ì„ ì‚¬ìš©(Colab íë¦„)
    for nm in CONFOUNDER_NAMES:
        out[nm] = get_series(df_mi, nm, y_year)
    for nm in MEDIATOR_NAMES:
        out[nm] = get_series(df_mi, nm, y_year)
    for nm in MODERATOR_NAMES:
        out[nm] = get_series(df_mi, nm, y_year)

    # ë¡œê·¸ë³€í™˜
    out["ln_X"] = np.log(out["GERD"].replace({0: np.nan}))
    out["ln_Y"] = np.log(out["GDP"].replace({0: np.nan}))

    # ê²°ì¸¡ ì œê±° (ln_X, ln_Y ìµœì†Œ)
    out = out.dropna(subset=["ln_X", "ln_Y"]).reset_index(drop=True)
    return out

def run_models(df_reg: pd.DataFrame):
    """Model 1~4 ì‹¤í–‰ ë° ìš”ì•½í‘œ ë°˜í™˜"""
    # ì•ˆì „í•˜ê²Œ ì¡´ì¬í•˜ëŠ” ë³€ìˆ˜ë§Œ ìˆ˜ì§‘
    confs = [c for c in CONFOUNDER_NAMES if c in df_reg.columns]
    meds  = [m for m in MEDIATOR_NAMES if m in df_reg.columns]
    mods  = [m for m in MODERATOR_NAMES if m in df_reg.columns]

    # Model 1
    m1 = smf.ols("ln_Y ~ ln_X", data=df_reg).fit()

    # Model 2 (+confounders)
    rhs2 = "ln_X" + (" + " + " + ".join([f'Q(\"{c}\")' for c in confs]) if confs else "")
    m2 = smf.ols(f"ln_Y ~ {rhs2}", data=df_reg).fit()

    # Model 3 (+mediators)
    rhs3 = rhs2 + (" + " + " + ".join([f'Q(\"{m}\")' for m in meds]) if meds else "")
    m3 = smf.ols(f"ln_Y ~ {rhs3}", data=df_reg).fit()

    # Model 4 (+moderators as interactions with ln_X)
    inter = " + ".join([f'ln_X * Q(\"{mo}\")' for mo in mods]) if mods else ""
    rhs4 = rhs3 if not inter else f"{rhs3} + {inter}"
    m4 = smf.ols(f"ln_Y ~ {rhs4}", data=df_reg).fit()

    # ë¹„êµí‘œ
    def pick(model, name="ln_X"):
        return model.params.get(name, np.nan), model.pvalues.get(name, np.nan), model.rsquared_adj

    rows = []
    for label, model in [("M1: lnY~lnX", m1), ("M2:+conf", m2), ("M3:+med", m3), ("M4:+mods", m4)]:
        beta, pval, adjr2 = pick(model, "ln_X")
        rows.append([label, beta, pval, adjr2])

    summary = pd.DataFrame(rows, columns=["Model", "Î²(ln_X)", "p(ln_X)", "Adj.RÂ²"]).round(4)
    return {"M1": m1, "M2": m2, "M3": m3, "M4": m4}, summary

# ----------------------------
# 2) Load & Build two fixed pairs (GERD@2020 â†’ GDP@2022, @2023)
# ----------------------------
st.title("ğŸ“ˆ GERD(2020) â†’ GDP(2022/2023) â€“ Full Regressions (Model 1â€“4)")

try:
    df_mi = read_as_multiindex(DATA_FILE)
except Exception as e:
    st.error(f"Error loading data: {e}")
    st.stop()

st.success("âœ… Dataset loaded (0í–‰=Year, 1í–‰=Indicator â†’ MultiIndex).")

# ê³ ì • ì—°ë„
X_YEAR = 2020
Y_YEARS = [2022, 2023]

for yyr in Y_YEARS:
    st.header(f"ğŸ§® Pair: GERD({X_YEAR}) â†’ GDP({yyr})")

    df_reg = assemble_dataset(df_mi, x_year=X_YEAR, y_year=yyr)
    if df_reg.empty:
        st.warning(f"No valid observations for GERD({X_YEAR}) â†’ GDP({yyr}).")
        continue

    st.subheader("ğŸ“‹ Regression dataset (preview)")
    st.dataframe(df_reg.head())

    # ì‚°ì ë„ (ln_GERD_2020 vs ln_GDP_yyr)
    fig, ax = plt.subplots(figsize=(7,5))
    sns.regplot(x="ln_X", y="ln_Y", data=df_reg, ax=ax, scatter_kws={"alpha":0.6})
    ax.set_xlabel(f"ln GERD ({X_YEAR})")
    ax.set_ylabel(f"ln GDP ({yyr})")
    st.pyplot(fig)

    # Model 1~4 ì‹¤í–‰
    models, table = run_models(df_reg)
    st.subheader("ğŸ“˜ Model Comparison")
    st.dataframe(table)

    # RÂ² ë§‰ëŒ€
    fig_r2, ax_r2 = plt.subplots(figsize=(6,4))
    sns.barplot(x="Model", y="Adj.RÂ²", data=table, ax=ax_r2)
    ax_r2.set_ylim(0, max(table["Adj.RÂ²"]) * 1.1 if len(table) else 1)
    st.pyplot(fig_r2)

    with st.expander("Full summaries"):
        for k in ["M1","M2","M3","M4"]:
            st.markdown(f"**{k}**")
            st.text(models[k].summary())

st.caption("All regressions follow your original Colab spec: fixed year-pairs, log-log, Model1~4 with confounders/mediators/moderators.")